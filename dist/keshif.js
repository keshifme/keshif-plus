import { _ as __awaiter, p as purify, s as selection, t as tippy, R as ROUND_ARROW, a as select, c as createPopper, e as extent, l as linear, b as log, m as min, d as max, n as noUiSlider, u as utcParse, f as format, g as cubicOut, h as arc, i as line, j as monotoneX, k as pointer, q as quantile, o as deviation, r as geoBounds, v as time, w as polyInOut, x as hsl, y as geoPath, z as geoTransform, A as quantize, B as linear$1, C as interpolate, D as interpolateHsl, E as rgb, F as curveLinear, G as schemeCategory10, H as polyOut, I as zoom, J as transform, L as identity, M as curveNatural, N as curveCatmullRomOpen, P as Pikaday, O as DateTime, Q as area, S as Interval, T as utcFormat, U as utcTime, V as second, W as utcMinute, X as utcHour, Y as utcDay, Z as utcSunday, $ as utcMonth, a0 as utcYear, a1 as sqrt, a2 as threshold, a3 as d3Chromatic } from './vendor.js';
import { S as Supercluster } from './vendor_mapping.js';

class kshfBase {
    constructor() {
        // active browser
        this.browser = null;
        // all browsers in window
        this.browsers = {};
        // update to support google api loading
        this.gapi = {
            gKey: null,
            clientId: null,
            scope: null,
        };
        // point to where geojson files are hosted
        this.geoFileDir = "";
        this.geoFileExt = "topojson";
        // dt: any = [];
        // dt_id: any = {};
        // Number of maximum visible records (items)
        this.maxVisibleItems_Default = 100;
        // how many rows (records) to look at to auto-detect attributes
        this.autoDetect_RowCount = 10;
        // **************************************************************
        // BASIC CONFIGURATIONS
        this.timeKeyHeight = 35; //
        this.recordRankWidth = 45; //
        this.maxRecordPointSize = 30;
        this.defaultRecordPointSize = 4.5;
        // Categorical chart size settings
        this.height_CatBottom = 36; //
        this.defaultBarHeight = 32; //
        this.width_CatLabelMin = 110; //
        this.width_scatter_margin_left = 85;
        this.height_scatter_margin_bottom = 95; //
        // Interval chart size settings
        this.width_HistBarGap = 2; // Width (pixels) between neighboring histogram bars
        this.width_HistBinDefault = 45;
        this.width_measureDescrLabel = 20; //
        this.height_MaxRatioDefault = 0.3; //
        this.height_HistMin = 40; //
        this.height_HistBottomGap = 12; // Height (pixels) for histogram gap on top.
        this.height_Percentile = 34; // Height (pixels) of percentile chart
        // Other size settings
        this.width_PanelGap = 8; //
        this.width_ScrollBar = 19; // scroll bar width
        this.width_AttribPanelDefault = 250; //
        this.percentDecimal = true; // set to false to not use a decimal point when presenting % labels
        this.defaultDOM = "#kshfDashboard";
        this.Panel_List = ["left", "right", "middle", "bottom"];
        this.defaultMetricFuncs = ["Sum", "Avg"];
        this.Compare_List = [
            "Compare_A",
            "Compare_B",
            "Compare_C",
            "Compare_D",
            "Compare_E",
        ];
        this.maps = new Map();
        this.tables = new Map();
        this.map = {
            tileTemplate: "",
            leafConfig: {
                maxBoundsViscosity: 1,
                worldCopyJump: false,
                // zoom settings
                zoomControl: false,
                boxZoom: false,
                doubleClickZoom: false,
                touchZoom: false,
                zoomSnap: 0.5,
                zoomDelta: 0.5,
                maxZoom: 18,
                minZoom: 1,
                //crs: L.CRS.EPSG3857
                //crs: L.CRS.Simple
            },
            tileConfig: {
                attribution: '&copy; <a href="https://openstreetmap.org/about/" target="_blank">OpenStreetMap</a><br><a href="https://www.mapbox.com/about/maps/" target="_blank">Mapbox</a> &amp; <a href="https://keshif.me" target="_blank">Keshif</a>',
                subdomains: "abcd",
                id: "mapbox.light",
                //noWrap: true
            },
            flyConfig: {
                padding: [0, 0],
                pan: { animate: true, duration: 1.2 },
                zoom: { animate: true },
            },
            pinGlyphPath: `M-0.025 -18 C-4.106 -18 -7.427 -14.751 -7.427 -10.757 -7.427 -5.8 
      -0.803 1.476 -0.521 1.784 -0.256 2.072 0.207 2.072 0.471 1.784 0.753 1.476 7.377 -5.8 
      7.377 -10.757 7.377 -14.751 4.057 -18 -0.025 -18 Z M-0.025 -7.112 C-2.078 -7.112 -3.749 
      -8.747 -3.749 -10.757 -3.749 -12.766 -2.078 -14.401 -0.025 -14.401 2.029 -14.401 3.699 
      -12.766 3.699 -10.757 3.699 -8.747 2.029 -7.112 -0.025 -7.112 Z`,
        };
        this.DOM = {};
        this.custom_icons = {
            trails: `<svg class="custom_icon custom_icon_trails" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 600 500" xml:space="preserve">
        <g>
          <path d="M489.2,65.25c0-35.7-28.5-65.2-64.2-65.2s-64.2,29.6-64.2,65.2c0,28.1,17.7,52.3,42.6,61.4l-28.2,232.3
            c-6.6,0.5-12.9,2-18.7,4.4l-97.1-99.6c1.6-5.8,2.5-11.8,2.5-18.1c0-35.7-28.5-65.2-64.2-65.2s-64.2,29.6-64.2,65.2
            c0,15.6,5.4,29.9,14.5,41.2l-62.3,75.7c-6.7-2.4-14-3.8-21.5-3.8c-35.7,0-64.2,29.6-64.2,65.2c0,35.7,28.5,65.2,64.2,65.2
            c36.7,0,64.2-29.6,64.2-65.2c0-13.3-4-25.8-10.9-36.2l64.8-78.8c4.9,1.2,10,1.9,15.3,1.9c14.5,0,27.8-4.9,38.5-13.1l89.4,91.8
            c-6.2,10-9.7,21.8-9.7,34.4c0,35.7,28.5,65.2,64.2,65.2s64.2-29.6,64.2-65.2c0-23.1-12-43.6-30.1-55.2l29.5-241
            C470.1,119.55,489.2,94.45,489.2,65.25z M425,40.85c12.2,0,23.4,11.2,23.4,24.5s-11.2,24.5-23.4,24.5s-23.4-11.2-23.4-24.5
            S411.7,40.85,425,40.85z M64.2,448.45c-12.2,0-23.4-11.2-23.4-24.5c0-13.2,10.2-24.5,23.4-24.5s23.4,11.2,23.4,24.5
            C87.7,437.25,76.4,448.45,64.2,448.45z M197.7,270.15c-12.2,0-23.4-11.2-23.4-24.5c0-13.2,10.2-24.5,23.4-24.5
            s23.4,11.2,23.4,24.5C221.2,258.95,209.9,270.15,197.7,270.15z M380.1,448.45c-12.2,0-23.4-11.2-23.4-24.5
            c0-13.2,10.2-24.5,23.4-24.5c13.2,0,23.4,11.2,23.4,24.5C403.6,437.25,392.4,448.45,380.1,448.45z"/>
        </g>
      </svg>`,
        };
        this.WebFontConfig = {
            google: {
                families: [
                    "Roboto:100,300,400,500,700:latin",
                    "Roboto+Slab:300,400,700",
                    "Roboto+Condensed:300,400",
                ],
            },
        };
        this.loadResources = function () {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._resourcesLoaded === true)
                    return;
                // Load common fonts
                window["WebFontConfig"] = this.WebFontConfig;
                yield import('https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js');
                //window.WebFont.load(this.WebFontConfig); // or, after loading the script
                window.addEventListener("resize", () => {
                    for (var id in this.browsers) {
                        this.browsers[id].setNoAnim(true);
                        this.browsers[id].updateLayout();
                    }
                    if (this._resizeTimeout) {
                        window.clearTimeout(this._resizeTimeout);
                    }
                    this._resizeTimeout = window.setTimeout(() => {
                        for (var id in this.browsers)
                            this.browsers[id].setNoAnim(false);
                    }, 500);
                }, false);
                this._resourcesLoaded = true;
                return true;
            });
        };
    }
    get Active_Compare_List() {
        let m = ["Active"];
        return m.concat(this.Compare_List);
    }
    get Total_Active_Compare_List() {
        let m = ["Total", "Active"];
        return m.concat(this.Compare_List);
    }
    reloadWithNewConfig(dashboard, newConfig) {
        this.tables.delete(dashboard.primaryTableName);
        return new Browser(newConfig);
    }
    ;
}
var Base = new kshfBase();
window["kshf"] = Base;

purify.setConfig({
    USE_PROFILES: { html: true, svg: true },
    ALLOWED_ATTR: ["target"],
    //'FORBID_ATTR': ['rel'],
    //'ALLOW_DATA_ATTR': false
});
// Open links in new window
purify.addHook("afterSanitizeAttributes", function (node) {
    if ("target" in node) {
        node.setAttribute("target", "_blank");
    }
});
function isObject(item) {
    return item && typeof item === "object" && !Array.isArray(item);
}
function mergeDeep(target, ...sources) {
    if (!sources.length)
        return target;
    const source = sources.shift();
    if (isObject(target) && isObject(source)) {
        for (const key in source) {
            if (isObject(source[key]) && !(source[key] instanceof HTMLElement)) {
                if (!target[key])
                    Object.assign(target, { [key]: {} });
                mergeDeep(target[key], source[key]);
            }
            else {
                Object.assign(target, { [key]: source[key] });
            }
        }
    }
    return mergeDeep(target, ...sources);
}
selection.tippyDefaultConfig = {
    allowHTML: true,
    animation: "scale",
    animateFill: false,
    theme: "dark kshf-tooltip",
    arrow: ROUND_ARROW,
    delay: [500, 50],
    duration: [350, 250],
    maxWidth: 350,
    placement: "auto",
    popperOptions: {
        modifiers: [
            {
                name: "flip",
                enabled: true,
                options: {
                    padding: 10,
                },
            },
        ],
    },
};
selection.prototype.tooltip = function (param1, param2) {
    var config = param2 ? param2 : typeof param1 === "object" ? param1 : null;
    var title = param2 ? param1 : typeof param1 === "object" ? null : param1;
    // this ensures that tooltips are visible if the dashboard is made full-screen
    var appendTo = Base.browser ? Base.browser.DOM.root.node() : document.body;
    var tippyConfig = Object.assign({ appendTo: appendTo }, selection.tippyDefaultConfig);
    mergeDeep(tippyConfig, config);
    tippyConfig.popperOptions.modifiers[0].options.boundariesElement =
        tippyConfig.appendTo;
    if (title) {
        if (typeof title === "string") {
            title = purify.sanitize(title);
            //
        }
        else if (typeof title === "function") {
            tippyConfig.onShow = (instance) => {
                instance.reference.tippy.setContent(purify.sanitize(title(instance.reference.__data__)));
                return true;
            };
        }
    }
    this.each(function () {
        if (this.tippy) {
            this.tippy.destroy();
        }
        this.tippy = tippy(this, tippyConfig);
        if (typeof title === "string") {
            this.tippy.setContent(title);
        }
    });
    return this;
};
function htmlRemove() {
    this.innerHTML = "";
}
function htmlConstant(value) {
    return function () {
        this.innerHTML = purify.sanitize(value);
    };
}
function htmlFunction(value) {
    return function () {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : purify.sanitize(v);
    };
}
selection.prototype.html = function (value) {
    return arguments.length
        ? this.each(value == null
            ? htmlRemove
            : (typeof value === "function" ? htmlFunction : htmlConstant)(value))
        : this.node().innerHTML;
};

class i18n_EN {
    constructor() {
        this.LANG_NAME = "English";
        this.LoadingData = "Loading data...";
        this.CreatingBrowser = "Creating Dashboard...";
        this.Close = "Close";
        this.Help = "Help";
        this.RemoveFilter = "Remove filter";
        this.RemoveHighlight = "Remove highlight";
        this.RemoveAllFilters = "Remove all filters";
        this.LockToCompare = "Compare";
        this.Unlock = "Remove comparison";
        this.CompareTopCategories = "Compare top categories";
        this.Compare = "Compare";
        (this.LockCrumbMode = (stacked) => `<b>${stacked ? "Stacked" : "Side-by-side"} charts</b><br> are used for comparison.<br><br>
        Click to switch to ${stacked ? "side-by-side" : "stacked"} charts.`),
            (this.SideBySide = "Side-by-Side");
        this.Stacked = "Stacked";
        this.GroupView = "Group-View";
        this.CollapseSummary = "Close";
        this.OpenSummary = "Open";
        this.ExpandSummary = "Maximize";
        this.RemoveSummary = "Remove";
        this.Confirm = "Confirm";
        this.Cancel = "Cancel";
        this.OK = "OK";
        this.Delete = "Delete";
        this.NoAttribute = "(None)";
        this["No [Record]"] = "No";
        this["Absolute (Breakdown)"] = "Absolute";
        this.SetPairTitle = (v) => `${v}->Relations`;
        this.DialogSideBySideCharts =
            "<u class='learnIcon' data-helparticle='5e88ff692c7d3a7e9aea6475'>Stacked charts</u>";
        this.DialogStackedCharts =
            "<u class='learnIcon' data-helparticle='5e88ff692c7d3a7e9aea6475'>Stacked charts</u>";
        this.DialogComparisonSelection =
            "<u class='learnIcon' data-helparticle='5e8905262c7d3a7e9aea6483'>Compare-selection</u>";
        this.DialogRelativeBreakdown =
            "<u class='learnIcon' data-helparticle='5e8944932c7d3a7e9aea659c'>%-of-groups breakdown</u>";
        this.DialogDependentBreakdown =
            "<u class='learnIcon' data-helparticle='5e8944812c7d3a7e9aea659b'>%-of-compared breakdown</u>";
        (this.DialogEmptyResultSet =
            "Removing this category will create an empty result list."),
            (this.DialogChangeCompare = (_to, _from) => `To compare by <i>${_to}</i>,<br> we need to remove the current comparison on <i>${_from}</i>.`);
        this.DialogStackedMultiValue = (_name) => this.DialogStackedCharts +
            ` cannot be enabled while comparing on<br> multi-valued categorical attribute:<br><i>${_name}</i>.`;
        this.DialogSideBySideSingleValue = (_name) => this.DialogSideBySideCharts +
            ` cannot be enabled while comparing on<br> single-valued categorical attribute:<br><i>${_name}</i><br>using ${this.DialogRelativeBreakdown}.`;
        this.DialogCompareForRelative = `Apply ${this.DialogComparisonSelection} first before switching to ${this.DialogRelativeBreakdown}.`;
        this.ComparedSelectionsLimit =
            "You cannot compare across more than five data groups.";
        this.ZoomLevelWarning =
            "" +
                "Your current browser zoom level may not be optimal for charting.<br>" +
                "For best results, " +
                "<span class='link attemptToFix'><i class='fa fa-magic'></i>click here to fix and refresh</span>, or<br>" +
                "if issue persists, manually reset your browser zoom and refresh the page.<br>" +
                "<a class='link' style='font-weight: 300' href='https://help.keshif.me/article/49-resolving-chart-display-issues'>" +
                "More info</a>";
        this.MeasureDescrLabel = (dashboard, summary) => {
            var _a, _b;
            const measureText_simple = dashboard.measureFunc_Count
                ? ""
                : `${dashboard.measureFunc} of ${dashboard.measureSummary.get().printName}`;
            const comparedBy = (_b = (_a = dashboard.comparedAttrib) === null || _a === void 0 ? void 0 : _a.printName) !== null && _b !== void 0 ? _b : null;
            const breakdown = dashboard.breakdownMode.get();
            if (breakdown == "absolute") {
                return (measureText_simple || dashboard.recordName) + (comparedBy ? ` by ${comparedBy}` : ``);
            }
            // PERCENTAGE-BASED BREAKDOWN
            const measureText_all = measureText_simple || `${dashboard.isFiltered() ? "filtered" : "all"} ${dashboard.recordName}`;
            if (!comparedBy) {
                return `% of ${measureText_all}`;
            }
            switch (breakdown) {
                case "dependent": return `${summary.printName} % , out of ${comparedBy} ${measureText_simple}`;
                case "relative": return `${comparedBy} % , out of ${summary.printName} ${measureText_simple}`;
                case "total": return `Combined % , out of ${measureText_all}`;
            }
        };
        this.measureText = (dashboard) => (dashboard.measureFunc_Count)
            ? dashboard.recordName
            : `${dashboard.measureFunc} of ${dashboard.measureSummary.get().printName}`;
        this.measureText_2 = (dashboard) => (dashboard.measureFunc_Count)
            ? ""
            : `${dashboard.measureFunc} of ${dashboard.measureSummary.get().printName} of `;
        this.ListButton = "List";
        this.MapButton = "Map";
        this.NodeButton = "Node-Link";
        this.TimeSeriesButton = "Time";
        this.ScatterButton = "Scatter";
        this.RecordViewTypeTooltip = (v) => `View ${Base.browser.recordName} on <br><b>${v}</b> chart`;
        this.Boost_NoSuggestions = "No suggested changes. Explore on!";
        this.TooltipOne = (_v, dashboard) => `${dashboard.getValueLabel(_v, false, 1, true)} of
        ${dashboard.isFiltered() ? dashboard.getFilteredSummaryText() : "all"}
        ${dashboard.recordName}`;
        this.Tooltip_OutOf = (_v, dashboard) => {
            var _a;
            var str = "";
            if (dashboard.absoluteBreakdown)
                return str;
            str += "<div class='percentageExplainer'>";
            if (dashboard.relativeBreakdown) {
                str += "% out of <i>" + _v + "</i>";
            }
            else if (dashboard.dependentBreakdown) {
                str += "% out of <i>" + ((_a = dashboard.comparedAttrib) === null || _a === void 0 ? void 0 : _a.printName) + "</i>";
            }
            else {
                str += "% out of all";
            }
            str += "</div>";
            return str;
        };
        this.Size = "Size";
        this.Larger = "Larger";
        this.Smaller = "Smaller";
        this.Pairs = "Pairs";
        this.Color = "Color";
        this.InvertColorTheme = "Invert color theme";
        this.ChangeColorTheme = "Change color theme";
        this.ReverseOrder = "Reverse order";
        this.Reorder = "Reorder";
        this.SwapAxis = "Swap axis";
        this.Percentiles = "Percentiles";
        this.OpenDataSource = "Open Data Source";
        this.ShowInfoCredits = "Info";
        this.ShowFullscreen = "Fullscreen";
        this.PrintButton =
            "Click to activate print style<br><b>Shift+click</b> to print.";
        this.Search = "Search";
        (this.TextSearchForRecords = `Type to search and highlight.<br><br>+
        <b><u>Enter</u></b> to filter <i class="fa fa-filter"></i>`),
            (this.ClearTextSearch = "Clear");
        this.Rows = "Rows";
        this.More = "More";
        this.ScrollToTop = "Top";
        this.Percent = "Percent";
        this.Absolute = "Absolute";
        this.Relative = "Relative";
        this.Dependent = "Dependent";
        this.Breakdown = "Breakdown";
        this.BreakdownBy = "Breakdown by";
        this.Total = "Prozentuale";
        this.SeeBreakdown = (v) => `See <b>${this[v.charAt(0).toUpperCase() + v.slice(1)]}</b> Breakdown`;
        this.DragToFilter = "Drag";
        this.And = "And";
        this.Or = "Or";
        this.Not = "Not";
        this.NoData = "Missing data";
        this.ValidData = "Valid data";
        this.KeepNoData = "Keep missing data";
        this.KeepValidData = "Keep valid data";
        this.ZoomToFit = "Zoom to fit";
        this.ZoomIn = "Zoom In";
        this.ZoomOut = "Zoom Out";
        this.MeasureScale = "Scale";
        this.RowHeight = "Bar Height";
        this.RowOrder = "Order";
        this.Charts = "Charts";
        this.Charts_Histogram = "Histogram";
        this.Charts_Percentiles = "Percentiles";
        this.BinScale = "Value Axis Scale";
        this.BinWidth = "Bin Width";
        this.BinWidth_Narrow = "Narrow";
        this.BinWidth_Medium = "Medium";
        this.BinWidth_Wide = "Wide";
        this.BinHeight = "Height";
        this.BinHeight_Compact = "Compact";
        this.BinHeight_Short = "Short";
        this.BinHeight_Medium = "Medium";
        this.BinHeight_Tall = "Tall";
        this.DashboardAnalyticsConfig = "Dashboard Configuration";
        this.ViewAsMap = "View as Map";
        this.ViewAsList = "View as List";
        this.ViewSetMatrix = "Show/Hide pair-wise relations";
        this.MissingLocations = "Missing<br>Locations";
        this.Reset = "Reset";
        this.measure_Sum = "Sum";
        this.measure_Avg = "Average";
        this.measure_Count = "Count";
        this.Of_NumberRecord = "of";
        this.AutoPlay = "Autoplay";
        this.StopAutoPlay = "Stop Autoplay";
        this.SaveSelection = "Save selection";
        this.EditFormula = "Edit formula";
        this.Attributes = "Attributes";
        this.DatasetButton = "Attributes";
        this.AdjustButton = "Adjust";
        this.SaveShareButton = "Save";
        this.CategoricalAttribute = "Categorical";
        this.NumericAttribute = "Numeric";
        this.TimestampAttribute = "Timestamp";
        this.TimeseriesAttribute = "Timeseries";
        this.LocationAttribute = "Geographic";
        this.UnknownAttribute = "Unknown";
        this.UniqueAttribute = "Unique";
        this.MultiValuedAttribute = "Multi-valued";
        this.FunctionAttribute = "Uses Custom Function";
        this.ContentAttribute = "Content";
        this.Configure = "Configure";
        this.Derive = "Derive";
        // Adjust
        this.EditTitle = "Rename";
        this.RemoveRecordPanel = "Remove record panel";
        this.EmptyDashboardNotice = `To add data into the dashboard : <br><br>
          <i class='far fa-angle-double-down'></i> switch to <span style='font-weight: bolder'>Author</span> mode,<br>and <br>
          <i class='far fa-angle-double-left'></i> double-click, or
          click+drag an attribute into this canvas.
          <br> <img class='kshfLogo_K'>`;
        this.LinearSequence =
            "<span style='font-size:0.8em; opacity: 0.75'>(1,2,3,4)</span>";
        this.Log2Sequence =
            "<span style='font-size:0.8em; opacity: 0.75'>(1,2,4,8)</span>";
        this.Log10Sequence =
            "<span style='font-size:0.8em; opacity: 0.75'>(1,10,100)</span>";
        this.Error_CannotFindMap = (mapName) => `<i class='fal fa-frown'></i> We could not find the map [${mapName}].`;
        this.Error_CannotLoadMap = (mapName) => `<i class='fal fa-frown'></i> We could not load the map [${mapName}].`;
        this.Error_CannotMatchMap = (mapName) => `<i class='fal fa-frown'></i> We could not match any location name with the map [${mapName}].`;
        // Platform-specific
        this.RemoveDataset = "Remove Dataset";
        this.Bookmark = "Bookmark<br><i>Shift+Click to delete</i>";
        // Keeping these because they are referenced from lang table to create derived summaries
        this.Lookup_Months = {
            0: "January",
            1: "February",
            2: "March",
            3: "April",
            4: "May",
            5: "June",
            6: "July",
            7: "August",
            8: "September",
            9: "October",
            10: "November",
            11: "December",
        };
        this.Lookup_DaysOfWeek = {
            0: "Sunday",
            1: "Monday",
            2: "Tuesday",
            3: "Wednesday",
            4: "Thursday",
            5: "Friday",
            6: "Saturday",
        };
    }
}

let ActiveLanguage = null; // internal variable (singleton, always created);
let LoadLanguage = function (langSpec) {
    ActiveLanguage = new Proxy(langSpec, {
        // returns the value in indexed position if it exists. Otherwise, returns the key.
        get: function (obj, prop) {
            return prop in obj ? obj[prop] : prop;
        },
    });
};
// Main object used to index translation keys.
// Loads the default language (i18n_EN) if it's not defined yet.
var i18n = new Proxy({}, {
    // using proxy feature to adjust return values...
    get: function (obj, prop) {
        // if not defined, load English
        if (!ActiveLanguage)
            LoadLanguage(new i18n_EN());
        return ActiveLanguage[prop];
    },
});

/** -- */
class Filter_Base {
    get isFiltered() {
        return this._isFiltered;
    }
    /** -- */
    constructor(_browser) {
        // Each filter has its own breadcrumb
        this.breadcrumb = null;
        this._isFiltered = false;
        this.how = "All";
        this.browser = _browser;
        this.filterID = this.browser.filterCounter++;
        // Initialize all records to true (Not filtered) for current filter ID
        this.browser.records.forEach((record) => record.setFilterCache(this.filterID, true));
        this.browser.filters.push(this);
    }
    /** -- */
    setFiltered(update = true) {
        if (this.browser.singleFiltering) {
            // TODO check logic
            return;
        }
        this._isFiltered = true;
        if (!update)
            return;
        this.browser.refresh_filterClearAll();
        this.applyFilter();
        var stateChanged = false;
        var how = 0;
        if (this.how === "LessResults")
            how = -1;
        if (this.how === "MoreResults")
            how = 1;
        this.browser.records.forEach((record) => {
            if (how < 0 && record.filteredOut)
                return;
            if (how > 0 && !record.filteredOut)
                return;
            stateChanged = record.refreshFilterCache() || stateChanged;
        });
        if (stateChanged) {
            this.browser.updateRecordCount_Active();
            this.browser.updateAfterFilter();
        }
    }
    /* -- */
    applyFilter() {
        if (!this.breadcrumb) {
            this.breadcrumb = this.browser.createNewCrumb();
        }
        this.onFilter();
        this.breadcrumb.showCrumb("Filter", this);
    }
    /** -- */
    getRichText() {
        return `${this.title}: ${this.filterView_Detail()}`;
    }
    /** -- */
    getRichText_flipped() {
        return `${this.filterView_Detail()} [${this.title}]`;
    }
    /** -- */
    clearFilter(forceUpdate = true) {
        var _a;
        if (!this._isFiltered)
            return false; // TO-DO: Does this break anything?
        this._isFiltered = false;
        this.browser.records.forEach((rec) => rec.setFilterCache(this.filterID, true));
        (_a = this.breadcrumb) === null || _a === void 0 ? void 0 : _a.removeCrumb();
        this.breadcrumb = null;
        this.onClear(forceUpdate);
        if (forceUpdate !== false) {
            this.browser.records.forEach((rec) => rec.filteredOut && rec.refreshFilterCache());
            this.browser.updateRecordCount_Active();
            this.browser.updateAfterFilter(true);
        }
        if (!this.browser.isFiltered()) {
            this.browser.filters_wrap_letItWrap = false;
            this.browser.DOM.breadCrumbs_Filter.classed("collapsed", false);
        }
        return true;
    }
}
/** adds this attribute - these filters work on an individual attribute */
class Filter extends Filter_Base {
    get noValueAggr() {
        return this.attrib.noValueAggr;
    }
    /** -- */
    constructor(_browser) {
        super(_browser);
    }
    /** -- */
    onFilter() {
        var _a;
        (_a = this.attrib.block) === null || _a === void 0 ? void 0 : _a.refreshUIFiltered(true);
        // clear compare selections - these items cannot be within the filtered area
        if (this.attrib.isComparedAttrib()) {
            Base.Compare_List.forEach((cT) => {
                if (this.browser.selectedAggrs[cT]) {
                    this.browser.clearSelect_Compare(cT, true, true);
                }
            });
        }
    }
    /** -- */
    onClear(forceUpdate = false) {
        var _a, _b;
        (_a = this.attrib.block) === null || _a === void 0 ? void 0 : _a.refreshUIFiltered(false);
        (_b = this.attrib.block) === null || _b === void 0 ? void 0 : _b.onClearFilter(forceUpdate);
    }
}
/**
 * @constructor
 */
class Filter_Record extends Filter_Base {
    /** -- */
    constructor(browser) {
        super(browser);
        this.removedRecords = [];
    }
    /** -- */
    removeRecord(_record) {
        _record.setFilterCache(this.filterID, false);
        this.removedRecords.push(_record);
        this.setFiltered();
    }
    /** -- */
    get title() {
        return `<i class='far fa-times-circle></i> ${i18n.Removed}`;
    }
    /** -- */
    onClear() {
        this.removedRecords = [];
    }
    /** -- */
    filterView_Detail() {
        return this.removedRecords.length + " " + this.browser.recordName;
    }
    /** -- */
    onFilter() { }
    /** -- */
    exportFilter() {
        return this.removedRecords.map((r) => r.id);
    }
    /** -- */
    importFilter(_) {
        var recordIndex = Base.tables.get(this.browser.primaryTableName);
        if (!recordIndex)
            return;
        this.removedRecords = [];
        _.forEach((recID) => {
            var record = recordIndex[recID];
            if (record) {
                this.removedRecords.push(record);
                record.setFilterCache(this.filterID, false);
            }
        });
        if (this.removedRecords.length > 0) {
            this.setFiltered(false);
            this.applyFilter();
        }
    }
}
/** -- */
class Filter_Text extends Filter_Base {
    /** -- */
    constructor(browser) {
        super(browser);
        this.multiMode = "and";
        // This is the text query string, populated by user input
        this._queryString = null;
        this._queryString = null;
    }
    /** -- */
    get title() {
        return this.browser.recordDisplay.textAttrib_Brief.attribName;
    }
    /** -- */
    filterView_Detail() {
        return this._queryString;
    }
    /** -- */
    onClear() {
        this.browser.recordDisplay.DOM.recordTextSearch.classed("showClear", false);
        this.browser.recordDisplay.DOM.recordTextSearch
            .select("input")
            .node().value = "";
    }
    /** -- */
    onFilter() {
        this.browser.recordDisplay.DOM.recordTextSearch.classed("showClear", true);
        // go over all the records in the list, search each keyword separately
        var _summary = this.browser.recordDisplay.textAttrib_Brief;
        this.browser.records.forEach((record) => {
            var v = _summary.getRecordValue(record);
            var f = false;
            if (v) {
                let v2 = v.join(" ").toLowerCase();
                if (this.multiMode === "or") {
                    f = !this.filterQuery.every((v_i) => v2.indexOf(v_i) === -1);
                }
                else if (this.multiMode === "and") {
                    f = this.filterQuery.every((v_i) => v2.indexOf(v_i) !== -1);
                }
            }
            record.setFilterCache(this.filterID, f);
        });
    }
    /** -- */
    set queryString(v) {
        this._queryString = v.toLowerCase();
        // convert string to query pieces
        this.filterQuery = [];
        if (this._queryString !== "") {
            // split the input by " character
            this._queryString.split('"').forEach((block, i) => {
                if (i % 2 === 0) {
                    block.split(/\s+/).forEach((q) => this.filterQuery.push(q));
                }
                else {
                    this.filterQuery.push(block);
                }
            });
            // Remove the empty strings
            this.filterQuery = this.filterQuery.filter((v) => v !== "");
        }
    }
    get queryString() {
        return this._queryString;
    }
    /** -- */
    importFilter(_) {
        if (typeof _ === "string")
            _ = { query: _ };
        if (!_.query)
            return;
        this.queryString = _.query;
        if (_.multiMode)
            this.multiMode = _.multiMode;
        if (this.isFiltered) {
            this.browser.recordDisplay.DOM.recordTextSearch
                .select(".textSearchInput")
                .node().value = _.query;
            this.applyFilter();
        }
    }
    /** -- */
    exportFilter() {
        return {
            query: this._queryString,
            multiMode: this.multiMode,
        };
    }
}

const d3$q = { select };
class Modal {
    /** -- */
    static alert(message, header = "") {
        return new Promise((resolve, reject) => {
            var _wrapper;
            if (Base.browser) {
                _wrapper = Base.browser.DOM.overlay_wrapper;
            }
            else {
                Base.DOM.Modal = d3$q
                    .select("body")
                    .append("div")
                    .attr("class", "kshf kshf_Modal");
                _wrapper = Base.DOM.Modal.append("div").attr("class", "overlay_wrapper");
            }
            var _root = _wrapper
                .append("div")
                .attr("class", "overlay_content overlay_modal")
                .html(`<div class='overlay_Header'>${header}<i class='fa fa-warning'></i></div>
          <div class='overlay_Content'>${message}</div>
          <div class='ModalButtons'>
            <div class='modalButton confirmButton'>${i18n.OK}</div>
          </div>`);
            Modal.createHelpScoutLinks(_root, true);
            _wrapper.attr("show", "modal");
            _root.select(".confirmButton").on("click", (event) => {
                Modal._removeModal(_wrapper);
                if (resolve)
                    resolve(true);
            });
        });
    }
    /** -- */
    static confirm(message, okText, cancelText = null) {
        return new Promise((resolve, reject) => {
            var _wrapper;
            if (Base.browser) {
                _wrapper = Base.browser.DOM.overlay_wrapper;
            }
            else {
                // there's no keshif browser, attach to main body of the page.
                Base.DOM.Modal = d3$q
                    .select("body")
                    .append("div")
                    .attr("class", "kshf kshf_Modal");
                _wrapper = Base.DOM.Modal.append("div").attr("class", "overlay_wrapper");
            }
            _wrapper.attr("show", "modal");
            var _root = _wrapper
                .append("div")
                .attr("class", "overlay_content overlay_modal")
                .html(`<div class='overlay_Header'><i class='fa fa-question-circle'></i></div>
          <div class='overlay_Content'>${message}</div>
          <div class='ModalButtons'>
            <div class='modalButton confirmButton'>${okText || i18n.OK}</div>
            <div class='modalButton rejectButton'>${cancelText || i18n.Cancel}</div>
          </div>
          `);
            _root.select(".confirmButton").on("click", (event) => {
                Modal._removeModal(_wrapper);
                resolve(new MouseEvent(event.type, event));
            });
            _root.select(".rejectButton").on("click", () => {
                Modal._removeModal(_wrapper);
                if (reject)
                    reject(false);
            });
        });
    }
    /** -- */
    static prompt(message, _default) {
        return window.prompt(message, _default);
        // TO-DO: Make it a promise & modal dialogue box
    }
    /** -- */
    static autoChanges(_changes) {
        return new Promise(function (resolve, reject) {
            var _wrapper;
            if (Base.browser) {
                _wrapper = Base.browser.DOM.overlay_wrapper;
                _wrapper.selectAll(".overlay_modal").remove();
            }
            else {
                Base.DOM.Modal = d3$q
                    .select("body")
                    .append("div")
                    .attr("class", "kshf kshf_Modal");
                _wrapper = Base.DOM.Modal.append("div").attr("class", "overlay_wrapper");
            }
            var _root = _wrapper
                .append("div")
                .attr("class", "overlay_content overlay_modal").html(`
          <div class='overlay_Header'>Review Changes <i class='fa fa-question-circle'></i></div>
          <div class='overlay_Content'></div>
          <div class='ModalButtons'>
            <div class='modalButton confirmButton'>OK</div>
            <div class='modalButton rejectButton'>Cancel</div>
          </div>
          `);
            _wrapper.attr("show", "modal");
            var _ = _root.select(".overlay_Content");
            _.html("").style("text-align", "left"); // clear content
            _.append("div").html("We identified the following potential changes: ");
            var changeList = _.append("table").attr("class", "changeList");
            var __ = changeList
                .selectAll(".changeRow")
                .data(_changes)
                .enter()
                .append("tr")
                .attr("class", "changeRow");
            __.append("td")
                .attr("class", "changeIcon")
                .html((d) => d.i);
            __.append("td")
                .attr("class", "changeText")
                .html((d) => d.q);
            var _t = __.append("td").attr("class", "changeToggle");
            _t.append("input")
                .attr("class", "theToggleInput")
                .attr("type", "checkbox")
                .attr("checked", (d) => {
                return d.change ? true : null;
            })
                .attr("id", (_, i) => {
                return "toggle_" + i;
            })
                .on("change", (event, d) => {
                d.change = !d.change;
            });
            _t.append("label")
                .attr("class", "theToggleLabel")
                .attr("for", (_, i) => {
                return "toggle_" + i;
            });
            _root.select(".confirmButton").on("click", () => {
                _wrapper.attr("show", "none");
                _root.classed("modalAlert", false);
                if (Base.DOM.Modal)
                    Base.DOM.Modal.remove();
                if (resolve)
                    resolve(_changes);
            });
            _root.select(".rejectButton").on("click", () => {
                _wrapper.attr("show", "none");
                _root.remove();
                if (Base.DOM.Modal)
                    Base.DOM.Modal.remove();
                if (reject)
                    reject(false);
            });
        });
    }
    /** -- */
    static _removeModal(_wrapper) {
        var _a;
        _wrapper.select(".overlay_modal").remove();
        // Keshif-dashboard
        if (_wrapper.selectAll(".overlay_modal").nodes().length === 0) {
            _wrapper.attr("show", "none");
        }
        // Non-Keshif modal window
        (_a = Base.DOM.Modal) === null || _a === void 0 ? void 0 : _a.remove();
    }
    /** -- */
    static popupMenu(event, template, param, opts = null) {
        var _a;
        var dashRootDOM = Base.browser.DOM.root;
        if (Base.popupInstance &&
            Base.popupInstance.state.elements.reference === event.target) {
            return;
        }
        // remove existing popup menu
        if (dashRootDOM.select(".contextMenu")) {
            dashRootDOM.select(".contextMenu").remove();
        }
        var contextMenu = dashRootDOM.append("div").attr("class", "contextMenu");
        var contextArrow = contextMenu.append("div").attr("class", "popperArrow");
        var removePopper = () => {
            contextMenu.remove();
            if (Base.popupInstance) {
                var t = Base.popupInstance.state.elements.reference;
                while (t && t.classList) {
                    t.classList.remove("popupVisible");
                    t = t.parentNode;
                }
            }
            Base.popupInstance = null;
        };
        Base.popupInstance = createPopper(event.currentTarget, // reference
        contextMenu.node(), // popper
        {
            placement: (_a = opts === null || opts === void 0 ? void 0 : opts.placement) !== null && _a !== void 0 ? _a : "right-start",
            strategy: "absolute",
            modifiers: [
                {
                    name: "flip",
                    enabled: true,
                },
                {
                    name: "offset",
                    options: {
                        offset: [0, 8],
                    },
                },
                {
                    name: "arrow",
                    options: {
                        element: contextArrow.node(),
                        padding: 4,
                    },
                },
            ],
        });
        contextMenu
            .append("div")
            .attr("class", "popupMenu_Close")
            .tooltip(i18n.Close)
            .html("<i class='fa fa-window-close'></i>")
            .on("click", () => removePopper());
        contextMenu
            .append("div")
            .attr("class", "contextMenu_Header")
            .html(i18n[template.name]);
        var contextMenu_Items = contextMenu
            .append("div")
            .attr("class", "contextMenu_Items");
        contextMenu_Items.selectAll(".popupMenuItem").remove();
        var isWhen = (item) => !item.when || item.when(param);
        var isApplicable = (item) => {
            // we know it's not applicable
            if (item.when && !item.when(param))
                return false;
            // no options, just check current item
            if (!item.options)
                return isWhen(item);
            // convert from function to proper list
            var _options = item.options;
            if (typeof item.options === "function") {
                if (!isWhen(item))
                    return false;
                _options = item.options(param);
            }
            return _options.some(isApplicable) && isWhen(item);
        };
        var addTitleText = (_) => {
            _.filter((item) => item.iconClass)
                .append("span")
                .attr("class", "popupMenuItem_Header_Icon")
                .append("span")
                .attr("class", (item) => item.iconClass);
            _.filter((item) => item.iconXML)
                .append("span")
                .attr("class", "popupMenuItem_Header_Icon")
                .html((item) => item.iconXML);
            _.append("span")
                .attr("class", "popupMenuItem_Header_Text")
                .call((header) => {
                header
                    .append("div")
                    .attr("class", "mainText")
                    .html((item) => i18n[item.name]);
                header
                    .filter((item) => item.sampleValue)
                    .append("div")
                    .attr("class", "sampleValue")
                    .html((item) => i18n[item.sampleValue]);
            });
            _.filter((item) => item.helparticle)
                .append("span")
                .attr("class", "helparticle fal fa-question-circle")
                .attr("data-helparticle", (item) => item.helparticle)
                .tooltip(i18n["Learn more"], { placement: "bottom" })
                .on("click", (event, item) => {
                Modal.attachHelpScout().then(() => window.Beacon("article", item.helparticle, { type: "modal" }));
                event.stopPropagation();
                event.preventDefault();
            });
            _.filter((item) => item.options)
                .append("i")
                .attr("class", "expandCollapseIcon fa fa-caret-down");
            _.each((item, i, nodes) => {
                if (item.onName)
                    item.onName(nodes[i]);
            });
        };
        function insertChildItems(DOM, items, parentD = null) {
            DOM.selectAll(".popupMenuItem")
                .data(items.filter(isApplicable))
                .enter()
                .append("div")
                .attr("class", "popupMenuItem")
                .classed("expanded", (item) => item.expanded)
                .attr("data-itemID", (item) => item.id || null)
                .call((_) => {
                _.append("div")
                    .attr("class", "popupMenuItem_Header")
                    .classed("active", (item) => {
                    if (item.active) {
                        if (typeof item.active === "function") {
                            return item.active(param);
                        }
                        else {
                            return !!item.active;
                        }
                    }
                })
                    .each((d2) => {
                    d2.parentD = parentD;
                })
                    .on("click", processItem)
                    .call(addTitleText);
                _.append("div")
                    .attr("class", "popupMenuItem_Children")
                    .each((item, i, nodes) => {
                    if (item.expanded) {
                        // do not over-write this.
                        // the options function, if there is, need to be dynamically evaluated every time.
                        var _options = item.options;
                        if (typeof item.options === "function" && isWhen(item))
                            _options = item.options(param);
                        insertChildItems(d3$q.select(nodes[i]), _options, item);
                    }
                });
            });
        }
        function processItem(_event, item) {
            var _path = [], t;
            for (t = item.parentD; t; t = t.parentD) {
                _path = [t.name].concat(_path);
            }
            if (!item.options) {
                // find the "do" function in hierarchy, and execute it
                for (var curNode = item; curNode; curNode = curNode.parentD) {
                    if (curNode.do) {
                        curNode.do(param, item.value, _path);
                        break;
                    }
                }
                removePopper();
                return;
            }
            // has options
            _path.push(item.name);
            // swap expanded setting
            this.parentNode.classList.toggle("expanded");
            var _ = d3$q.select(this.parentNode);
            if (_.classed("expanded")) {
                // close all items
                //contextMenu_Items.selectAll(".popupMenuItem").classed("expanded",false);
                // but, enable current item
                var children = d3$q.select(this.parentNode.childNodes[1]);
                children.selectAll(".popupMenuItem").remove();
                // do not over-write this.
                // the options function, if there is, need to be dynamically evaluated every time.
                var _options = item.options;
                if (typeof item.options === "function" && isWhen(item))
                    _options = item.options(param);
                insertChildItems(children, _options, item);
            }
            Base.popupInstance.update();
        }
        insertChildItems(contextMenu_Items, template.items);
        Base.popupInstance.update();
        setTimeout(() => contextMenu.classed("visible", true), 10);
    }
    /** -- */
    static helpUI() {
        return Modal.attachHelpScout().then(() => window.Beacon("open"));
    }
    /** -- */
    static createHelpScoutLinks(dom, withTooltip = false) {
        dom = dom.selectAll("[data-helparticle]");
        dom.on("click", (event) => {
            var articleID = event.currentTarget.dataset.helparticle;
            if (!articleID)
                return;
            Modal.attachHelpScout().then(() => window.Beacon("article", articleID, { type: "modal" }));
        });
        if (withTooltip) {
            dom.tooltip(i18n["Learn more"]);
        }
    }
    /** -- */
    static attachHelpScout() {
        if (!window.Beacon) {
            (window.Beacon = function (t, n, a) {
                window.Beacon.readyQueue.push({ method: t, options: n, data: a });
            }),
                (window.Beacon.readyQueue = []);
        }
        return import('https://beacon-v2.helpscout.net/')
            .then(() => {
            if (!window.Beacon.readyQueue)
                return;
            window.Beacon("init", Base.helpscoutBeacon);
            if (window.firebase && window.firebase.auth) {
                var user = window.firebase.auth().currentUser;
                if (user) {
                    window.Beacon("identify", {
                        name: user.displayName || user.email,
                        email: user.email,
                        avatar: user.photoURL,
                        uid: user.uid,
                        portal_name: "TODO",
                    });
                }
            }
        })
            .catch(() => {
            Modal.alert("Script blocking extensions (Adblock, NoScript, uBlock, ...)<br>" +
                "may be blocking our embedded help system. " +
                "<a href='https://docs.helpscout.net/article/911-beacon-ad-blockers' target='_blank'>Learn more</a>", "<i class='fal fa-frown'></i> Cannot display the help.");
            throw new Error();
        });
    }
}

/** -- */
class Aggregate {
    /** -- */
    constructor(attrib) {
        // Records which are mapped to this aggregate
        this.records = [];
        // locked selection status: true if compared and locked (not highlighting)
        this._locked = false;
        // Set false to signal that this aggregate should not be rendered
        this.usedAggr = true;
        // DOM elements
        this.DOM = { aggrGlyph: undefined };
        this.attrib = attrib;
        this.resetAggregateMeasures();
    }
    /** -- */
    get label() {
        return "";
    }
    get compared() {
        return this._compared;
    }
    get locked() {
        return this._locked;
    }
    /** -- */
    setAggrGlyph(v) {
        this.DOM.aggrGlyph = v;
    }
    // ********************************************************************
    // Access to key data
    // ********************************************************************
    measure(m) {
        if (Base.browser.measureFunc.is("Avg")) {
            var r = this[m].recCnt;
            return r === 0 ? 0 : this[m].measure / r; // avoids division by zero
        }
        return this[m].measure;
    }
    recCnt(m) {
        return this[m].recCnt;
    }
    scale(m) {
        return this[m].scale;
    }
    offset(m) {
        return this[m].offset;
    }
    ratioToActive(t) {
        return this.Active.measure ? this[t].measure / this.Active.measure : 0;
    }
    sumOffsetScale(m) {
        return this[m].offset + this[m].scale;
    }
    setOffset(m, v) {
        this[m].offset = v;
    }
    setScale(m, v) {
        this[m].scale = v;
    }
    // ********************************************************************
    // Add/remove records and update data
    // ********************************************************************
    /** Adds the given record to the aggregate */
    addRecord(record) {
        this.records.push(record);
        record._aggrCache.push(this);
        this._processRecord(record);
    }
    /** Internal method to update (insert) measure/record count caches with data from the given record */
    _processRecord(record) {
        if (record.measure_Self == null)
            return;
        ["Total"]
            .concat(record.filteredOut
            ? []
            : ["Active"].concat(Base.Compare_List.filter((cT) => record.isSelected(cT))))
            .forEach((cT) => {
            this[cT].measure += record.measure_Self;
            this[cT].recCnt++;
        });
    }
    /** -- */
    clearRecords() {
        this.records.forEach((record) => {
            record.removeAggrFromCache(this);
        });
        this.records = [];
        this.resetAggregateMeasures();
    }
    /** -- */
    removeRecord(record) {
        this.records.splice(this.records.indexOf(record), 1);
        record.removeAggrFromCache(this);
        if (record.measure_Self == null)
            return;
        ["Total"]
            .concat(record.filteredOut ? [] : ["Active"])
            .concat(Base.Compare_List.filter((cT) => record.isSelected(cT)))
            .forEach((cT) => {
            this[cT].measure -= record.measure_Self;
            this[cT].recCnt--;
        });
    }
    /** -- */
    resetMeasure(t) {
        this[t] = { measure: 0, recCnt: 0 };
    }
    resetAggregateMeasures() {
        Base.Total_Active_Compare_List.forEach((cT) => this.resetMeasure(cT));
        this.records.forEach((record) => this._processRecord(record));
    }
    addToActive(measureToAdd, cntToAdd) {
        this.Active.measure += measureToAdd;
        this.Active.recCnt += cntToAdd;
    }
    // ********************************************************************
    // Select / unselect
    // ********************************************************************
    /** -- */
    unselectAggregate() {
        var _a;
        if (this._locked)
            return;
        (_a = this.DOM.aggrGlyph) === null || _a === void 0 ? void 0 : _a.classList.remove("showLock");
    }
    /** -- */
    selectCompare(cT) {
        var _a, _b;
        this._compared = cT;
        this.records.forEach((record) => record.setCompared(cT));
        (_a = this.DOM.aggrGlyph) === null || _a === void 0 ? void 0 : _a.classList.add("showLock");
        (_b = this.DOM.aggrGlyph) === null || _b === void 0 ? void 0 : _b.classList.add(this._compared);
    }
    /** -- */
    clearCompare(cT) {
        var _a, _b;
        (_a = this.DOM.aggrGlyph) === null || _a === void 0 ? void 0 : _a.classList.remove("showLock");
        (_b = this.DOM.aggrGlyph) === null || _b === void 0 ? void 0 : _b.classList.remove(this._compared);
        if (this._locked) {
            this.unlockSelection();
        }
        this._compared = null;
        this.records.forEach((record) => record.unsetCompared(cT));
    }
    /** -- */
    lockSelection() {
        var _a;
        this._locked = true;
        (_a = this.DOM.aggrGlyph) === null || _a === void 0 ? void 0 : _a.classList.add("locked");
    }
    /** -- */
    unlockSelection() {
        var _a;
        this._locked = false;
        (_a = this.DOM.aggrGlyph) === null || _a === void 0 ? void 0 : _a.classList.remove("locked");
    }
    // no info by default
    exportAggregateInfo() {
        return null;
    }
    // ********************************************************************
    // Tooltip
    // ********************************************************************
    /** -- */
    get tooltipTitle() {
        return "";
    }
    get tooltipSkip1() {
        return false;
    }
    printCompared(cT, details) {
        return (`<tr>` +
            `<td class='measureDetail'>${details}</td>` +
            `<td><span class='colorBox bg_${cT}'></span></td> ` +
            `<td class='measureValue'>${Base.browser.getMeasureFormattedValue(this.measure(cT).toLocaleString())}</td>` +
            (Base.browser.absoluteBreakdown
                ? ""
                : `<td class='percentValue'>(${Base.browser.getValueLabel(Base.browser.getChartValue(this, cT))})</td>`) +
            `</tr>`);
    }
    /** Returns the html content of the tooltip as a string */
    getTooltipHTML() {
        var str = "";
        var browser = Base.browser;
        var newLine = true;
        str += `<div class='tooltipSummaryName'>${this.tooltipTitle}</div>`;
        if (this.label) {
            str += `<span class='mapItemName ${this._compared ? "bg_" + this._compared : ""}'>${this.label}</span>`;
        }
        str += "<div class='aggrTooltip'>";
        str += "<div class='aggrRecordCount'>";
        if (browser.measureFunc.is("Sum")) {
            newLine = false;
            str +=
                browser.getValueLabel(browser.getMeasureValue(this, "Active", "absolute"), false, 1, false) +
                    " " +
                    i18n.measureText(browser);
            str += `<span class='percentBlock percentage_metricSumOutOf'> (${i18n.TooltipOne(browser.getMeasureValue(this, "Active", "dependent"), browser)}) </span>`;
            str += `<div style='font-size: 0.8em;' class='tooltipAmong'>among</div>`;
        }
        str += `<span class="recordNumberInfo">${this.recCnt("Active").toLocaleString()} ${browser.recordName}`;
        // show the %-of value if there are active records inside
        if (this.recCnt("Active") > 0 &&
            (this.recCnt("Active") != browser.allRecordsAggr.recCnt("Active") ||
                this.tooltipSkip1)) {
            str += `${newLine ? "<br>" : ""}
          <span class='percentBlock percentage_recordOutOf'> 
          (${i18n.TooltipOne((100 * this.recCnt("Active")) /
                browser.allRecordsAggr.recCnt("Active"), browser)})
        </span>`;
        }
        str += `</span>`; // recordNumberInfo
        str += `</div>`; // aggrRecordCount
        if (browser.isCompared() &&
            this.attrib &&
            this.recCnt("Active") > 0 &&
            (!this.attrib.isComparedAttrib() ||
                (this.attrib.isMultiValued && browser.activeComparisonsCount > 1))) {
            str += `<div class='tooltipBreakdownHeader'> 
            <span class='BreakdownText'>${i18n.BreakdownBy}</span>
            ${browser.comparedAttrib.attribNameHTML}
          </div>`;
            this.Other = {
                measure: this.measure("Active"),
                recCnt: this.recCnt("Active"),
            };
            browser.activeComparisons.forEach((cT) => {
                this.Other.measure -= this.measure(cT);
                this.Other.recCnt -= this.recCnt(cT);
            });
            str += "<table class='tooltipBreakdownTable'>";
            // sort active comparisons from large to small measure value
            var _ = browser.activeComparisons
                .slice()
                .sort((a, b) => this[b].measure - this[a].measure);
            // render each compared label and its value
            _.forEach((cT) => {
                var _a;
                var comparedLabel = browser.selectedAggrs[cT].label;
                if (((_a = this.attrib) === null || _a === void 0 ? void 0 : _a.attribID) === browser.comparedAttrib.attribID &&
                    comparedLabel === this.label) {
                    // same summary, and same category
                    return;
                }
                str += this.printCompared(cT, comparedLabel);
            });
            let c = browser.comparedAttrib;
            if (this.Other.measure &&
                !c.isMultiValued &&
                this.attrib.browser.breakdownMode.get() !== "dependent") {
                str += this.printCompared("Other", `(${browser.otherNameInCompare})`);
            }
            str += "</table>";
            str += i18n.Tooltip_OutOf(this.label, browser);
        }
        str += "</div>"; // aggrTooltip
        return purify.sanitize(str);
    }
}

/** -- */
class Aggregate_NoValue extends Aggregate {
    constructor(attrib) {
        super(attrib);
        this.filterSelection = false;
    }
    get label() {
        return i18n.NoData;
    }
    get filtered() {
        return this.filterSelection;
    }
    set filtered(v) {
        var _a, _b;
        this.filterSelection = v;
        if (this.records.length === 0)
            return;
        if (this.filterSelection === false) {
            (_a = this.DOM.aggrGlyph) === null || _a === void 0 ? void 0 : _a.classList.remove("filtered");
        }
        else {
            (_b = this.DOM.aggrGlyph) === null || _b === void 0 ? void 0 : _b.classList.add("filtered");
        }
    }
    exportAggregateInfo() {
        return {};
    }
}

const d3$p = { extent };
class TimeSeriesData {
    constructor() {
        // timedata indexed by string representations of date
        this._keyIndex = {};
        // a (sorted) list of timedata
        this._timeseries_ = [];
        // Range of date (cache)
        this.extent_Time = null;
        // Range of values - may be adjusted to show different analytics
        this.extent_Value = null;
        // Range of values - based on raw values, not dynamic
        this.extent_Value_raw = null;
    }
    addTimeData(t) {
        this._keyIndex[t._time_src] = t;
        this._timeseries_.push(t);
    }
    isEmpty() {
        return this._timeseries_.length === 0;
    }
    hasTimeData() {
        return this._timeseries_.length > 0;
    }
    computeCaches() {
        this.extent_Time = d3$p.extent(this._timeseries_, (k) => k._time);
        this.extent_Value = d3$p.extent(this._timeseries_, (k) => k._value);
        this.extent_Value_raw = [...this.extent_Value];
    }
    sortTimeseries() {
        this._timeseries_.sort((a, b) => a._time.getTime() - b._time.getTime());
    }
}

/**
  ->Degree(), Year(), ....
  ->[UPPERCASE(*.)]
  ->[*.]
  ->...->...
  ->2010 (timekey)
  ->Change(%)
  ->Change(#)
*/
class AttribTemplate {
    // used for easy serialization
    toString() {
        return this.str;
    }
    get pathStr() {
        return this.path.join("->");
    }
    constructor(input, dashboard) {
        var _a;
        // the string representation of the template
        this.str = null;
        // the function to call to access values from records
        this.func = null;
        // path of the access
        this.path = [];
        // special access to last information
        this.special = null;
        // parent attribute
        this.parent = null;
        // type of the attribute
        this.blockType = null;
        this.lastKey = null;
        if (typeof input === "function") {
            this.func = input;
            this.str = "" + this.func;
            return;
        }
        this.str = input;
        var path = input.split("->");
        this.lastKey = path[path.length - 1];
        this.path = path.slice(0, -1);
        this.parent = dashboard.attribWithName(this.path.join("->")) || null;
        if (this.path.length === 0) {
            // direct index in the object
            this.func = function () {
                return this[input];
            };
        }
        else {
            // closure variable - it is updated later depending on special type
            var lastAccess = (v) => v[this.lastKey];
            switch (this.lastKey) {
                case "Degree()":
                    lastAccess = (v) => v.length;
                    this.special = "Degree";
                    this.blockType = "numeric";
                    break;
                case "Year()":
                    lastAccess = (v) => v && !isNaN(v.getTime()) ? v.getUTCFullYear() : null;
                    this.special = "Year";
                    this.blockType = "categorical";
                    break;
                case "Month()":
                    lastAccess = (v) => v && !isNaN(v.getTime()) ? v.getUTCMonth() : null;
                    this.special = "Month";
                    this.blockType = "categorical";
                    break;
                case "DayOfMonth()":
                    lastAccess = (v) => v && !isNaN(v.getTime()) ? v.getUTCDate() : null;
                    this.special = "DayOfMonth";
                    this.blockType = "numeric";
                    break;
                case "WeekDay()":
                    lastAccess = (v) => (v && !isNaN(v.getTime()) ? v.getUTCDay() : null);
                    this.special = "WeekDay";
                    this.blockType = "categorical";
                    break;
                case "Hour()":
                    lastAccess = (v) => v && !isNaN(v.getTime()) ? v.getUTCHours() : null;
                    this.special = "Hour";
                    this.blockType = "numeric";
                    break;
                case "Change(#)":
                    lastAccess = (v) => {
                        let _ts = new TimeSeriesData();
                        v._timeseries_.forEach((k, i) => {
                            if (i == 0)
                                return;
                            var cur = v._timeseries_[i];
                            var prev = v._timeseries_[i - 1];
                            if (!cur || !prev)
                                return;
                            _ts.addTimeData({
                                _time: k._time,
                                _time_src: k._time_src,
                                _value: cur._value - prev._value,
                            });
                        });
                        return _ts;
                    };
                    this.special = "TimeseriesChange-#";
                    this.blockType = "timeseries";
                    break;
                case "Change(%)":
                    lastAccess = (v) => {
                        let _ts = new TimeSeriesData();
                        v._timeseries_.forEach((k, i) => {
                            if (i == 0)
                                return;
                            var cur = v._timeseries_[i];
                            var prev = v._timeseries_[i - 1];
                            if (!cur || !prev)
                                return;
                            _ts.addTimeData({
                                _time: k._time,
                                _time_src: k._time_src,
                                _value: (100 * (cur._value - prev._value)) / (prev._value || 1),
                            });
                        });
                        return _ts;
                    };
                    this.special = "TimeseriesChange-%";
                    this.blockType = "timeseries";
                    break;
            }
            // TimePoint of a TimeSeries variable
            if (!this.special && ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.type) === "timeseries") {
                this.special = "TimePoint";
                this.blockType = "numeric";
                if (["TimeseriesChange-%", "TimeseriesChange-#"].includes(this.parent.template.special)) {
                    // anonymous function, has access to this context in this scope.
                    this.func = (record) => {
                        var v = this.parent.getRecordValue(record);
                        if (!v || v.length != null || v.length === 0)
                            return null;
                        if (v)
                            v = lastAccess.call(this, v._keyIndex);
                        return v ? v._value : v;
                    };
                    return;
                }
                else {
                    lastAccess = (v) => v._keyIndex[this.lastKey]._value;
                }
            }
            this.func = function () {
                var v = this;
                for (var i = 0; i < path.length - 1; i++) {
                    v = v[path[i]];
                    if (v == null)
                        return null; // hit a null key in the object path. Abort! Abort!
                }
                return v ? lastAccess.call(this, v) : v;
            };
        }
    }
}

const d3$o = {
    scaleLinear: linear,
    scaleLog: log,
    min,
    max,
};
/** -- */
class Attrib {
    get block() {
        return this._block;
    }
    applyTemplateSpecial() { }
    isEmpty() {
        return this._aggrs.length === 0;
    }
    isFiltered() {
        var _a, _b;
        return (_b = (_a = this.summaryFilter) === null || _a === void 0 ? void 0 : _a.isFiltered) !== null && _b !== void 0 ? _b : false;
    }
    // cen be extended by sub-classes
    createSummaryFilter() { }
    get parent() {
        var _a;
        return this._parent || ((_a = this.template) === null || _a === void 0 ? void 0 : _a.parent);
    }
    // overwritten by numeric summary
    hasTimeSeriesParent() {
        return false;
    }
    createDerivedAttrib(_special, name = null) {
        if (this.derivatives[_special])
            return;
        this.derivatives[_special] = this.browser.createAttrib(name || `${this.attribName}->${_special.replace("()", "")}`, `${this.template}->${_special}`);
        this.browser.refreshAttribList();
    }
    // aka blockName
    get attribName() {
        return this._attribName;
    }
    get printName() {
        return this._attribName.split("->").pop();
    }
    // name without last key item
    get pathName() {
        return this._attribName.split("->").slice(0, -1); // removes last item
    }
    // specialized method to consider/change behavior if with timeseries parent
    get groupPath() {
        return this.pathName;
    }
    get attribNameHTML() {
        return `<span class='blockName_Path ${this.pathName.length ? "visible" : ""}'>${this.pathName
            .map((_) => `<span class='groupName'>${_}</span><span class='fa fa-caret-right'></span>`)
            .join("")}</span><span class='blockName_Print'>${this.printName}</span>`;
    }
    set attribName(newName) {
        var _a, _b, _c;
        let curName = this._attribName;
        if (curName === newName)
            return;
        if (this.browser.attribWithName(newName))
            return;
        this.browser.removeAttribFromGroupIndex(this); // remove it from previous newName index
        this._attribName = newName;
        this.browser.insertAttribIntoGroupIndex(this);
        this.browser.refreshAttribList();
        (_a = this.block) === null || _a === void 0 ? void 0 : _a.refreshSummaryName_DOM();
        if ((_c = (_b = this.summaryFilter) === null || _b === void 0 ? void 0 : _b.breadcrumb) === null || _c === void 0 ? void 0 : _c.DOM) {
            this.addDOMBlockName(this.summaryFilter.breadcrumb.DOM.select(".crumbHeader"));
        }
    }
    get description() {
        if (!this._description && this._parent)
            return this._parent.description;
        return this._description;
    }
    set description(v) {
        var _a;
        this._description = purify.sanitize(v, {}) || null;
        (_a = this.block) === null || _a === void 0 ? void 0 : _a.updateDescription();
    }
    refreshConfigs() {
        Object.values(this.configs).forEach((cfg) => cfg.refresh());
    }
    /** -- */
    isIDAttrib() {
        return this.browser.idSummaryName === this.attribName;
    }
    isComparedAttrib() {
        return this === this.browser.comparedAttrib;
    }
    autoCompare() { }
    get canHaveMetricFuncs() {
        return false;
    }
    get supportedMetricFuncs() {
        return []; // none supported by default
    }
    /** -- */
    addSupportedMetricFunc(t) {
        if (this._metricFuncs.includes(t))
            return;
        this._metricFuncs.push(t);
        this.browser.measureSummary.refresh();
    }
    /** -- */
    removeSupportedMetricFunc(t) {
        var _a;
        if (!this._metricFuncs.includes(t))
            return; // not included already
        this._metricFuncs = this._metricFuncs.filter((_) => _ != t);
        if (this.attribID === ((_a = this.measureSummary) === null || _a === void 0 ? void 0 : _a.attribID) &&
            this.browser.measureFunc.is(t)) {
            this.browser.measureFunc.set("Count");
            this.browser.measureFunc.refresh();
        }
        else {
            this.browser.measureSummary.refresh(); // drop-down options refresh
        }
    }
    // Does not support record encoding by default, can be extended
    supportsRecordEncoding(_coding) {
        return false;
    }
    // ********************************************************************
    // Record value access
    // ********************************************************************
    getRecordValue(record) {
        return record.getValue(this);
    }
    setRecordValueCacheToMissing(record) {
        // TO-DO: Remove record from its existing aggregate for this summary
        record.setValue(this, null);
        this.noValueAggr.addRecord(record);
    }
    getFormattedValue(_v, _isSVG) {
        return "";
    }
    renderRecordValue(_v, _d3_selection) {
        return "";
    }
    // ********************************************************************
    // ********************************************************************
    constructor(browser, name, template = null, _type, blockClassName = "", nuggetClassName = "") {
        // The associated block (view) - null by default
        this._block = null;
        // ********************************************************************
        // Template system
        // ********************************************************************
        this.template = null;
        // ********************************************************************
        // Aggregation
        // ********************************************************************
        this._aggrs = [];
        this.aggr_initialized = false;
        // ********************************************************************
        // Filtering
        // ********************************************************************
        // The filter used to filter records. May be null
        this.summaryFilter = null;
        // ********************************************************************
        // Other attributes (parent/derivative/child)
        // ********************************************************************
        // may have multiple derivatives, indexed by string keys
        this.derivatives = {};
        // may have a single parent attribute
        this._parent = null;
        // ********************************************************************
        // Name (path, html formatted strings, etc.)
        // ********************************************************************
        // the string representation of the name. May include a path/group
        this._attribName = null;
        // ********************************************************************
        // Description
        // ********************************************************************
        // The description of the variable or content block
        this._description = "";
        // ********************************************************************
        // Configuration objects TODO review
        // ********************************************************************
        this.configs = {};
        // TODO review
        this._metricFuncs = Base.defaultMetricFuncs;
        this.measureLogBase = 10;
        // ********************************************************************
        // Measurable configuration
        // ********************************************************************
        this.measurable = null;
        this.browser = browser;
        this._attribName = name;
        this.type = _type;
        this.attribID = this.browser.attribCounter++;
        this.blockClassName = blockClassName;
        this.nuggetClassName = nuggetClassName;
        this.browser.attribs.push(this);
        if (template instanceof AttribTemplate) {
            this.template = template;
        }
        else {
            this.template = new AttribTemplate(name, this.browser);
        }
        this.noValueAggr = new Aggregate_NoValue(this);
        this.browser.allAggregates.push(this.noValueAggr);
        this.isComparable = new Config({
            parent: this,
            cfgClass: "isComparable",
            cfgTitle: "Select-Compare",
            UI: { disabled: true },
            default: true,
            itemOptions: [
                { name: "Enabled", value: true },
                { name: "Disabled", value: false },
            ],
            onSet: (v) => {
                var _a, _b;
                if (!v) {
                    // if not comparable, cannot be used to sum/avg data
                    this._metricFuncs = [];
                }
                if (!v && this.isComparedAttrib()) {
                    this.browser.clearSelect_Compare(this.browser.activeComparisons);
                }
                (_b = (_a = this.block) === null || _a === void 0 ? void 0 : _a.DOM.root) === null || _b === void 0 ? void 0 : _b.classed("disableCompareLock", !v);
            },
        });
        this.measureScaleType = new Config({
            cfgClass: "measureScaleType",
            cfgTitle: "Axis Scale",
            parent: this,
            UISeperator: {
                title: "Axis",
            },
            default: "linear",
            iconClass: "fa fa-chart-line",
            helparticle: "5e88d63f04286364bc97d40b",
            itemOptions: [
                {
                    name: i18n.Linear + " " + i18n.LinearSequence,
                    value: "linear",
                },
                { name: i18n.Log + " " + i18n.Log10Sequence, value: "log" },
            ],
            forcedValue: () => {
                if (this.stackedCompare)
                    return "linear";
                if (this.percentBreakdown)
                    return "linear";
                if (this.browser.measureSumWithNegativeValues())
                    return "linear";
            },
            onSet: (v) => {
                var _a;
                this.refreshChartScale_Measure(v);
                (_a = this.block) === null || _a === void 0 ? void 0 : _a.refreshViz_All();
            },
        });
        this.axisScaleType = new Config({
            cfgClass: "axisScaleType",
            cfgTitle: "Axis Extent",
            default: "fit",
            parent: this,
            iconClass: "fa fa-chart-line",
            helparticle: "5e893b562c7d3a7e9aea656e",
            itemOptions: [
                { name: "Fit", value: "fit" },
                { name: "Sync", value: "sync" },
                { name: "Full", value: "full" },
            ],
            forcedValue: () => {
                if (this.percentBreakdown && !this.browser.isCompared()) {
                    return "fit";
                }
                if (this.browser.measureFunc_Avg &&
                    this.axisScaleType._value === "full") {
                    return "fit";
                }
            },
            onSet: () => {
                var _a;
                if (!this.aggr_initialized)
                    return;
                this.updateChartScale_Measure(true);
                (_a = this.block) === null || _a === void 0 ? void 0 : _a.refreshViz_All();
            },
        });
    }
    finishTemplateSpecial() {
        if (this.template.special) {
            // add to parent's derivatives automatically
            if (this.template.parent) {
                this.template.parent.derivatives[this.template.special] = this;
            }
            // customizations per attribute class.
            this.applyTemplateSpecial();
        }
    }
    destroy() {
        this.browser.destroyAttrib(this);
    }
    /** Utility method to inject HTML into DOM */
    addDOMBlockName(DOM) {
        DOM.html(this.attribNameHTML);
        DOM.select(".blockName_Path")
            .tooltip(i18n["Show/Hide Path"])
            .on("click", (event) => {
            event.currentTarget.classList.toggle("visible");
            event.stopPropagation();
        });
    }
    // ********************************************************************
    // ********************************************************************
    // Shorthand access
    get records() {
        return this.browser.records;
    }
    get breakdownMode() {
        return this.browser.breakdownMode.get();
    }
    get relativeBreakdown() {
        return this.browser.relativeBreakdown;
    }
    get absoluteBreakdown() {
        return this.browser.absoluteBreakdown;
    }
    get dependentBreakdown() {
        return this.browser.dependentBreakdown;
    }
    get totalBreakdown() {
        return this.browser.totalBreakdown;
    }
    get percentBreakdown() {
        return this.browser.percentBreakdown;
    }
    get stackedCompare() {
        return this.browser.stackedCompare.is(true);
    }
    vizActive(key) {
        return this.browser.vizActive(key);
    }
    get measureFunc() {
        return this.browser.measureFunc.get();
    }
    get activeComparisons() {
        return this.browser.activeComparisons;
    }
    get activeComparisonsCount() {
        return this.browser.activeComparisonsCount;
    }
    get measureSummary() {
        return this.browser.measureSummary.get();
    }
    /** -- */
    get measureScale_Log() {
        return this.measureScaleType.is("log");
    }
    /** -- */
    get measureScale_Linear() {
        return this.measureScaleType.is("linear");
    }
    /** -- */
    get measureExtent_Self() {
        var maxMeasureValue = this.getPeakAggr(d3$o.max);
        var minMeasureValue = 0;
        if (this.absoluteBreakdown && this.browser.measureSumWithNegativeValues()) {
            minMeasureValue = Math.min(this.getPeakAggr(d3$o.min), 0); // just making sure it cannot be > 0
        }
        // if using log scale, minimum value cannot be zero or negative
        if (this.measureScale_Log && minMeasureValue <= 0) {
            minMeasureValue = Math.max(1, minMeasureValue);
        }
        // If min/max domain is set to zero, d3 puts zero-value in the middle of the range. prevent
        if (maxMeasureValue === 0 && minMeasureValue === 0) {
            maxMeasureValue = 0.001;
        }
        return [minMeasureValue, maxMeasureValue];
    }
    /** -- */
    get measureDomain_Final() {
        var _a, _b;
        if (!((_a = this.block) === null || _a === void 0 ? void 0 : _a.panel)) {
            return this.measureExtent_Self;
        }
        if (this.axisScaleType.is("fit")) {
            return this.measureExtent_Self;
        }
        if (this.axisScaleType.is("full")) {
            if (this.absoluteBreakdown) {
                return [0, this.browser.allRecordsAggr.measure("Active")];
            }
            else {
                return [0, 100];
            }
        }
        if (this.axisScaleType.is("sync")) {
            return (_b = this.block) === null || _b === void 0 ? void 0 : _b.panel.syncedMeasureExtent;
        }
        // fallback, just in case
        return this.measureExtent_Self;
    }
    refreshChartScale_Measure(v = null) {
        var _a, _b;
        v !== null && v !== void 0 ? v : (v = this.measureScaleType.get());
        this.chartScale_Measure_prev = (_b = (_a = this.chartScale_Measure) === null || _a === void 0 ? void 0 : _a.copy().clamp(false)) !== null && _b !== void 0 ? _b : null;
        this.measureLogBase = 10;
        this.chartScale_Measure = v === "log"
            ? d3$o.scaleLog().base(this.measureLogBase)
            : d3$o.scaleLinear();
        this.chartScale_Measure.clamp(true);
        if (this.chartScale_Measure_prev) {
            var domain = this.chartScale_Measure_prev.domain();
            if (this.measureScale_Log) {
                if (domain[0] === 0)
                    domain[0] = 1;
            }
            else {
                domain[0] = Math.min(0, domain[0]);
            }
            this.chartScale_Measure.domain(domain)
                .range(this.chartScale_Measure_prev.range()); // same range
        }
    }
    /** -- */
    updateChartScale_Measure(skipRefreshViz = false) {
        var _a, _b, _c, _d, _e;
        if (!this.aggr_initialized || this.isEmpty()) {
            return; // nothing to do
        }
        this.chartScale_Measure_prev = (_b = (_a = this.chartScale_Measure) === null || _a === void 0 ? void 0 : _a.copy().clamp(false)) !== null && _b !== void 0 ? _b : null;
        var newDomain = this.measureDomain_Final;
        if (this.measureScale_Log && newDomain[0] === 0) {
            newDomain[0] = 1;
        }
        var hideActive = false;
        if (this.relativeBreakdown && this.browser.activeComparisonsCount > 0) {
            hideActive = newDomain[1] !== 100;
        }
        (_d = (_c = this.block) === null || _c === void 0 ? void 0 : _c.DOM.root) === null || _d === void 0 ? void 0 : _d.classed("hideActive", hideActive);
        this.chartScale_Measure.domain(newDomain).range([0, this.measureRangeMax]);
        if (!skipRefreshViz && this.chartScale_Measure_prev) {
            var oldDomain = this.chartScale_Measure_prev.domain();
            if (newDomain[0] !== oldDomain[0] ||
                newDomain[1] !== oldDomain[1] ||
                this.measureRangeMax !== this.chartScale_Measure_prev.range()[1]) {
                (_e = this.block) === null || _e === void 0 ? void 0 : _e.refreshViz_All();
            }
        }
    }
    // returns the maximum active aggregate value per row in chart data
    // peakFunc is d3.min or d3.max
    getPeakAggr(peakFunc, sT = null) {
        if (this.isEmpty())
            return 0;
        if (typeof sT === "string") {
            return peakFunc(this._aggrs, (aggr) => aggr.usedAggr ? this.browser.getChartValue(aggr, sT) : null);
        }
        // No comparisons. Max aggregate will be that of the active
        if (this.activeComparisonsCount === 0) {
            return this.getPeakAggr(peakFunc, "Active");
        }
        // Active will be max if visible & using count or positive-sum's
        if ((this.absoluteBreakdown || this.totalBreakdown) &&
            this.browser.showWholeAggr.is(true) &&
            this.browser.measureWithPositiveValues()) {
            return this.getPeakAggr(peakFunc, "Active");
        }
        var activeComparisons = this.activeComparisons;
        if (this.browser.stackedChart) {
            // cannot add up separate maximums per selection, it needs to be accumulated per aggregate
            return peakFunc(this._aggrs, (aggr) => aggr.usedAggr
                ? activeComparisons.reduce((accum, sT) => accum + this.browser.getChartValue(aggr, sT), 0)
                : null);
        }
        else {
            // pick the peak of all comparisons
            return peakFunc(activeComparisons.map((sT) => this.getPeakAggr(peakFunc, sT)));
        }
    }
    // only sets it if the attribute has/is "measurable"
    set unitName(v) {
        var _a;
        if (this.measurable) {
            this.measurable.unitName = v;
            (_a = this.browser.recordDisplay.View) === null || _a === void 0 ? void 0 : _a.refreshAttribUnitName(this);
        }
    }
    get unitName() {
        var _a;
        return ((_a = this.measurable) === null || _a === void 0 ? void 0 : _a.unitName) || "";
    }
    get valueDomain() {
        var _a;
        return ((_a = this.measurable) === null || _a === void 0 ? void 0 : _a.valueDomain) || null;
    }
    get metricFuncs() {
        var _a;
        return ((_a = this.measurable) === null || _a === void 0 ? void 0 : _a.metricFuncs) || Base.defaultMetricFuncs;
    }
    // ....
    get isMultiValued() {
        return false;
    }
    // ********************************************************************
    // Export & apply config
    // ********************************************************************
    /** -- */
    applyConfig(blockCfg) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (blockCfg.noNugget) {
                this.browser.removeAttribFromGroupIndex(this);
            }
            if (blockCfg.isComparable === false) {
                yield this.isComparable.set(false);
            }
            if (blockCfg.metricFuncs) {
                this._metricFuncs = blockCfg.metricFuncs;
            }
            yield this.axisScaleType.set(blockCfg.axisScaleType);
            (_a = this.block) === null || _a === void 0 ? void 0 : _a.setCollapsed(blockCfg.collapsed === true);
            this.description = blockCfg.description;
            this.initializeAggregates();
        });
    }
    isExportable() {
        return true;
    }
    /** -- */
    exportConfig() {
        var _a, _b, _c;
        var cfg1 = {
            name: this._attribName,
            panel: ((_b = (_a = this.block) === null || _a === void 0 ? void 0 : _a.panel) === null || _b === void 0 ? void 0 : _b.name) || "none",
            description: this.description || undefined,
            collapsed: (_c = this.block) === null || _c === void 0 ? void 0 : _c.collapsed,
            type: this.type,
            // TODO: nonugget
        };
        var cfg2 = Object.assign({ value: this.template.str !== cfg1.name ? this.template.str : undefined, axisScaleType: this.axisScaleType.exportValue(), measureScaleType: this.measureScaleType.exportValue(), isComparable: this.isComparable.exportValue() }, this.measurable);
        return Object.assign({}, cfg1, cfg2);
    }
}

class ConfigS {
}
/** -- */
class Config {
    /** -- */
    constructor(_cfg) {
        var _a, _b, _c, _d, _e;
        // disables export setting
        this.noExport = false;
        this.lookup = new Map();
        Object.assign(this, _cfg);
        (_a = this.UI) !== null && _a !== void 0 ? _a : (this.UI = { disabled: false });
        (_b = this.isActive) !== null && _b !== void 0 ? _b : (this.isActive = (d) => {
            if (d._type === "_range_") {
                return this.get() > 0;
            }
            return this.is(d.value);
        });
        (_c = this.itemOptions) === null || _c === void 0 ? void 0 : _c.filter((option) => option.value !== null).forEach((option) => this.lookup.set(option.value, option.name));
        if ((_d = this === null || this === void 0 ? void 0 : this.parent) === null || _d === void 0 ? void 0 : _d.configs)
            this.parent.configs[this.cfgClass] = this;
        this._prevValue = _cfg.default;
        this._value = _cfg.default;
        // TODO: This function may be async, but we are in a constructor...
        (_e = this.onSet) === null || _e === void 0 ? void 0 : _e.call(this, this.get(), this);
    }
    /** Current value to string */
    toString() {
        let v = this.get();
        return i18n[this.lookup.get(v) || v];
    }
    /** Value getter */
    get() {
        var _a, _b, _c, _d;
        // First, check & return if there is a forced value
        return (_d = (_b = (_a = this.forcedValue) === null || _a === void 0 ? void 0 : _a.call(this, this)) !== null && _b !== void 0 ? _b : (_c = this.onRead) === null || _c === void 0 ? void 0 : _c.call(this, this._value)) !== null && _d !== void 0 ? _d : this._value;
    }
    is(v) {
        return this.get() === v;
    }
    /** Value setter - onSet function may be async*/
    set(v) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            if (v == null)
                return; // cannot set to null or undefined. (false is ok)
            if (this.preSet) {
                try {
                    v = yield this.preSet(v, this);
                }
                catch (error) {
                    if ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.finalized) {
                        Modal.alert(error); // show alert only after dashboard loading
                    }
                    return;
                }
            }
            if (v == null)
                return; // preSet can return null, preventing change and raising no error
            if (this._value === v)
                return; // prevent setting it to current value - no change
            this._prevValue = this._value;
            this._value = v;
            const forced = (_b = this.forcedValue) === null || _b === void 0 ? void 0 : _b.call(this, this);
            if (forced === v)
                return; // trying to set to current forced value. No need to call onSet/refresh
            yield ((_c = this.onSet) === null || _c === void 0 ? void 0 : _c.call(this, this.get(), this));
            if ((_d = this.parent) === null || _d === void 0 ? void 0 : _d.refreshConfigs) {
                this.parent.refreshConfigs();
            }
            else {
                this.refresh();
            }
        });
    }
    // sets the value to previous value
    undoChange() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.set(this._prevValue);
        });
    }
    /** -- */
    refresh() {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            (_a = this.onRefreshDOM) === null || _a === void 0 ? void 0 : _a.call(this, this);
            if (this.DOM) {
                // we have custom forced value function
                if (this.forcedValue) {
                    var v = this.forcedValue(this);
                    this.DOM.root.classed("forced", v != null);
                    if (v != null)
                        yield ((_b = this.onSet) === null || _b === void 0 ? void 0 : _b.call(this, v, this));
                }
                if (this.isActive) {
                    this.DOM.configOptions.classed("active", this.isActive);
                }
                (_c = this.DOM.noUiSlider) === null || _c === void 0 ? void 0 : _c.setHandle(0, this._value, false);
                (_d = this.itemOptions) === null || _d === void 0 ? void 0 : _d.filter((_) => _.DOM && _.activeWhen).forEach((_) => {
                    _.DOM.classList[!_.activeWhen() ? "add" : "remove"]("disabled");
                });
            }
        });
    }
    /** Calls oNSet and refresh... */
    reset() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            yield ((_a = this.onSet) === null || _a === void 0 ? void 0 : _a.call(this, this.get(), this));
            if ((_b = this.parent) === null || _b === void 0 ? void 0 : _b.refreshConfigs) {
                this.parent.refreshConfigs(); // refresh all configs of the parent
            }
            else {
                yield this.refresh();
            }
        });
    }
    addUISeperator(DOM) {
        var _a;
        if (!this.UISeperator)
            return;
        DOM.append("tr")
            .attr("class", (_a = "configItemGroup " + this.UISeperator.className) !== null && _a !== void 0 ? _a : "")
            .append("td")
            .attr("class", "groupName")
            .html(i18n[this.UISeperator.title]);
    }
    /** -- */
    insertControl(DOM) {
        var _a, _b;
        if ((_a = this.UI) === null || _a === void 0 ? void 0 : _a.disabled)
            return;
        this.addUISeperator(DOM);
        this.DOM = {};
        this.DOM.root = DOM.append("tr")
            .attr("class", "configItem configItem_" + this.cfgClass);
        this.DOM.root.append("td")
            .attr("class", "configItem_Header")
            .append("span")
            .html(i18n[this.cfgTitle]);
        let icon = this.DOM.root.append("td")
            .attr("class", "configItem_Icon")
            .append("span");
        // We can use a css class, or iconXML.
        if (this.iconClass) {
            icon.attr("class", "icon " + this.iconClass);
        }
        else {
            icon.attr("class", "icon").append("span").html(this.iconXML);
        }
        var _ = this.DOM.root
            .append("td")
            .attr("class", "configItem_Options_td")
            .append("div")
            .attr("class", "configItem_Options");
        this.DOM.configOptions = _.selectAll(".configOption")
            .data(this.itemOptions || [])
            .enter()
            .append("span")
            .attr("class", (d) => "configOption pos_" + (d._type || d.value || d.name))
            .each((d, i, nodes) => {
            d.DOM = nodes[i];
        });
        this.DOM.configOptions
            .filter((_) => _.value !== undefined)
            .html((d) => i18n[d.name])
            .on("click", (_event, d) => __awaiter(this, void 0, void 0, function* () { return yield this.set(d.value); }));
        this.DOM.configOptions
            .filter((_) => _._type === "_range_")
            .append("span")
            .attr("class", "configOptionRange")
            .each((_, i, nodes) => {
            this.DOM.noUiSlider = noUiSlider.create(nodes[i], {
                connect: "lower",
                step: 1,
                behaviour: "tap-drag",
                range: {
                    min: _.minValue,
                    max: _.maxValue,
                },
                start: this.default,
            });
            nodes[i].noUiSlider.on("set", (v) => __awaiter(this, void 0, void 0, function* () { return yield this.set(v); }));
        });
        this.DOM.root
            .append("td")
            .attr("class", "configItem_Info")
            .append("span")
            .attr("class", "fal fa-question-circle")
            .attr("data-helparticle", this.helparticle)
            .tooltip((this.tooltip ? this.tooltip + "<br><br>" : "") + "Learn more", {
            placement: "bottom",
        });
        Modal.createHelpScoutLinks(this.DOM.root);
        (_b = this.onDOM) === null || _b === void 0 ? void 0 : _b.call(this, this.DOM);
        this.refresh();
    }
    exportValue() {
        if (this.noExport)
            return undefined;
        if (this._value === this.default)
            return undefined;
        var v = this._value;
        if (v instanceof Attrib)
            v = v.attribName;
        if (v._time_src)
            v = v._time_src;
        return v;
    }
    /** -- */
    exportConfigTo(_to) {
        _to[this.cfgClass] = this.exportValue();
    }
}

const d3$n = {
    utcParse,
    format,
    easeCubicOut: cubicOut,
    scaleLog: log,
    scaleLinear: linear,
    arc,
    line,
    curveMonotoneX: monotoneX,
};
/** A namespace for various independent functions */
var Util = {
    // Does not modify _base or _extend configurations
    mergeConfig(_base, _extend = {}) {
        return Util._mergeLevel(JSON.parse(JSON.stringify(_base)), JSON.parse(JSON.stringify(_extend)), _base, _extend);
    },
    // _target: is updated
    // returns: _target
    _mergeLevel(_target, _extend, _base_raw, _extend_raw) {
        for (var _key in _extend_raw) {
            var _value = _extend_raw[_key];
            //if(_value==null) continue; // skip undefined values
            if (_target[_key] == null) {
                // key is new => Just assign the variable
                _target[_key] = _value;
                continue;
            }
            if (_value === null) {
                delete _target[_key];
                continue;
            }
            switch (typeof _value) {
                case "object":
                    if (typeof _target[_key] === "object") {
                        // merge summaries section - custom logic
                        if (_key === "summaries") {
                            // both source and target has "summaries" section set
                            if (!Array.isArray(_extend.summaries) ||
                                !Array.isArray(_target.summaries)) {
                                console.log("Merge error: summaries property is not array");
                                continue;
                            }
                            var _finalSummaries = [];
                            _extend_raw.summaries.forEach((srcSummaryConfig) => {
                                if (!srcSummaryConfig.skipConfig)
                                    srcSummaryConfig.skipConfig = false;
                                var targetSummaryCfg = _base_raw.summaries.find((s) => s.name === srcSummaryConfig.name);
                                if (targetSummaryCfg) {
                                    srcSummaryConfig = Util._mergeLevel(JSON.parse(JSON.stringify(targetSummaryCfg)), JSON.parse(JSON.stringify(srcSummaryConfig)), targetSummaryCfg, srcSummaryConfig);
                                    if (!srcSummaryConfig.skipConfig)
                                        delete srcSummaryConfig.skipConfig;
                                }
                                // summary gets added to end of summaries list
                                _finalSummaries.push(srcSummaryConfig);
                            });
                            _base_raw.summaries.forEach((s) => {
                                if (!_finalSummaries.find((_s) => _s.name === s.name)) {
                                    _finalSummaries.push(s);
                                }
                            });
                            _target.summaries = _finalSummaries;
                        }
                        else {
                            // recursion to merge new objects
                            Util._mergeLevel(_target[_key], _extend[_key], _base_raw[_key], _extend_raw[_key]);
                        }
                        break;
                    }
                // just assign the value to the key
                default:
                    _target[_key] = _value;
                    break;
            }
        }
        // there may be keys in raw target OR source that's not in _target
        // Specically, function values (and dates) are skipped bc of JSON.stringify
        for (var _key in _base_raw) {
            if (_extend_raw[_key] === undefined) {
                _target[_key] = _base_raw[_key];
            }
        }
        for (var _key in _extend_raw) {
            _target[_key] = _target[_key] || _extend_raw[_key];
        }
        return _target;
    },
    // ********************************************
    // String methods
    // ********************************************
    // ***************
    strCollate: new Intl.Collator(undefined, {
        ignorePunctuation: true,
        sensitivity: "base",
        numeric: true,
    }),
    // ***************
    sortFunc_List_String(a, b) {
        return Util.strCollate.compare("" + a, "" + b);
    },
    // ***************
    sortFunc_List_Date(a, b) {
        if (a == null)
            return 1;
        if (b == null)
            return -1;
        return b.getTime() - a.getTime(); // recent first
    },
    sortFunc_List_Number(a, b) {
        return b - a;
    },
    /** -- */
    toProperCase(str) {
        return str.toLowerCase().replace(/\b[a-z]/g, (f) => f.toUpperCase());
    },
    /** -- */
    addUnitName(v, unitName, isSVG = false) {
        if (!unitName)
            return (v + "").replace("G", "B"); // replace abbrevation G with B;
        var s = isSVG ? unitName : "<span class='unitName'>" + unitName + "</span>";
        return ((Util.isCurrency(unitName) ? s + v : v + s) + "").replace("G", "B"); // replace abbrevation G with B;
    },
    /** -- */
    isCurrency(unitStr) {
        switch (unitStr) {
            case "$":
            case "€":
            case "₺":
            case "¥":
            case "£":
            case "₼":
            case "؋":
            case "ƒ":
            case "¢":
            case "﷼":
            case "₪":
            case "₣":
            case "₩":
            case "₦":
            case "₲":
            case "฿":
            case "₴":
            case "₡": // Costa Rican colon
            case "₱": // Cuban peso
            case "₫": // Vietnamese dong
            case "₽": // Russian ruble
            case "₹": // Indian rupee
            case "៛": // Cambodian riel
            case "лв":
            case "zł": // Polish zloty
            case "Br": // Belarusian ruble
            case "Lek": // Albanian lek
                return true;
            default:
                return false;
        }
    },
    /** -- */
    getTimeParseFunc(fmt) {
        // Note: new EPOCH config is %s (d3 standard method). Keeping for backwards compatibility!
        if (fmt === "%EPOCH")
            return (v) => new Date(Math.floor(v * 1000));
        if (fmt !== "%sn" && fmt !== "%SN")
            return d3$n.utcParse(fmt);
        // Parse (Google) Sheet Date
        // Days are counted from December 31st 1899 and are incremented by 1
        // Decimals are fractions of a day.
        return function (v) {
            if (v !== null) {
                var utc_days = Math.floor(v - 25569);
                var utc_base = utc_days * 86400;
                var fractional_day = v - Math.floor(v);
                if (fractional_day === 0) {
                    return new Date(utc_base * 1000);
                }
                var total_seconds = Math.floor(86400 * fractional_day);
                return new Date(utc_base * 1000 + total_seconds * 1000);
            }
        };
    },
    baseMeasureFormat: d3$n.format(".2s"),
    /** You should only display at most 3 digits + k/m/etc */
    formatForItemCount(n, unitName = "") {
        n = Math.round(n);
        let str;
        if (n < 1000 && n > -1000) {
            str = n.toString();
        }
        else {
            str = Util.baseMeasureFormat(n);
            if (str.replace(/\D/g, "").length === 3) {
                str = d3$n.format(".3s")(n);
            }
        }
        return Util.addUnitName(str, unitName, false);
    },
    /** -- */
    isStepTicks(ticks) {
        // increasing or decreasing (+/- 1)
        return (ticks.length >= 2 &&
            ticks.every((_, i) => i === 0 ? true : Math.abs(ticks[i] - ticks[i - 1]) === 1));
    },
    /** -- */
    insertMinorTicks(ticks, _scale, _out, numMinor = 4) {
        // if ticks[0] is larger than ticks[last], reverse
        if (ticks[0] > ticks[ticks.length - 1])
            ticks = ticks.reverse();
        for (var i = 1; i < ticks.length; i++) {
            let _minR = ticks[i - 1];
            const _maxR = ticks[i];
            const _difR = (_maxR - _minR) / numMinor;
            let _min = _scale(_minR);
            const _max = _scale(_maxR);
            for (let j = 1; j < numMinor; j++) {
                if (numMinor === 4) {
                    // base 2
                    let x = (_min + _max) / 2;
                    const _midR = (_minR + _maxR) / 2;
                    _out.push({
                        tickValue: _scale.invert(x),
                        major: false,
                        tickUnique: _midR,
                    });
                    _min = x;
                    _minR = _midR;
                }
                else {
                    // new way
                    let x = ticks[i - 1] + j * _difR;
                    _out.push({ tickValue: x, major: false, tickUnique: x });
                }
            }
        }
    },
    /** -- */
    ignoreScrollEvents: false,
    scrollToPos_do(scrollDom, targetPos) {
        scrollDom = scrollDom.node();
        Util.ignoreScrollEvents = true;
        // scroll to top
        var startTime = null;
        var scrollInit = scrollDom.scrollTop;
        var easeFunc = d3$n.easeCubicOut;
        var scrollTime = 500;
        var animateToTop = function (timestamp) {
            var progress;
            if (startTime == null)
                startTime = timestamp;
            // complete animation in 500 ms
            progress = (timestamp - startTime) / scrollTime;
            var m = easeFunc(progress);
            scrollDom.scrollTop = (1 - m) * scrollInit + m * targetPos;
            if (scrollDom.scrollTop >= targetPos ||
                scrollDom.offsetHeight + scrollDom.scrollTop >= scrollDom.scrollHeight) {
                Util.ignoreScrollEvents = false;
            }
            else {
                window.requestAnimationFrame(animateToTop);
            }
        };
        window.requestAnimationFrame(animateToTop);
    },
    removeEmptyKeys(cfg) {
        Object.keys(cfg).forEach((key) => cfg[key] === undefined && delete cfg[key]);
    },
    // http://stackoverflow.com/questions/13627308/add-st-nd-rd-and-th-ordinal-suffix-to-a-number
    ordinal_suffix_of(i) {
        const j = i % 10, k = i % 100;
        if (j == 1 && k != 11)
            return `${i}st`;
        if (j == 2 && k != 12)
            return `${i}nd`;
        if (j == 3 && k != 13)
            return `${i}rd`;
        return `${i}th`;
    },
    /** -- Geo-helper */
    addMarginToBounds(bounds) {
        if (!bounds.isValid())
            return bounds;
        const NW = bounds.getNorthWest();
        const SE = bounds.getSouthEast();
        const dist = NW.distanceTo(SE);
        return bounds.extend(NW.toBounds(dist / 10)).extend(SE.toBounds(dist / 10));
    },
    /** The order of data type sorting on the attribute panel */
    getAttribTypeOrder(t) {
        switch (t) {
            case "categorical":
                return 1;
            case "numeric":
                return 2;
            case "timestamp":
                return 3;
            case "timeseries":
                return 4;
            case "recordGeo":
                return 5;
            case "content":
                return 6;
            case "recordGeo":
                return 7;
            default:
                return 20;
        }
    },
    /* -- */
    intersects(d3bound, leafletbound) {
        if (d3bound[0][0] > leafletbound._northEast.lng)
            return false;
        if (d3bound[0][1] > leafletbound._northEast.lat)
            return false;
        if (d3bound[1][0] < leafletbound._southWest.lng)
            return false;
        if (d3bound[1][1] < leafletbound._southWest.lat)
            return false;
        return true;
    },
    /** -- */
    intersectsDOMRect(R1, R2) {
        if (!R1 || !R2)
            return false;
        if (R1.left > R2.right)
            return false;
        if (R1.right < R2.left)
            return false;
        if (R1.top > R2.bottom)
            return false;
        if (R1.bottom < R2.top)
            return false;
        return true;
    },
    /** -- */
    getD3Scale(useLog) {
        return useLog ? d3$n.scaleLog().base(2) : d3$n.scaleLinear();
    },
    /** -- */
    getLineGenerator(timeScale, valueScale) {
        return d3$n
            .line()
            .curve(d3$n.curveMonotoneX)
            .x((d) => timeScale(d._time))
            .y((d) => valueScale(d._value))
            .defined((d) => d._value != null);
    },
    /** -- */
    // http://stackoverflow.com/questions/5737975/circle-drawing-with-svgs-arc-path
    // http://stackoverflow.com/questions/15591614/svg-radial-wipe-animation-using-css3-js
    // http://jsfiddle.net/Matt_Coughlin/j3Bhz/5/
    getPieSVGPath(_start, _angle, radius, strokeOnly) {
        const _end = Math.min(_start + _angle, 0.999999);
        const startRadian = (Math.PI * (360 * _start - 90)) / 180;
        const endRadian = (Math.PI * (360 * _end - 90)) / 180;
        const largeArcFlag = _angle > 0.5 ? 1 : 0;
        return ("M " +
            Math.cos(startRadian) * radius +
            "," +
            Math.sin(startRadian) * radius +
            " A " +
            radius +
            "," +
            radius +
            " " +
            largeArcFlag +
            " " +
            largeArcFlag +
            " 1 " +
            Math.cos(endRadian) * radius +
            "," +
            Math.sin(endRadian) * radius +
            " " +
            (!strokeOnly ? "L0,0" : ""));
    },
    /** -- */
    getCirclePath() {
        return d3$n
            .arc()
            .innerRadius(0)
            .outerRadius(0.001)
            .startAngle(0)
            .endAngle(2 * Math.PI)(null);
    },
};

/** -- */
class Aggregate_Interval extends Aggregate {
    get minV() {
        return this._minV;
    }
    get maxV() {
        return this._maxV;
    }
    get tooltipTitle() {
        return this.attrib.attribNameHTML;
    }
    validateMinMax() {
        if (this.minV <= this.maxV)
            return;
        let _temp = this.minV;
        this._minV = this.maxV;
        this._maxV = _temp;
    }
    isMinLarger() {
        return this.minV > this.attrib.rangeOrg[0];
    }
    isMaxSmaller() {
        return this.maxV < this.attrib.rangeOrg[1];
    }
    updateRecords() {
        this.records = this.attrib.sortedRecords.filter((record) => this.isRecordWithin(record));
    }
    constructor(attrib, minV, maxV) {
        super(attrib);
        this._minV = null;
        this._maxV = null;
        // true if the maximum value is included within the scale
        this.isMaxIncluded = false;
        this.setRange(minV, maxV);
    }
    setRange(_minV, _maxV) {
        this._minV = _minV;
        this._maxV = _maxV;
    }
    isRecordWithin(record) {
        let v = this.attrib.getRecordValue(record);
        if (v < this.minV)
            return false;
        if (v > this.maxV)
            return false;
        if (v === this.maxV)
            return this.isMaxIncluded;
        return true;
    }
    /** -- */
    exportAggregateInfo() {
        return {
            min: this.minV,
            max: this.maxV,
        };
    }
}
class Aggregate_Interval_Numeric extends Aggregate_Interval {
    constructor() {
        super(...arguments);
        this.hasFloat = true;
    }
    get label() {
        if (this.minV == null || this.maxV == null)
            return "-";
        if (this.maxV === this.minV + 1 && !this.hasFloat) {
            return this.attrib.getFormattedValue(this.minV, false);
        }
        var minStr = this.attrib.getFormattedValue(this.minV, false);
        var maxStr = this.attrib.getFormattedValue(this.maxV, false);
        if (this.isMinLarger() && this.isMaxSmaller()) {
            if (this.isMaxIncluded) {
                return `${minStr} &mdash; ${maxStr}`;
            }
            else {
                return `${minStr} up to ${maxStr}`;
            }
        }
        else if (this.isMinLarger()) {
            return `Min ${minStr}`;
        }
        else {
            if (this.isMaxIncluded) {
                return `Max ${maxStr}`;
            }
            else {
                return `Up to ${maxStr}`;
            }
        }
    }
    validateMinMax() {
        super.validateMinMax();
        // must be integers
        if (!this.hasFloat) {
            this._minV = Math.floor(this.minV);
            this._maxV = Math.ceil(this.maxV);
        }
        this._minV = Math.max(this.minV, this.attrib.rangeOrg[0]);
        this._maxV = Math.min(this.maxV, this.attrib.rangeOrg[1]);
    }
}

/** Filtering based on intervals */
class Filter_Interval extends Filter {
    /** -- */
    constructor(_browser, attrib) {
        super(_browser);
        this.attrib = attrib;
    }
    /** -- */
    get title() {
        return this.attrib.attribName;
    }
    /** -- */
    exportFilter() {
        var _ = {};
        if (this.noValueAggr.filtered) {
            _.missing = this.noValueAggr.filtered;
        }
        else if (this.active) {
            _.min = this.active.minV;
            _.max = this.active.maxV;
        }
        return _;
    }
    /** -- */
    importFilter(_) {
        if (_.missing) {
            this.noValueAggr.filtered = _.missing;
        }
        else {
            this.active = this.attrib.createAggregate(_.min, _.max);
        }
        this.setFiltered(false);
        this.applyFilter();
    }
    /** -- */
    onClear() {
        var _a;
        super.onClear();
        this.active = null;
        (_a = this.browser.recordDisplay) === null || _a === void 0 ? void 0 : _a.filterStatusUpdated(this.attrib);
    }
    /** -- */
    onFilter() {
        var _a, _b;
        (_a = this.browser.recordDisplay) === null || _a === void 0 ? void 0 : _a.filterStatusUpdated(this.attrib);
        if (this.noValueAggr.filtered) {
            var c = this.noValueAggr.filtered === "in"
                ? (record) => this.attrib.getRecordValue(record) === null
                : (record) => this.attrib.getRecordValue(record) !== null;
            this.attrib.records.forEach((record) => {
                record.setFilterCache(this.filterID, c(record));
            });
            return;
        }
        var isFilteredCb;
        if (this.active.isMinLarger() && this.active.isMaxSmaller()) {
            if (this.active.isMaxIncluded) {
                isFilteredCb = (v) => v >= this.active.minV && v <= this.active.maxV;
            }
            else {
                isFilteredCb = (v) => v >= this.active.minV && v < this.active.maxV;
            }
            //
        }
        else if (this.active.isMinLarger()) {
            isFilteredCb = (v) => v >= this.active.minV;
            //
        }
        else {
            if (this.active.isMaxIncluded) {
                isFilteredCb = (v) => v <= this.active.maxV;
            }
            else {
                isFilteredCb = (v) => v < this.active.maxV;
            }
        }
        // TO-DO: Optimize: Check if the interval scale is extending/shrinking or completely updated...
        this.attrib.records.forEach((record) => {
            var v = this.attrib.getRecordValue(record);
            record.setFilterCache(this.filterID, v !== null ? isFilteredCb(v) : false);
        });
        (_b = this.attrib.block.DOM.zoomControl) === null || _b === void 0 ? void 0 : _b.attr("sign", this.attrib.block.zoomableStatus());
        this.attrib.block.refreshIntervalSlider();
        super.onFilter();
    }
    filterView_Detail() {
        if (this.noValueAggr.filtered === "in")
            return `(${i18n.NoData})`;
        if (this.noValueAggr.filtered === "out")
            return `(${i18n.ValidData})`;
        return this.active.label;
    }
}
class Filter_Numeric extends Filter_Interval {
}
class Filter_Timestamp extends Filter_Interval {
    /** -- */
    importFilter(_) {
        if (_.missing) {
            this.noValueAggr.filtered = _.missing;
        }
        else {
            this.active = this.active = this.attrib.createAggregate(_.min, _.max);
            // if (this.attrib.type === "timestamp") {
            //   this.active.min = new Date(this.active.min);
            //   this.active.max = new Date(this.active.max);
            // }
        }
        this.setFiltered(false);
        this.applyFilter();
    }
}

class Record {
    /** -- */
    constructor(d, idIndex) {
        // By default, each item is aggregated as 1
        // You can modify this with a non-negative value
        // Note that the aggregation currently works by summation only.
        this.measure_Self = 1;
        // Aggregates which this record falls under
        this._aggrCache = [];
        // The data that's used for mapping this item, used as a cache.
        // This is accessed by filterID, and used for getRecordValue
        this._valueCache = []; // caching the values this item was mapped toggle
        // ********************************************************************
        // Filtering state
        // ********************************************************************
        // Cached filter state, indexed by attribute ID
        this._filterCache = [];
        // Wanted item / not filtered out
        this._filteredOut = false;
        // If true, filter/wanted state is dirty and needs to be updated.
        this._filterCacheIsDirty = true;
        // ********************************************************************
        // Selected state
        // ********************************************************************
        this.selected = {
            Compare_A: false,
            Compare_B: false,
            Compare_C: false,
            Compare_D: false,
            Compare_E: false,
        };
        // ********************************************************************
        // Rank information (used externally)
        // ********************************************************************
        // Rank order of the record. Starts from zero
        // Used by the list view only TODO: Review
        this.recordRank = 0;
        // assigned on data load, each record has a unique order position
        this.recordOrder = 0;
        // negative if filtered out, positive if filtered in
        this.recordRank_Unique = 0;
        this._view = {};
        this.data = d;
        this._id = d[idIndex];
        this.DOM = { record: undefined };
    }
    get id() {
        return this._id;
    }
    get label() {
        return this._id;
    }
    setValue(attrib, v) {
        this._valueCache[attrib.attribID] = v;
    }
    getValue(attrib) {
        return this._valueCache[attrib.attribID];
    }
    get filteredOut() {
        return this._filteredOut;
    }
    get isIncluded() {
        return !this._filteredOut;
    }
    /** -- */
    setFilterCache(index, v) {
        if (this._filterCache[index] === v)
            return;
        this._filterCache[index] = v;
        this._filterCacheIsDirty = true;
    }
    /** Updates isIncluded state, and notifies all related aggregates of the change
     *  Returns true iff the filtered stated is changed.
     **/
    refreshFilterCache() {
        var _a;
        if (!this._filterCacheIsDirty)
            return false;
        var prev = this.isIncluded;
        this._filteredOut = this._filterCache.some((f) => !f); // set to true iff at least one is false
        this._filterCacheIsDirty = false;
        if (this.isIncluded === prev)
            return false;
        if (this.measure_Self != null) {
            // may be zero or negative...
            var cntToAdd = this.isIncluded ? 1 : -1;
            var measureToAdd = cntToAdd * this.measure_Self; // Add : Remove value
            this._aggrCache.forEach((aggr) => {
                aggr.addToActive(measureToAdd, cntToAdd);
            });
        }
        (_a = this.DOM.record) === null || _a === void 0 ? void 0 : _a.classList.toggle("isExcluded");
        return true;
    }
    // if a specific compare type is given, looks that up. otherwise, checks if ANY is selected
    isSelected(cT = null) {
        if (cT)
            return this.selected[cT];
        return Base.Compare_List.some((cT) => this.selected[cT]);
    }
    /** -- */
    get activeComparisons() {
        return Base.Compare_List.filter((cT) => this.selected[cT]);
    }
    // ********************************************************************
    // Used by other methods to track additional view-state
    // ********************************************************************
    /** -- */
    assignDOM(dom) {
        this.DOM.record = dom;
        if (!dom)
            return;
        this.DOM.record.classList[this.isIncluded ? "remove" : "add"]("isExcluded");
        Base.Compare_List.forEach((cT) => {
            this.DOM.record.classList[this.selected[cT] ? "add" : "remove"]("rec-selected-" + cT);
        });
    }
    /** -- */
    removeAggrFromCache(aggr) {
        this._aggrCache.splice(this._aggrCache.indexOf(aggr), 1);
    }
    /** -- */
    moveDOMtoTop() {
        if (this.DOM.record && navigator.userAgent.indexOf("Edge") <= 0) {
            this.DOM.record.parentNode.appendChild(this.DOM.record);
        }
    }
    /** -- */
    highlightRecord() {
        var _a;
        (_a = this.DOM.record) === null || _a === void 0 ? void 0 : _a.classList.add("rec-selected-onRecord");
        // update visuals of aggregates that this record appears in
        this._aggrCache.forEach((aggr) => {
            var _a;
            (_a = aggr.DOM.aggrGlyph) === null || _a === void 0 ? void 0 : _a.classList.add("withRecordHighlight");
            if (aggr instanceof Aggregate_Interval) {
                aggr.attrib.block.showRecordValue(this);
            }
        });
    }
    /** -- */
    unhighlightRecord() {
        var _a;
        (_a = this.DOM.record) === null || _a === void 0 ? void 0 : _a.classList.remove("rec-selected-onRecord");
        this._aggrCache.forEach((aggr) => {
            var _a, _b, _c;
            (_a = aggr.DOM.aggrGlyph) === null || _a === void 0 ? void 0 : _a.classList.remove("withRecordHighlight");
            if (aggr instanceof Aggregate_Interval) {
                (_c = (_b = aggr.attrib.block).hideRecordValue) === null || _c === void 0 ? void 0 : _c.call(_b);
            }
        });
    }
    /** -- */
    flipSelected(f, cT) {
        var _a;
        (_a = this.DOM.record) === null || _a === void 0 ? void 0 : _a.classList[this.selected[cT] === f ? "remove" : "add"]("rec-selected-" + cT);
    }
    /** -- */
    addToAggrMeasure(_type) {
        if (this.filteredOut)
            return;
        this._aggrCache.forEach((aggr) => {
            if (this.measure_Self === 0)
                return;
            aggr[_type].measure += this.measure_Self;
            aggr[_type].recCnt++;
        });
    }
    /** -- */
    removeFromAggrMeasure(_type) {
        if (this.filteredOut)
            return;
        this._aggrCache.forEach((aggr) => {
            if (this.measure_Self === 0)
                return;
            aggr[_type].measure -= this.measure_Self;
            aggr[_type].recCnt--;
        });
    }
    /** -- */
    setCompared(cT) {
        if (this.selected[cT])
            return;
        this.selected[cT] = true;
        if (this.DOM.record) {
            this.DOM.record.classList.add("rec-selected-" + cT);
            // SVG geo area - move it to the bottom of parent so that border can be displayed nicely.
            // TO-DO: improve the conditional check!
            if (this.DOM.record.nodeName === "path")
                this.DOM.record.parentNode.appendChild(this.DOM.record);
        }
        this.addToAggrMeasure(cT);
    }
    /** -- */
    unsetCompared(cT) {
        var _a;
        if (!this.selected[cT])
            return;
        this.selected[cT] = false;
        (_a = this.DOM.record) === null || _a === void 0 ? void 0 : _a.classList.remove("rec-selected-" + cT);
        this.removeFromAggrMeasure(cT);
    }
    /** -- */
    getTimeKeys() {
        // collect ALL time keys / all attributes
        return (this._valueCache
            // only the timseries values
            .filter((_) => _ instanceof TimeSeriesData)
            // Keep TimeData only
            .map((ts) => Object.values(ts._keyIndex))
            .flat()
            // filter to unique values
            .filter((key, index, self) => self.findIndex((t) => t._time.getTime() === key._time.getTime()) === index)
            // sort by _time (latest first)
            .sort((a, b) => b._time.getTime() - a._time.getTime()));
    }
}

const d3$m = { extent };
class Attrib_Interval extends Attrib {
    get block() {
        return this._block;
    }
    get attribName() {
        return super.attribName;
    }
    set attribName(name) {
        super.attribName = name;
        // name wasn't updated
        if (this.attribName === name) {
            this.browser.recordDisplay.refreshAttribOptions("sort");
        }
    }
    binMatch(bin, aggr) {
        return +bin[0] - +aggr.minV === 0 && +bin[1] - +aggr.maxV === 0;
    }
    // Resets the valueScale and intervalTicks based on 
    // active range (filtering/zoom), UI width, scale type
    refreshValueScale() {
        var nicing = this.block.getScaleNicing();
        this.valueScale = this.getValueScaleObj()
            .domain(this.rangeActive)
            .range([0, this.block.width_histogram])
            .nice(nicing);
        this.intervalTicks = this.valueScale.ticks(nicing);
        this.updateTickPrintFunc();
    }
    updateScaleAndBins(forceRenderUpdate = false) {
        if (this.isEmpty())
            return;
        if (!this.aggr_initialized)
            return;
        this.valueScale_prev = this.valueScale.copy();
        // if the labels are updated (multiple rows), design needs update too.
        var height_labels_prev = this.block.height_Ticklabels;
        this.refreshValueScale();
        var ticks = this.intervalTicks;
        if (ticks.length === 0)
            return;
        this.block.aggrWidth =
            this.valueScale(ticks[1]) - this.valueScale(ticks[0]);
        // converts ticks to bins
        var bins = this.intervalTicks.reduce((result, value, index, array) => {
            if (index < array.length - 1) {
                result.push([value, array[index + 1], null]);
            }
            return result;
        }, []);
        // Identify aggregates that don't match to a bin, clear their records, remove them from all aggreegate index
        this._aggrs = this._aggrs.filter((curAggr) => {
            // aggregate that matches one of the bins exists already. Do not modify...
            if (bins.some((bin) => this.binMatch(bin, curAggr))) {
                return true;
            }
            curAggr.clearRecords();
            this.browser.allAggregates.splice(this.browser.allAggregates.indexOf(curAggr), 1);
            return false;
        });
        // keep only bins that do not have an existing aggregate
        bins = bins.filter((bin) => !this._aggrs.some((curAggr) => this.binMatch(bin, curAggr)));
        // if there are new bins, create aggregates, and put records inside
        if (bins.length > 0) {
            // create new aggregate interval for each remaining bin
            bins.forEach((bin, i) => {
                let aggr = this.getAggregate(bin[0], bin[1]);
                if (i === bins.length - 1) {
                    aggr.isMaxIncluded = true;
                }
                bin[2] = aggr; // indexing aggregate object for the bin
            });
            // sort aggregates by order of bin values, min to max
            this._aggrs = this._aggrs.sort((a, b) => +b.minV - +a.minV);
            // place records across bins
            this.records.forEach((record) => {
                var v = this.getRecordValue(record);
                if (v == null)
                    return;
                // Add record into appropriate bin.
                // This iterates only over new bins
                bins.forEach((bin) => {
                    if (v < bin[0])
                        return;
                    var aggr = bin[2];
                    if (v < bin[1] || (v == bin[1] && aggr.isMaxIncluded)) {
                        aggr.addRecord(record);
                    }
                });
            });
        }
        // RENDER UPDATES
        if (!this.block.DOM.inited)
            return;
        this.block.refreshIntervalSlider();
        if (bins.length > 0 || forceRenderUpdate) {
            this.block.insertVizDOM();
            if (height_labels_prev !== this.block.height_Ticklabels) {
                this.block.setHeight(this.block.getHeight());
            }
            this.updateChartScale_Measure();
            this.block.refreshViz_All(false); // no-axis
        }
    }
    get stepTicks() {
        return this._stepTicks;
    }
    setStepTicks(v) {
        this._stepTicks = v;
    }
    initializeAggregates() {
        if (this.aggr_initialized)
            return;
        if (this.noValueAggr.records.length > 0) {
            this.noValueAggr.records = [];
            this.noValueAggr.resetAggregateMeasures();
        }
        this.fillValueCache();
        // remove records that map to null / undefined
        this.sortedRecords = this.records.filter((record) => this.getRecordValue(record) != null);
        // Sort the items by their attribute value
        this.sortedRecords.sort((a, b) => {
            // +Date converts the date to a number, and the template system continues by conversion
            let a1 = +this.getRecordValue(a);
            let a2 = +this.getRecordValue(b);
            return a1 - a2;
        });
        this.updatedRangeOrg();
        this.refreshValueScale();
        this.pofffff();
        this.aggr_initialized = true;
    }
    getAggregate(minV, maxV) {
        var newAggr = this.createAggregate(minV, maxV);
        this._aggrs.push(newAggr);
        this.browser.allAggregates.push(newAggr);
        return newAggr;
    }
    createSummaryFilter() {
        this.summaryFilter = new Filter_Interval(this.browser, this);
    }
    updatedRangeOrg() {
        this.rangeOrg = this.getRecordValueExtent();
    }
    // returns filtered range if filtered. Otherwise, original range
    get rangeActive() {
        return (this.summaryFilter.isFiltered && this.block.zoomed.is(true))
            ? [this.summaryFilter.active.minV, this.summaryFilter.active.maxV]
            : this.rangeOrg;
    }
    // in numbers, if time-series key, uses timeseries extent automatically
    getRecordValueExtent() {
        return d3$m.extent(this.sortedRecords, (record) => this.getRecordValue(record));
    }
    // if time-series time key, returns timeserie's scale domain.
    getVizDomain() {
        this.initializeAggregates();
        return this.valueScale.domain();
    }
    // creates new aggregate, and uses a timer to run the filtering
    setRangeFilter_Custom(minV, maxV) {
        var aggr = this.createAggregate(minV, maxV);
        aggr.validateMinMax();
        this.setRangeFilter(aggr, true);
    }
    setRangeFilter(aggr, useTimer = false) {
        aggr.validateMinMax();
        this.summaryFilter.active = aggr;
        this.summaryFilter.noValueAggr.filtered = false;
        this.block.refreshIntervalSlider();
        if (this.rangeFilterTimer)
            window.clearTimeout(this.rangeFilterTimer);
        this.rangeFilterTimer = window.setTimeout(() => {
            this.summaryFilter.setFiltered();
            this.rangeFilterTimer = 0;
        }, useTimer ? 250 : 0);
    }
    get sortLabel() {
        if (this._sortLabel) {
            return (record) => this._sortLabel.call(record.data, record);
        }
        return (record) => {
            var s = this.getRecordValue(record);
            return s == null ? "" : this.getFormattedValue(s, false);
        };
    }
    set sortLabel(v) {
        this._sortLabel = v;
    }
    // ********************************************************************
    // Record / printing / access
    // ********************************************************************
    getRecordValue(record) {
        return record.getValue(this);
    }
    constructor(browser, name, template, _type, blockClassName, nuggetClassName) {
        super(browser, name, template, _type, "kshfSummary_Interval " + blockClassName, // adds "kshfSummary_Interval" to given class name
        nuggetClassName);
        this._aggrs = [];
        this.sortedRecords = [];
        // ********************************************************************
        // Value scale and Ticks
        // ********************************************************************
        this.intervalTicks = [];
        // d3 scale object (linear / log / time
        // depends on whether it is numeric or timestamp attibute
        this.valueScale = null;
        this.valueScale_prev = null;
        // looks like a function, but created like a member in subclasses dynamically
        this.intervalTickPrint = null;
        // ********************************************************************
        // Step ticks
        // ********************************************************************
        this._stepTicks = false;
        this.rangeFilterTimer = 0;
        // ********************************************************************
        // Sort labels (when attribute is used for sorting)
        // ********************************************************************
        this._sortLabel = null;
        this.createSummaryFilter();
    }
    updateChartScale_Measure(skipRefreshViz = false) {
        if (!this.block.isVisible())
            return;
        super.updateChartScale_Measure(skipRefreshViz);
        this.block.refreshViz_Bins();
        this.block.refreshViz_All(false); // no-axis
    }
    get measureRangeMax() {
        return this.block.height_hist;
    }
    // if range is invalid, returns the same value in both pairs
    sanitizeRange(minV, maxV) {
        var activeRanges = this.activeComparisons
            .filter((_) => {
            return (this.browser.Compare_Highlight !== _ &&
                this.browser.selectedAggrs[_].minV != null);
        })
            .map((_) => this.browser.selectedAggrs[_])
            .map((_) => ({ minV: _.minV, maxV: _.maxV }));
        var r = activeRanges.reduce((accum, curRange) => {
            // zero size range. no-op
            if (accum.minV === accum.maxV)
                return accum;
            // current range holds the input range. bad!
            if (curRange.minV <= accum.minV && accum.maxV <= curRange.maxV) {
                return { minV: minV, maxV: maxV }; // same value - signals invalid range
            }
            // input range holds the active range. bad!
            if (accum.minV <= curRange.minV && curRange.maxV <= accum.maxV) {
                return { minV: minV, maxV: maxV }; // same value - signals invalid range
            }
            // current range does not intersect with active range. Continue as-is
            if (curRange.minV > accum.maxV || curRange.maxV < accum.minV) {
                return accum;
            }
            // current range limits the active minimum value
            if (curRange.maxV > accum.minV && curRange.minV < accum.minV) {
                return { minV: curRange.maxV, maxV: accum.maxV };
            }
            // current range limits the active maximum value
            if (curRange.minV < accum.maxV && curRange.minV > accum.maxV) {
                return { minV: accum.minV, maxV: curRange.minV };
            }
            return accum;
        }, { minV: minV, maxV: maxV });
        return [r.minV, r.maxV];
    }
    renderRecordValue(v, d3_selection) {
        if (v instanceof Record)
            v = this.getRecordValue(v);
        if (v == null) {
            v = "-";
        }
        else if (this.type !== "timestamp") {
            v = v.toLocaleString();
        }
        let str = this.getFormattedValue(v, false);
        if (d3_selection) {
            d3_selection.html(str);
        }
        else {
            return str;
        }
    }
    /** -- */
    printAbbr(v, isSVG = false) {
        if (v == null)
            return "-";
        this.initializeAggregates();
        return this.getFormattedValue(this.intervalTickPrint(v), isSVG);
    }
    isEmpty() {
        return !this.aggr_initialized;
    }
    applyConfig(blockCfg) {
        const _super = Object.create(null, {
            applyConfig: { get: () => super.applyConfig }
        });
        return __awaiter(this, void 0, void 0, function* () {
            _super.applyConfig.call(this, blockCfg);
            yield this.block.showHistogram.set(blockCfg.showHistogram);
            yield this.block.optimumBinWidth.set(blockCfg.optimumBinWidth);
            yield this.block.maxHeightRatio.set(blockCfg.maxHeightRatio);
            yield this.measureScaleType.set(blockCfg.measureScaleType);
            yield this.block.zoomed.set(blockCfg.zoomed);
            if (blockCfg.filter) {
                this.summaryFilter.importFilter(blockCfg.filter);
            }
            else if (this.isFiltered()) {
                this.summaryFilter.clearFilter();
            }
        });
    }
}

const d3$l = { select, pointer };
class Block {
    // browser of the block (retrieved from attribute)
    get browser() {
        return this.attrib.browser;
    }
    // shorthand
    get _aggrs() {
        return this.attrib._aggrs;
    }
    get collapsed() {
        return this._collapsed;
    }
    constructor(attrib) {
        this.DOM = { inited: false };
        // The panel this block appears in (if placed in dashboard)
        this.panel = null;
        // Can be accessed by called .collapsed
        this._collapsed = false;
        this._height_header = 0; // TODO
        // This can be set to true to prevent refreshViz_Axis from executing
        this.noRefreshVizAxis = false;
        this.attrib = attrib;
    }
    get inDashboard() {
        return this.panel !== null;
    }
    isVisible() {
        return (!this.attrib.isEmpty() &&
            this.inDashboard &&
            !this.collapsed &&
            this.DOM.inited);
    }
    onClearFilter(forceUpdate = false) { }
    getWidth() {
        return this.panel ? this.panel.width_Real - 2 : 0; // 1 pixel border on left & right
    }
    getHeight() {
        return this.height_Header + this.height_Content;
    }
    get height_withMargin() {
        return this.getHeight() + 8;
    }
    get height_Header() {
        if (!this.DOM.inited)
            return 0;
        if (!this._height_header) {
            if (this.panel.isCollapsed())
                return 0;
            this._height_header = 29; // too much work to get the height/width right with panels collapsing
            // 1 * this.DOM.headerGroup.node().offsetHeight;
        }
        return this._height_header;
    }
    refreshHeight() {
        if (this.attrib.isEmpty() || !this.inDashboard || !this.DOM.inited)
            return;
        this.DOM.root.style("flex-basis", this.getHeight() + "px");
    }
    insertRoot(beforeDOM) {
        this.DOM.root = this.panel.DOM.root.insert("div", () => {
            return beforeDOM;
        });
        this.DOM.root
            .attr("class", "kshfSummary " + this.attrib.blockClassName)
            .attr("summary_id", this.attrib.attribID) // can be used to customize a specific summary using CSS
            .classed("disableCompareLock", !this.attrib.isComparable.is(true))
            .classed("filtered", this.attrib.isFiltered())
            .datum(this);
        // can be extended by sub-classes
        this.insertHeader();
        // initialize config controls
        Object.values(this.attrib.configs).forEach((cfg) => cfg.insertControl(this.DOM.summaryConfig));
    }
    updateDescription() {
        var _a, _b;
        (_a = this.DOM.nugget) === null || _a === void 0 ? void 0 : _a.select(".summaryDescription").classed("active", this.attrib.description ? true : null).node().tippy.setContent(this.attrib.description);
        (_b = this.DOM.summaryIcons) === null || _b === void 0 ? void 0 : _b.select(".summaryDescription").classed("active", this.attrib.description ? true : null);
    }
    addToPanel(panel, index = null, _force = false) {
        var _a;
        if (!panel)
            return;
        if (index === null) {
            index = panel.attribs.length; // add to end
        }
        var panelChanged = false;
        if (this.panel === null) {
            panelChanged = true;
        }
        else if (this.panel && this.panel !== panel) {
            this.panel.removeBlock(this);
            panelChanged = true;
        }
        else {
            // re-inserting to current panel
            if (this.orderInPanel === index) {
                return; // inserting the summary to the same index as current one
            }
            // remove the dropzone above the moved summary
            var dropZoneDOM = this.panel.DOM.root.selectAll(".dropZone").nodes()[this.orderInPanel];
            dropZoneDOM.parentNode.removeChild(dropZoneDOM);
            if (this.orderInPanel < index)
                index--;
        }
        panel.addBlock(this, index);
        (_a = this.DOM.nugget) === null || _a === void 0 ? void 0 : _a.classed("inDashboard", (_) => this.inDashboard);
        if (panelChanged) {
            this.refreshWidth();
            this.refreshViz_Axis();
        }
        this.browser.refreshIsEmpty();
    }
    removeFromPanel() {
        var _a;
        if (!this.panel)
            return;
        this.panel.removeBlock(this);
        if (this.DOM.root) {
            let dom = this.DOM.root.node();
            dom.parentNode.removeChild(dom);
        }
        this.panel = null;
        (_a = this.DOM.nugget) === null || _a === void 0 ? void 0 : _a.classed("inDashboard", (_) => this.inDashboard);
        this.browser.refreshIsEmpty();
    }
    insertHeader() {
        var me = this;
        var _tempMoved = false;
        this.DOM.headerGroup = this.DOM.root
            .append("div")
            .attr("class", "headerGroup")
            .on("mousedown", function (event) {
            if (!me.browser.authorMode) {
                event.preventDefault();
                return;
            }
            var _this = this;
            var moved = false;
            _tempMoved = false;
            d3$l.select("body")
                .style("cursor", "move")
                .on("keydown.layout", function () {
                if (event.keyCode === 27) {
                    // Escape key
                    _this.style.opacity = null;
                    me.browser.clearDropZones();
                }
            })
                .on("mousemove.layout", function (event2) {
                _tempMoved = true;
                if (!moved) {
                    if (_this.nextSibling)
                        _this.nextSibling.style.display = "none";
                    if (_this.previousSibling)
                        _this.previousSibling.style.display = "none";
                    _this.parentNode.style.opacity = 0.5;
                    me.browser.prepareDropZones(me.attrib, "browser");
                    moved = true;
                }
                var mousePos = d3$l.pointer(event2, me.browser.DOM.root.node());
                me.browser.DOM.attribDragBox.style("transform", "translate(" +
                    (mousePos[0] - 20) +
                    "px," +
                    (mousePos[1] + 5) +
                    "px)");
                event2.stopPropagation();
                event2.preventDefault();
            })
                .on("mouseup.layout", function (event2) {
                d3$l.select("body").style("cursor", null);
                // Mouse up on the body
                me.browser.clearDropZones();
                if (me.panel !== undefined || true) {
                    _this.parentNode.style.opacity = null;
                    if (_this.nextSibling)
                        _this.nextSibling.style.display = "";
                    if (_this.previousSibling)
                        _this.previousSibling.style.display = "";
                }
                event2.preventDefault();
            });
            event.preventDefault();
        })
            .on("mouseup", () => {
            if (_tempMoved)
                return;
            d3$l.select("body").style("cursor", null);
            this.browser.clearDropZones();
            this.browser.unregisterBodyCallbacks();
        });
        this.DOM.headerGroup
            .append("span")
            .attr("class", "header_display_control iconGroup")
            .on("mousedown", (event) => event.stopPropagation())
            .selectAll("span")
            .data([
            [
                "Remove",
                "far fa-times-circle",
                () => {
                    this.removeFromPanel();
                    this.browser.updateLayout();
                },
            ],
            [
                "Collapse",
                "far fa-compress-alt",
                () => this.setCollapsedAndLayout(true),
            ],
            ["Open", "far fa-expand-alt", () => this.setCollapsedAndLayout(false)],
        ])
            .enter()
            .append("span")
            .attr("class", (_) => "buttonSummary" + _[0] + " " + _[1])
            .tooltip((_) => i18n[_[0] + "Summary"], { placement: "bottom" })
            .on("click", (_event, _) => _[2]());
        this.DOM.summaryNameWrapper = this.DOM.headerGroup
            .append("span")
            .attr("class", "summaryNameWrapper");
        this.DOM.blockName = this.DOM.summaryNameWrapper
            .append("span")
            .attr("class", "blockName summaryName")
            .on("click", () => {
            if (this.collapsed) {
                this.setCollapsedAndLayout(false); //un-collapse
            }
        });
        this.attrib.addDOMBlockName(this.DOM.blockName);
        this.DOM.summaryIcons = this.DOM.headerGroup
            .append("span")
            .attr("class", "summaryIcons iconGroup")
            .on("mousedown", (event) => event.stopPropagation());
        this.DOM.summaryConfigControl = this.DOM.summaryIcons
            .append("span")
            .attr("class", "summaryConfigControl fal fa-cog")
            .tooltip(i18n.Configure, { placement: "bottom" })
            .on("click", () => {
            var open = !this.DOM.root.classed("showConfig");
            this.browser.closeConfigPanels();
            if (open) {
                this.browser.blockWithOpenConfig = this;
            }
            this.DOM.root.classed("showConfig", open);
        });
        this.DOM.summaryIcons
            .append("span")
            .attr("class", "summaryDescription fa fa-info")
            .tooltip("", {
            placement: "bottom",
            onShow: (instance) => {
                instance.reference.tippy.setContent(this.attrib.description);
            },
        });
        this.updateDescription();
        this.DOM.headerGroup
            .append("div")
            .attr("class", "configPanel summaryConfig")
            .on("mousedown", (event) => event.stopPropagation())
            .call((summaryConfig) => {
            summaryConfig
                .append("div")
                .attr("class", "configClose fa fa-window-close")
                .tooltip(i18n.Close)
                .on("click", () => {
                this.browser.closeConfigPanels();
                this.DOM.root.classed("showConfig", false);
            });
            summaryConfig
                .append("div")
                .attr("class", "compactSizeControl far fa-angle-double-up")
                .on("click", (event) => event.target.parentNode.classList.toggle("compact"));
            this.DOM.summaryConfig = summaryConfig
                .append("table")
                .attr("class", "configTable");
        });
        this.DOM.wrapper = this.DOM.root.append("div").attr("class", "wrapper");
        this.refreshSummaryName_DOM();
        this.insertDOM_EmptyAggr();
        this.DOM.summaryNameWrapper
            .insert("div", ":first-child")
            .attr("class", "summaryHeaderButton clearFilterButton fa")
            .tooltip(i18n.RemoveFilter, { placement: "bottom" })
            .on("mousedown", (event) => event.stopPropagation())
            .on("click", (event) => {
            var _a;
            (_a = this.attrib.summaryFilter) === null || _a === void 0 ? void 0 : _a.clearFilter();
            event.stopPropagation();
        });
        this.DOM.summaryNameWrapper
            .append("div")
            .attr("class", "summaryHeaderButton summaryLockButton far fa-clone")
            .tooltip("", {
            onTrigger: (instance) => {
                instance.reference.tippy.setContent(i18n[this.browser.comparedAttrib === this.attrib
                    ? "Unlock"
                    : "CompareTopCategories"]);
            },
        })
            .on("mousedown", (event) => event.stopPropagation())
            .on("click", (event) => {
            if (this.attrib.isComparedAttrib()) {
                this.browser.clearSelect_Compare(this.browser.activeComparisons, true, true);
            }
            else {
                this.attrib.autoCompare();
            }
            event.stopPropagation();
        });
    }
    refreshSummaryName_DOM() {
        var _a;
        if (this.DOM.blockName) {
            this.attrib.addDOMBlockName(this.DOM.blockName);
        }
        (_a = this.DOM.nugget) === null || _a === void 0 ? void 0 : _a.select(".summaryName").html(this.attrib.printName);
    }
    get hasNugget() {
        return !!this.DOM.nugget;
    }
    refreshNugget(_dom) {
        var me = this;
        let attribMoved;
        this.DOM.nugget = _dom;
        this.DOM.nugget
            .on("dblclick", (event, d) => {
            if (event.which !== 1)
                return; // only respond to left-click
            if (this.inDashboard) {
                this.removeFromPanel();
            }
            else {
                this.browser.autoAddAttib(d.item);
            }
            this.browser.updateLayout();
        })
            .on("mousedown", function (event) {
            if (event.which !== 1)
                return; // only respond to left-click
            var _this = this;
            attribMoved = false;
            d3$l.select("body")
                .on("keydown.layout", (event2) => {
                if (event2.keyCode === 27) {
                    // Escape key
                    _this.removeAttribute("moved");
                    me.browser.clearDropZones();
                }
            })
                .on("mousemove.layout", (event2) => {
                if (!attribMoved) {
                    _this.setAttribute("moved", "");
                    me.browser.prepareDropZones(me.attrib, "authoringPanel");
                    attribMoved = true;
                }
                var mousePos = d3$l.pointer(event2, me.browser.DOM.root.node());
                me.browser.DOM.attribDragBox.style("transform", `translate(${mousePos[0] - 20}px,${mousePos[1] + 5}px)`);
                event2.stopPropagation();
                event2.preventDefault();
            })
                .on("mouseup.layout", (event2) => {
                if (!attribMoved)
                    return;
                _this.removeAttribute("moved");
                me.browser.DOM.root.attr("drag_cursor", null);
                me.browser.clearDropZones();
                event2.preventDefault();
            });
            event.preventDefault();
        })
            .on("mouseup", () => {
            if (!attribMoved)
                this.browser.unregisterBodyCallbacks();
        });
    }
    setCollapsedAndLayout(collapsed) {
        this.setCollapsed(collapsed);
        this.browser.updateLayout_Height();
        if (!this.DOM.root || this.collapsed || !this.DOM.inited)
            return;
        this.refreshViz_All();
        this.refreshMeasureLabelText("Active");
    }
    setCollapsed(v) {
        var _a, _b;
        this._collapsed = v;
        (_a = this.panel) === null || _a === void 0 ? void 0 : _a.refreshCollapsed();
        this.height_Header; // computes header height if needed.
        (_b = this.DOM.root) === null || _b === void 0 ? void 0 : _b.classed("collapsed", this.collapsed).classed("showConfig", false);
        this.onCollapse();
    }
    // Can be extended by sub-classes as needed
    onCollapse() {
        return;
    }
    // used by subclasses as well
    get measureLineZero() {
        return this.attrib.chartScale_Measure(0);
    }
    refreshViz_Cache(sT, _preCompare = null) {
        if (!this.DOM.inited)
            return;
        if (this.attrib.type === "setpair")
            return;
        var baseline = this.measureLineZero;
        var preCompare = this.browser.stackedChart
            ? _preCompare || this.browser.activeComparisons
            : [];
        var _chartValue = (aggr, sT) => this.attrib.chartScale_Measure(this.browser.getChartValue(aggr, sT)) -
            baseline;
        this._aggrs.forEach((aggr) => {
            aggr.setScale(sT, _chartValue(aggr, sT));
            aggr.setOffset(sT, preCompare.reduce((accum, sT) => accum + _chartValue(aggr, sT), 0));
        });
        // flip 'active' selection
        if (sT === "Active" && preCompare.length > 0 && this.browser.stackedChart) {
            this._aggrs.forEach((aggr) => {
                aggr.setScale(sT, aggr.scale("Active") - aggr.offset(sT));
            });
        }
    }
    /** -- */
    refreshViz_All(withAxisRefresh = true) {
        if (!this.isVisible())
            return;
        if (!this.attrib.chartScale_Measure)
            return;
        this.refreshViz_Active();
        this.refreshViz_Compare_All();
        this.refreshViz_NoValueAggr();
        if (withAxisRefresh)
            this.refreshViz_Axis();
    }
    // -- TODO: incomplete / check references, not used much
    refreshViz(sT) {
        if (this.attrib.type === "content")
            return;
        return sT === "Active"
            ? this.refreshViz_Active()
            : this.refreshViz_Compare(sT, 0, 0, null);
    }
    /** -- */
    refreshViz_Compare_All() {
        if (this.attrib.type === "content")
            return;
        var compared = this.browser.activeComparisons;
        var totalC = this.browser.activeComparisonsCount;
        compared.forEach((cT, i) => this.refreshViz_Compare(cT, i, totalC, compared.slice(0, i)));
    }
    /** -- */
    refreshViz_Axis() {
        if (!this.isVisible())
            return;
        if (this.noRefreshVizAxis)
            return;
        var axis_Scale = this.attrib.chartScale_Measure.copy().clamp(false);
        // GET TICK VALUES ***********************************************************
        // (no more than 10 tick values)
        var tickValues = axis_Scale.ticks(Math.min(10, this.chartAxis_Measure_TickSkip()));
        // Remove 0-tick if all domain values are non-negative
        // if(axis_Scale.domain()[0]>=0) tickValues = tickValues.filter(d => d!==0 );
        if (this.browser.hasIntOnlyMeasure())
            tickValues = tickValues.filter((d) => Number.isInteger(d));
        var ticks = tickValues.map((p) => ({ tickValue: p, major: true }));
        if (this.attrib.measureScale_Log) {
            if (this.attrib.measureLogBase === 2) {
                Util.insertMinorTicks(tickValues, this.attrib.chartScale_Measure, ticks);
            }
            else {
                var maxDomainValue = axis_Scale.domain()[1];
                if (maxDomainValue > this.attrib.measureLogBase) {
                    ticks = [];
                    tickValues = [];
                    var x = 1;
                    maxDomainValue *= this.attrib.measureLogBase; // adding one more major tick beyond the domain, so minors can be added.
                    while (x < maxDomainValue) {
                        ticks.push({ tickValue: x, major: true });
                        tickValues.push(x);
                        x *= this.attrib.measureLogBase;
                    }
                }
                Util.insertMinorTicks(tickValues, this.attrib.chartScale_Measure, ticks, this.attrib.measureLogBase - 1);
                maxDomainValue = axis_Scale.domain()[1];
                ticks = ticks.filter((_) => _.tickValue < maxDomainValue);
            }
        }
        var _transform = this.attrib.type === "categorical"
            ? (d, _scale) => `translateX(${_scale(d.tickValue) - 0.5}px)`
            : (d, _scale) => `translateY(${-_scale(d.tickValue)}px)`;
        var finalAnim = (t) => t
            .style("transform", (d) => _transform(d, axis_Scale))
            .style("opacity", 1);
        var selection = this.DOM.chartAxis_Measure_TickGroup
            .selectAll("span.tick")
            .data(ticks, (t) => t.tickValue);
        selection
            .enter()
            .append("span")
            .attr("class", "tick")
            .call((ticks) => {
            ticks.append("span").attr("class", "line");
            ticks.append("span").attr("class", "text measureAxis_1");
            ticks.append("span").attr("class", "text measureAxis_2");
            if (this.browser.chartsLoaded &&
                this.attrib.chartScale_Measure_prev &&
                !this.browser.preventAxisScaleTransition) {
                // to transition position from previous scale, set position based on previous scale first
                ticks = ticks
                    .style("opacity", 0)
                    .classed("noAnim", true)
                    .style("transform", (tick) => _transform(tick, this.attrib.chartScale_Measure_prev))
                    .classed("noAnim", false)
                    .transition().duration(0).delay(10);
            }
            finalAnim(ticks);
        })
            .merge(selection)
            .classed("major", (tick) => tick.major)
            .classed("minor", (tick) => !tick.major)
            .call((x) => x
            .selectAll(".text")
            .html((tick) => this.browser.getValueLabel(tick.tickValue, false)));
        finalAnim(selection);
        selection.exit().call((exit) => {
            if (this.browser.chartsLoaded &&
                this.attrib.chartScale_Measure_prev &&
                !this.browser.preventAxisScaleTransition) {
                exit = exit.style("transform", (tick) => _transform(tick, axis_Scale));
            }
            return exit
                .style("opacity", 0)
                .transition()
                .duration(0)
                .delay(500)
                .remove();
        });
    }
    refreshViz_NoValueAggr() {
        var _a;
        if (this.attrib.noValueAggr.records.length === 0)
            return;
        (_a = this.DOM.noValueAggr) === null || _a === void 0 ? void 0 : _a.classed("visible", this.attrib.noValueAggr.recCnt("Active") > 0);
    }
    refreshMeasureLabelPos_All() {
        this.refreshMeasureLabelPos("Active");
        this.browser.activeComparisons.forEach((cT, i) => this.refreshMeasureLabelPos(cT, i));
    }
    refreshMeasureLabelPos(sT = "Active", curGroup = 0) {
        // No-op, can be extended
    }
    refreshMeasureLabelText(selectType) {
        var _a;
        if (!this.isVisible())
            return;
        var _ = this.DOM["measureLabel_" + selectType];
        if (!_)
            return;
        var offset = this.browser.stackedChart && selectType === "Active"
            ? this.browser.activeComparisons
            : [];
        var func = (aggr) => {
            var _a, _b;
            var _val = this.browser.getMeasureValue(aggr, selectType, null, offset);
            var isSVG = ((_b = (_a = aggr.DOM) === null || _a === void 0 ? void 0 : _a.aggrGlyph) === null || _b === void 0 ? void 0 : _b.nodeName) === "g";
            return this.browser.getValueLabel(_val, isSVG, Base.percentDecimal ? 1 : 0);
        };
        _.html(func);
        if (this.attrib.noValueAggr.records.length > 0 &&
            selectType === "Active") {
            offset = [];
            (_a = this.DOM.noValueAggr) === null || _a === void 0 ? void 0 : _a.select(".measureLabel_Active").html(func);
        }
    }
    insertDOM_EmptyAggr() {
        this.DOM.noValueAggr = this.DOM.wrapper
            .append("span")
            .attr("class", "noValueAggr aggrGlyph")
            .classed("filtered", this.attrib.noValueAggr.filtered)
            .datum(this.attrib.noValueAggr)
            .tooltip((_) => this.attrib.noValueAggr.getTooltipHTML(), {
            theme: "dark kshf-tooltip kshf-record",
        })
            .each((_, i, nodes) => {
            this.attrib.noValueAggr.setAggrGlyph(nodes[i]);
        })
            .on("mouseover", () => {
            if (this.browser.adjustMode)
                return;
            if (this.browser.mouseOverCompare.is(false))
                return;
            this.browser.setSelect_Compare(this.attrib.noValueAggr);
        })
            .on("mouseout", () => {
            this.browser.clearSelect_Compare();
        })
            .on("click", (event) => {
            if (event.shiftKey) {
                this.browser.lockSelect_Compare();
                return;
            }
            var noValAggr = this.attrib.noValueAggr;
            var menuConfig = { name: "Filter", items: [] };
            if (noValAggr.filtered) {
                menuConfig.items.push({
                    id: "filterOption_Remove",
                    name: `<span class='filterContextOpt'>${i18n.Clear}</span>`,
                    do: () => {
                        noValAggr.filtered = false;
                        this.attrib.summaryFilter.how = "All";
                        this.attrib.summaryFilter.clearFilter();
                    },
                });
            }
            if (noValAggr.filtered !== "in") {
                menuConfig.items.push({
                    id: "filterOption_Only",
                    iconXML: "✗",
                    name: i18n.KeepNoData,
                    helparticle: "5e88e95e04286364bc97d43f",
                    do: () => {
                        this.attrib.summaryFilter.clearFilter();
                        noValAggr.filtered = "in";
                        this.attrib.summaryFilter.how = "All";
                        this.attrib.summaryFilter.setFiltered();
                    },
                });
            }
            if (noValAggr.filtered !== "out") {
                menuConfig.items.push({
                    id: "filterOption_Not",
                    iconXML: "✓",
                    name: i18n.KeepValidData,
                    helparticle: "5e88e95e04286364bc97d43f",
                    do: () => {
                        noValAggr.filtered = "out";
                        this.attrib.summaryFilter.setFiltered();
                    },
                });
            }
            Modal.popupMenu(event, menuConfig, noValAggr);
        });
        this.DOM.noValueAggr.append("div").attr("class", "noValueIcon").text("∅");
        this.DOM.noValueAggr
            .append("div")
            .attr("class", "measureLabel measureLabel_Active");
        this.refreshViz_NoValueAggr();
    }
    refreshUIFiltered(v) {
        var _a;
        (_a = this.DOM.root) === null || _a === void 0 ? void 0 : _a.classed("filtered", v).classed("filtered_missing", v ? this.attrib.noValueAggr.filtered !== false : false);
    }
    // -- Shared - Summary Base --
    insertChartAxis_Measure(dom) {
        this.DOM.chartAxis_Measure = dom
            .append("div")
            .attr("class", "chartAxis_Measure");
        this.DOM.chartAxis_Measure.append("div").attr("class", "measureDescrLabel");
        this.refreshMeasureDescrLabel();
        this.DOM.chartAxis_Measure_TickGroup = this.DOM.chartAxis_Measure
            .append("div")
            .attr("class", "tickGroup");
    }
    refreshMeasureDescrLabel() {
        var _a;
        (_a = this.DOM.root) === null || _a === void 0 ? void 0 : _a.selectAll(".measureDescrLabel").html(i18n.MeasureDescrLabel(this.browser, this.attrib));
    }
    // Utility method for subclasses
    insertAggrLockButton(dom, placement) {
        var onClick = (aggr) => {
            if (aggr.compared && aggr.locked) {
                this.browser.clearSelect_Compare(aggr.compared, true, true);
            }
            else {
                if (this.browser.setSelect_Compare(aggr, null, false // no finalize analytics
                )) {
                    this.browser.lockSelect_Compare();
                }
            }
        };
        dom
            .append("span")
            .attr("class", "lockButton far fa-clone")
            .tooltip((_) => i18n[_.locked ? "Unlock" : "LockToCompare"], {
            placement: placement,
        })
            .on("click", (event, aggr) => {
            if (this.browser.comparedAttrib && !this.attrib.isComparedAttrib()) {
                Modal.confirm(i18n.DialogChangeCompare(this.attrib.attribNameHTML, this.browser.comparedAttrib.attribNameHTML), i18n.Confirm).then(() => {
                    this.browser.clearSelect_Compare(this.browser.activeComparisons, false, true); // don't finalize yet
                    onClick(aggr);
                }, () => { });
            }
            else if (!this.browser.Compare_Highlight && !aggr.locked) {
                Modal.alert(i18n.ComparedSelectionsLimit);
            }
            else {
                onClick(aggr);
            }
            event.preventDefault();
            event.stopPropagation();
        });
    }
    // ********************************************************************
    // ********************************************************************
    showRecordValue(record) { }
    hideRecordValue() { }
}

const d3$k = {
    select,
    pointer,
    min,
    max,
    extent,
};
class Block_Interval extends Block {
    // shorthand
    get valueScale() {
        return this.attrib.valueScale;
    }
    constructor(attrib) {
        super(attrib);
        // pixel width settings...
        this.height_hist = 1; // Initial height (will be updated later...)
        this.height_Ticklabels = 13; // can be double line
        this.width_measureAxisLabel = 35; // ..
        this.highlightRangeLimits_Active = false;
        // width for one aggregate - fixed width
        this.aggrWidth = 0;
        // ********************************************************************
        // DOM initializations
        // ********************************************************************
        this._initPos = null;
        this.zoomed = new Config({
            parent: this,
            cfgClass: "zoomed",
            cfgTitle: "ValueAxisZoom",
            default: false,
            UI: { disabled: true },
            iconClass: "far fa-search",
            helparticle: "5e87ea002c7d3a7e9aea606c",
            itemOptions: [
                { name: "Zoomed", value: true },
                { name: "Full", value: false },
            ],
            forcedValue: () => {
                if (!this.attrib.isFiltered())
                    return false;
            },
            onSet: (v) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                if (!this.attrib.aggr_initialized)
                    return;
                this.attrib.refreshValueScale();
                if (this.DOM.inited) {
                    this.DOM.summaryInterval.classed("zoomed", v);
                    this.DOM.zoomControl.attr("sign", v ? "minus" : "plus");
                }
                this.noRefreshVizAxis = true;
                var tempScale_prev = this.attrib.chartScale_Measure.copy().clamp(false);
                if (this.attrib.type !== "timestamp")
                    this.attrib.refreshScaleType(); // linear vs log
                this.attrib.updateScaleAndBins();
                this.refreshHeight();
                this.noRefreshVizAxis = false;
                this.attrib.chartScale_Measure_prev = tempScale_prev;
                this.refreshViz_Axis();
                yield ((_a = this.browser.recordDisplay) === null || _a === void 0 ? void 0 : _a.refreshAttribScaleType(this));
                this.attrib.updateScaleAndBins();
            }),
        });
        // ******************************************************
        // Interval Bin width
        this.optimumBinWidth = new Config({
            parent: this,
            cfgClass: "optimumBinWidth",
            cfgTitle: "BinWidth",
            UISeperator: {
                title: "Binning",
            },
            default: Base.width_HistBinDefault,
            iconClass: "fa fa-arrows-h",
            helparticle: "5e87e8952c7d3a7e9aea6065",
            itemOptions: [
                { name: "<i class='fa fa-minus'></i>", value: -99, _type: "minus" },
                { name: "1x", value: 45, max: 90 },
                { name: "2x", value: 90, max: 135 },
                { name: "3x", value: 135, max: 180 },
                { name: "4x", value: 180, max: 100000 },
                { name: "<i class='fa fa-plus'></i>", value: -199, _type: "plus" },
            ],
            isActive: (d) => d.value <= this.optimumBinWidth.get() && d.max > this.optimumBinWidth.get(),
            preSet: (v, obj) => __awaiter(this, void 0, void 0, function* () {
                if (v === -99) {
                    v = obj._value - 5;
                }
                else if (v === -199) {
                    v = obj._value + 5;
                }
                return Math.max(45, Math.min(180, v));
            }),
            onSet: () => this.attrib.updateScaleAndBins(),
        });
        // ******************************************************
        // Interval Bin height (linear / log)
        this.maxHeightRatio = new Config({
            parent: this,
            cfgClass: "maxHeightRatio",
            cfgTitle: "BinHeight",
            default: Base.height_MaxRatioDefault,
            UISeperator: {
                title: "Size",
            },
            iconClass: "fa fa-arrows-v",
            helparticle: "5e87e7502c7d3a7e9aea6060",
            itemOptions: [
                { name: "<i class='fa fa-minus'></i>", value: -99, _type: "minus" },
                { name: "1x", value: 0.15, max: 0.3 },
                { name: "2x", value: 0.3, max: 0.6 },
                { name: "4x", value: 0.6, max: 1.2 },
                { name: "8x", value: 1.2, max: 1.5 },
                { name: "10x", value: 1.5, max: 2.0 },
                { name: "<i class='fa fa-plus'></i>", value: -199, _type: "plus" },
            ],
            isActive: (d) => {
                var v = this.maxHeightRatio.get();
                if (this.attrib.type === "timestamp")
                    v *= 3;
                return d.value <= v && d.max > v;
            },
            // if timestamp, the returned value is divided by 3.
            onRead: (v) => (this.attrib.type === "timestamp" ? v / 3 : v),
            preSet: (v, obj) => __awaiter(this, void 0, void 0, function* () {
                if (v === -99) {
                    v = obj._value - 0.05;
                }
                else if (v === -199) {
                    v = obj._value + 0.05;
                }
                return Math.max(0.08, Math.min(1.5, v));
            }),
            onSet: () => {
                if (!this.attrib.aggr_initialized)
                    return;
                this.browser.updateLayout_Height();
            }
        });
        this.showHistogram = new Config({
            parent: this,
            cfgClass: "showHistogram",
            cfgTitle: "Histogram",
            iconClass: "fa fa-chart-bar",
            UISeperator: {
                title: "Charts",
            },
            default: true,
            itemOptions: [
                { name: "Show", value: true },
                { name: "Hide", value: false },
            ],
            onSet: (v) => {
                if (!attrib.aggr_initialized)
                    return; // not initialized yet
                if (!v)
                    this.height_hist = 0;
                this.refreshChartsVisibleOption();
                this.browser.updateLayout_Height();
            },
        });
        this.attrib.configs.zoomed = this.zoomed;
        this.attrib.configs.optimumBinWidth = this.optimumBinWidth;
        this.attrib.configs.maxHeightRatio = this.maxHeightRatio;
        this.attrib.configs.showHistogram = this.showHistogram;
    }
    get _aggrs() {
        return this.attrib._aggrs;
    }
    refreshIntervalSlider(t = undefined) {
        if (!this.DOM.intervalSlider)
            return;
        (t || Base.Active_Compare_List).forEach((cT) => {
            var _a, _b, _c, _d;
            var minPos, maxPos, visible;
            switch (cT) {
                case "Active":
                    // based on filtered range
                    visible = this.attrib.isFiltered();
                    minPos =
                        (_b = (_a = this.attrib.summaryFilter.active) === null || _a === void 0 ? void 0 : _a.minV) !== null && _b !== void 0 ? _b : this.attrib.rangeOrg[0];
                    maxPos =
                        (_d = (_c = this.attrib.summaryFilter.active) === null || _c === void 0 ? void 0 : _c.maxV) !== null && _d !== void 0 ? _d : this.attrib.rangeOrg[1];
                    break;
                default:
                    visible =
                        this.browser.vizActive(cT) && this.attrib.isComparedAttrib();
                    var aggr = this.browser.selectedAggrs[cT];
                    if (visible) {
                        minPos = aggr.minV;
                        maxPos = aggr.maxV;
                    }
                    break;
            }
            minPos = Math.max(this.valueScale.range()[0], this.valueScale(minPos));
            maxPos = Math.min(this.valueScale.range()[1], this.valueScale(maxPos));
            this.DOM.intervalSlider
                .select(".base_" + cT)
                .classed("visible", visible)
                .style("left", minPos + "px")
                .style("width", maxPos - minPos + "px");
            if (cT === "Active") {
                this.DOM.rangeHandle.style("transform", (d) => `translateX(${d === "min" ? minPos : maxPos}px)`);
            }
        });
    }
    // ********************************************************************
    // Height & width
    // ********************************************************************
    get height_hist_max() {
        return Math.max(Base.height_HistMin, this.width_histogram * this.maxHeightRatio.get()); // Maximim possible histogram height
    }
    get height_RangeMax() {
        if (this.attrib.isEmpty())
            return this.height_Header;
        return (this.height_Header +
            this.height_Extra_max +
            (this.showHistogram.get() ? this.height_hist_max : 0));
    }
    get height_RangeMin() {
        if (this.attrib.isEmpty())
            return this.height_Header;
        return 0 + this.height_Header + this.height_Extra_max;
    }
    get height_slider() {
        return 12;
    }
    get height_padding() {
        return 7;
    }
    get height_Extra_base() {
        return this.height_padding + this.height_slider + this.height_Ticklabels;
    }
    get height_Extra() {
        return (this.height_Extra_base +
            (this.showHistogram.get() ? Base.height_HistBottomGap : 0) +
            4); // 4 is some gap
    }
    get height_Extra_max() {
        return this.height_Extra_base + Base.height_HistBottomGap;
    }
    get height_Content() {
        return !this.isVisible()
            ? 0
            : (this.showHistogram.get() ? this.height_hist : 0) + this.height_Extra;
    }
    chartAxis_Measure_TickSkip() {
        return this.height_hist / 30;
    }
    setHeight(targetHeight) {
        if (!this._aggrs)
            return;
        var c = Math.min(this.height_hist_max, targetHeight - this.height_Header - this.height_Extra);
        if (this.height_hist === c)
            return;
        this.height_hist = c;
        this.attrib.updateChartScale_Measure(true);
    }
    refreshHeight() {
        super.refreshHeight();
        if (this.attrib.isEmpty() || !this.inDashboard || !this.DOM.inited)
            return;
        var _h = this.showHistogram.get() ? this.height_hist + 23 : 10;
        this.DOM.valueTickGroup.style("height", this.height_Ticklabels + "px");
        this.DOM.rangeHandle
            .style("height", _h + "px")
            .style("top", -_h + 10 + "px");
        this.DOM.highlightRangeLimits.style("height", this.height_hist + "px");
        this.DOM.histogram.style("height", this.height_hist + "px");
        this.DOM.root
            .select(".chartAxis_Measure > .measureDescrLabel")
            .style("width", this.height_hist + "px")
            .style("left", -this.height_hist / 2 + "px");
        this.refreshViz_Bins();
        this.updateValueTicks();
        this.refreshViz_All();
    }
    get width_marginLeft() {
        return this.width_measureAxisLabel + Base.width_measureDescrLabel;
    }
    get width_marginRight() {
        return this.width_measureAxisLabel * (this.isWideChart() ? 1 : 0.5) + 8;
    }
    get width_histogram() {
        if (!this.inDashboard)
            return 30;
        return Math.max(2, this.getWidth() - this.width_marginLeft - this.width_marginRight);
    }
    get width_Bin() {
        return this.aggrWidth - Base.width_HistBarGap * 2;
    }
    isWideChart() {
        return this.getWidth() > 500;
    }
    refreshWidth() {
        this.attrib.updateScaleAndBins(true); // forces render update
        if (this.DOM.inited === false)
            return;
        this.DOM.wrapper.classed("showMeasureAxis_2", this.isWideChart());
        this.DOM.summaryInterval
            .style("padding-left", this.width_marginLeft + "px")
            .style("padding-right", this.width_marginRight + "px");
        this.DOM.blockName.style("max-width", this.collapsed ? null : this.getWidth() - 40 + "px");
    }
    // ********************************************************************
    // Visualization
    // ********************************************************************
    insertVizDOM() {
        this.refreshViz_Bins();
        this.refreshViz_Axis();
        this.refreshMeasureLabelText("Active");
        this.updateValueTicks();
    }
    refreshViz_Bins() {
        if (!this.DOM.inited)
            return;
        var me = this;
        var baseline = this.measureLineZero;
        var _width = (aggr) => this.valueScale(aggr.maxV) -
            this.valueScale(aggr.minV) -
            Base.width_HistBarGap * 2;
        var _transform = (aggr) => `translateX(${this.valueScale(aggr.minV) + Base.width_HistBarGap}px)`;
        var updateVizBinWidth = (selection) => {
            Base.Total_Active_Compare_List.forEach((t) => {
                selection
                    .selectAll(".measure_" + t)
                    .style("transform", (aggr) => `translateY(${this.height_hist - baseline}px) scale(${_width(aggr)},0)`);
            });
        };
        this.DOM.aggrGlyphs = this.DOM.histogram_bins
            .selectAll(".aggrGlyph")
            .data(this._aggrs, (aggr) => [aggr.maxV, aggr.minV])
            .join((enter) => enter
            .append("span")
            .attr("class", "aggrGlyph rangeGlyph")
            .tooltip((aggr) => aggr.getTooltipHTML(), {
            theme: "dark kshf-tooltip kshf-record",
            placement: "bottom",
            animation: "fade",
            trigger: "manual",
        })
            .on("mouseenter", function (_event, aggr) {
            if (aggr.Active.recCnt === 0)
                return;
            if (me.highlightRangeLimits_Active)
                return;
            this.highlightTimeout = window.setTimeout(() => {
                me.onAggrHighlight(aggr);
                this.tippy.show();
            }, me.browser.movingMouseDelay);
        })
            .on("mouseleave", function (_event, aggr) {
            this.tippy.hide();
            if (aggr.Active.recCnt === 0)
                return;
            if (me.highlightRangeLimits_Active)
                return;
            if (this.highlightTimeout)
                window.clearTimeout(this.highlightTimeout);
            me.onAggrLeave(aggr);
        })
            .on("click", (event, aggr) => this.onAggrClick(event, aggr))
            .call((aggrGlyph) => {
            aggrGlyph
                .transition()
                .duration(0)
                .delay(10)
                .style("opacity", null)
                .style("pointer-events", null);
            var measureGroup = aggrGlyph
                .append("div")
                .attr("class", "measureGroup");
            Base.Total_Active_Compare_List.forEach((t) => {
                this.DOM["measure_" + t] = measureGroup
                    .append("span")
                    .attr("class", `measure_${t} bg_${t}`)
                    .on("mouseenter", (_event, aggr) => {
                    aggr.DOM.aggrGlyph
                        .querySelector(".measureLabel_" + t)
                        .classList.add("forceShow");
                    if (Base.Compare_List.find((_) => _ === t)) {
                        this.browser.refreshAllMeasureLabels(t);
                    }
                })
                    .on("mouseleave", (_event, aggr) => {
                    var labelDOM = aggr.DOM.aggrGlyph.querySelector(".measureLabel_" + t);
                    if (labelDOM)
                        labelDOM.classList.remove("forceShow");
                    if (Base.Compare_List.find((_) => _ === t)) {
                        this.browser.refreshAllMeasureLabels("Active");
                    }
                });
            });
            updateVizBinWidth(aggrGlyph);
            this.insertAggrLockButton(aggrGlyph, "top");
            aggrGlyph
                .append("span")
                .attr("class", "measureLabelGroup")
                .call((measureLabelGroup) => {
                Base.Active_Compare_List.forEach((t) => {
                    measureLabelGroup
                        .append("span")
                        .attr("class", "measureLabel measureLabel_" + t);
                });
            });
        }), (update) => update
            .style("width", (aggr) => _width(aggr) + "px")
            .style("transform", _transform)
            .call((update) => updateVizBinWidth(update)), (exit) => {
            if (this.noRefreshVizAxis && this.browser.finalized) {
                exit
                    .style("width", (aggr) => _width(aggr) + "px")
                    .style("transform", _transform)
                    .style("opacity", 0)
                    .style("pointer-events", "none")
                    .transition()
                    .duration(0)
                    .delay(700)
                    .remove();
                updateVizBinWidth(exit);
            }
            else {
                exit.remove();
            }
            return exit;
        })
            .call((merged) => {
            merged
                .style("width", (aggr) => _width(aggr) + "px")
                .style("transform", _transform);
            merged.each(function (aggr) {
                aggr.isVisible = true;
                aggr.setAggrGlyph(this);
            });
            Base.Total_Active_Compare_List.forEach((t) => {
                this.DOM["measure_" + t] = merged.selectAll(".measure_" + t);
            });
            this.DOM.lockButton = merged.selectAll(".lockButton");
            this.DOM.measureLabelGroup = merged.selectAll(".measureLabelGroup");
            Base.Active_Compare_List.forEach((t) => {
                this.DOM["measureLabel_" + t] = merged.selectAll(".measureLabel_" + t);
            });
        });
    }
    refreshViz_Active() {
        if (!this.isVisible() || !this.DOM.aggrGlyphs || !this.valueScale)
            return;
        var baseline = this.measureLineZero;
        this.DOM.aggrGlyphs.classed("NoActiveRecords", (aggr) => aggr.measure("Active") === 0);
        this.refreshViz_Cache("Active");
        // Position the lock button
        this.DOM.lockButton
            .style("transform", (aggr) => `translateY(${this.height_hist - baseline - aggr.sumOffsetScale("Active") - 10}px)`)
            .classed("inside", (aggr) => this.browser.relativeBreakdown ||
            Math.abs(this.height_hist - aggr.offset("Active") - aggr.scale("Active")) < 6);
        var maybePartial = this.attrib.isFiltered() &&
            !this.attrib.stepTicks &&
            this.attrib.summaryFilter.active &&
            this.attrib.type !== "timestamp";
        // Used for partial rendering
        let filter_min, filter_max, minPos, maxPos;
        if (maybePartial) {
            filter_min = this.attrib.summaryFilter.active.minV;
            filter_max = this.attrib.summaryFilter.active.maxV;
            minPos = this.valueScale(filter_min);
            maxPos = this.valueScale(filter_max);
        }
        this.DOM.measure_Active.style("transform", (aggr) => {
            var translateX = 0;
            var _w = this.width_Bin;
            if (maybePartial) {
                var aggr_min = aggr.minV;
                var aggr_max = aggr.maxV;
                // it is within the filtered range
                if (aggr_max > filter_min && aggr_min < filter_max) {
                    if (aggr_min < filter_min) {
                        var lostWidth = minPos - this.valueScale(aggr_min);
                        translateX = lostWidth;
                        _w -= lostWidth;
                    }
                    if (aggr_max > filter_max) {
                        _w -=
                            this.valueScale(aggr_max) - maxPos - Base.width_HistBarGap * 2;
                    }
                }
                else {
                    aggr.setScale("Active", 0);
                }
            }
            return `translate(${translateX}px, ${this.height_hist - baseline - aggr.offset("Active")}px) scale(${_w},${aggr.scale("Active")})`;
        });
        // doing position update after rendering the bar,
        // bc the active scale can be set to zero if the bar is outside filtering.
        this.refreshMeasureLabelText("Active");
        this.refreshMeasureLabelPos("Active");
    }
    refreshViz_Compare(cT, curGroup, totalGroups, prevCts = []) {
        if (!this.isVisible() || !this.DOM.aggrGlyphs || !this.valueScale)
            return;
        this.refreshViz_Cache(cT, prevCts);
        this.refreshMeasureLabelText(cT);
        this.refreshMeasureLabelPos(cT, curGroup);
    }
    refreshMeasureLabelPos(sT = "Active", curGroup = 0) {
        if (!this.isVisible() || !this.DOM.aggrGlyphs || !this.valueScale)
            return;
        if (sT === "Other")
            return;
        if (this.browser.stackedChart) {
            this.DOM["measureLabel_" + sT]
                .classed("hidden", (aggr) => aggr.scale(sT) < 16 || this.browser.getMeasureValue(aggr, sT) == 0)
                .style("width", "100%")
                .style("transform", (aggr, i, nodes) => {
                nodes[i].setAttribute("labelAlign", "middle");
                return `translate(0px, ${-aggr[sT].offset - aggr[sT].scale / 2}px)`;
            });
        }
        else {
            if (this.attrib.type === "timestamp" &&
                (sT !== "Active" || this.browser.activeComparisonsCount > 0)) {
                // Line chart
                // _spacer is needed to detect intersecting labels and prevent overlaps
                // cannot use LabelSpacer because this needs to maintain which selections are visible, etc.
                this._aggrs.forEach((_) => {
                    _._spacer = _._spacer || {};
                });
                var visibleStuff = ["Active"]
                    .concat(this.browser.activeComparisons)
                    .filter((_) => _ !== sT);
                this.DOM["measureLabel_" + sT].style("transform", (aggr, i, nodes) => {
                    var v = aggr.offset(sT) + aggr.scale(sT);
                    if (sT === "Active") {
                        v += 20; // 20 pixel up
                    }
                    // 5px: just extra offset to avoid intersecting with line
                    v = 5 - Math.min(v, this.height_hist);
                    aggr._spacer[sT] = { min: v - 5, max: v + 20 };
                    var intersects = visibleStuff.some((s) => {
                        var l = aggr._spacer[s];
                        return l ? l.min <= v && l.max >= v : false;
                    });
                    // the visibility (hidden class) of label depends on all other labels on the same aggregate
                    nodes[i].classList[intersects ? "add" : "remove"]("hidden");
                    return `translate(0px, ${v}px)`;
                });
            }
            else {
                var totalGroups = this.browser.activeComparisonsCount;
                var width = 100;
                var tX = 0;
                var hidden = false;
                if ((sT !== "Active" && sT !== "Total") &&
                    totalGroups > 1 &&
                    this.browser.vizActive(sT)) {
                    var realWidth = this.width_Bin / totalGroups;
                    tX = realWidth * curGroup;
                    width = 100 / totalGroups;
                    hidden = realWidth < this.panel.width_CatMeasureLabel;
                }
                this.DOM["measureLabel_" + sT]
                    .classed("hidden", this.attrib.type !== "timestamp" && hidden)
                    .style("transform", `translate(${tX}px, 2px)`)
                    .style("width", `${width}%`);
            }
        }
    }
    // ********************************************************************
    // Show record value
    // ********************************************************************
    updateAfterFilter() {
        if (!this.isVisible())
            return;
        this.attrib.updateChartScale_Measure();
        this.refreshMeasureLabelText("Active");
        this.refreshViz_NoValueAggr();
    }
    showRecordValue(record) {
        if (!this.inDashboard || !this.DOM.inited || !this.valueScale)
            return;
        var v = this.attrib.getRecordValue(record);
        if (v == null)
            return;
        if (v < this.valueScale.domain()[0])
            return;
        if (v > this.valueScale.domain()[1])
            return;
        this.DOM.recordValue
            .style("transform", "translateX(" + this.attrib.getValuePosX(v) + "px)")
            .style("display", "block");
        this.DOM.recordValueText.html(this.attrib.getFormattedValue(v, false));
    }
    hideRecordValue() {
        if (!this.DOM.inited || !this.DOM.recordValue)
            return;
        this.DOM.recordValue.style("display", null);
    }
    initDOM(beforeDOM) {
        this.attrib.initializeAggregates();
        if (this.attrib.isEmpty())
            return false;
        if (this.DOM.inited)
            return true;
        this.insertRoot(beforeDOM);
        this.DOM.summaryInterval = this.DOM.wrapper
            .append("div")
            .attr("class", "summaryInterval")
            .on("mousedown", (event) => {
            event.stopPropagation();
            event.preventDefault();
        });
        var _flexClear = (event) => {
            this._initPos = undefined;
            this.highlightRangeLimits_Active = false;
            event.preventDefault();
            event.stopPropagation();
        };
        this.DOM.histogram = this.DOM.summaryInterval
            .append("div")
            .attr("class", "histogram");
        this.DOM.histogram_bins = this.DOM.histogram
            .append("div")
            .attr("class", "aggrGroup")
            .on("mousemove", (event) => {
            if (!event.shiftKey) {
                if (this.highlightRangeLimits_Active) {
                    this.browser.clearSelect_Compare();
                    _flexClear(event);
                }
                return;
            }
            // dynamically select... range by mouse-move
            var pointerPosition = this.valueScale.invert(d3$k.pointer(event)[0]);
            if (this._initPos == null) {
                this._initPos = pointerPosition;
            }
            var [minV, maxV] = d3$k.extent([this._initPos, pointerPosition]);
            [minV, maxV] = this.attrib.sanitizeRange(minV, maxV);
            if (minV === maxV)
                return; // no selection!
            this.highlightRangeLimits_Active = true;
            if (this.browser.vizActive(this.browser.Compare_Highlight)) {
                this.browser.clearSelect_Compare(this.browser.Compare_Highlight, false);
            }
            var aggr = this.attrib.createAggregate(minV, maxV);
            aggr.updateRecords();
            this.browser.allRecordsAggr.clearCompare(this.browser.Compare_Highlight);
            this.browser.setSelect_Compare(aggr);
            event.preventDefault();
            event.stopPropagation();
        })
            .on("click", (event) => {
            if (event.shiftKey && this.highlightRangeLimits_Active) {
                this.browser.lockSelect_Compare();
                _flexClear(event);
            }
        });
        this.DOM.highlightRangeLimits = this.DOM.histogram_bins
            .selectAll(".highlightRangeLimits")
            .data([0, 1])
            .enter()
            .append("div")
            .attr("class", "highlightRangeLimits");
        this.insertChartAxis_Measure(this.DOM.histogram);
        this.initDOM_Slider();
        this.insertVizDOM();
        this.setCollapsed(this.collapsed);
        this.DOM.inited = true;
        this.refreshChartsVisibleOption();
        return true;
    }
    initDOM_Slider() {
        var me = this;
        this.DOM.intervalSlider = this.DOM.summaryInterval
            .append("div")
            .attr("class", "intervalSlider");
        this.DOM.zoomControl = this.DOM.intervalSlider
            .append("span")
            .attr("class", "zoomControl far")
            .tooltip("", {
            onTrigger: (instance) => {
                var zoomIn = instance.reference.getAttribute("sign") === "plus";
                instance.reference.tippy.setContent(zoomIn ? "Zoom into filtered range" : "Zoom out");
            },
        })
            .attr("sign", this.zoomed.is(true) ? "minus" : "plus")
            .on("click", (event) => __awaiter(this, void 0, void 0, function* () {
            yield this.zoomed.set(event.currentTarget.getAttribute("sign") === "plus");
        }));
        var controlLine = this.DOM.intervalSlider
            .append("div")
            .attr("class", "controlLine")
            .on("mousedown", function (event) {
            if (event.which !== 1)
                return; // only respond to left-click
            me.browser.DOM.root
                .classed("adjustingWidth", true)
                .classed("noPointerEvents", true);
            var e = this.parentNode;
            var initPos = me.valueScale.invert(d3$k.pointer(event, e)[0]);
            d3$k.select("body")
                .on("mousemove", function (event2) {
                var targetPos = me.valueScale.invert(d3$k.pointer(event2, e)[0]);
                me.browser.preventAxisScaleTransition = true;
                me.attrib.setRangeFilter_Custom(d3$k.min([initPos, targetPos]), d3$k.max([initPos, targetPos]));
            })
                .on("mouseup", function () {
                me.browser.preventAxisScaleTransition = false;
                me.browser.DOM.root
                    .classed("adjustingWidth", false)
                    .classed("noPointerEvents", false);
                d3$k.select("body").on("mousemove", null).on("mouseup", null);
            });
            event.preventDefault();
        });
        this.DOM.activeTotalRange = controlLine
            .append("span")
            .attr("class", "base base_Total");
        controlLine
            .append("span")
            .attr("class", "base base_Active")
            .tooltip(i18n.DragToFilter, { placement: "bottom" })
            .on("mousedown", function (event) {
            if (event.which !== 1)
                return; // only respond to left-click
            // time is not supported for now.
            // if (me instanceof Summary_Timestamp) return;
            if (me.attrib.type === "timestamp")
                return;
            me.browser.DOM.root.classed("noPointerEvents", true);
            var e = this.parentNode;
            var initMin = me.attrib.summaryFilter.active.minV;
            var initMax = me.attrib.summaryFilter.active.maxV;
            var initPos = d3$k.pointer(event, e)[0];
            d3$k.select("body")
                .on("mousemove", () => {
                me.browser.preventAxisScaleTransition = true;
                me.dragRange(initPos, d3$k.pointer(event, e)[0], initMin, initMax);
            })
                .on("mouseup", () => {
                me.browser.preventAxisScaleTransition = false;
                me.browser.DOM.root.classed("noPointerEvents", false);
                d3$k.select("body").on("mousemove", null).on("mouseup", null);
            });
            event.preventDefault();
            event.stopPropagation();
        });
        Base.Compare_List.forEach((cT) => {
            controlLine
                .append("span")
                .attr("class", "base base_Compare bg_" + cT)
                .tooltip(i18n.DragToFilter, { placement: "bottom" });
        });
        this.DOM.rangeHandle = controlLine
            .selectAll(".rangeHandle")
            .data(["min", "max"])
            .enter()
            .append("span")
            .attr("class", (d) => "rangeHandle " + d)
            .tooltip(i18n.DragToFilter)
            .on("mouseenter", function () {
            if (this.dragging)
                return;
            this.tippy.show();
            this.classList.add("dragging");
        })
            .on("mouseleave", function () {
            if (this.dragging)
                return;
            this.tippy.hide();
            this.classList.remove("dragging");
        })
            .on("dblclick", function (_event, d) {
            me.showValuePicker(this, d);
        })
            .on("mousedown", function (event, d) {
            if (event.which !== 1)
                return; // only respond to left-click
            me.browser.DOM.root
                .classed("adjustingWidth", true)
                .classed("noPointerEvents", true);
            this.classList.add("dragging");
            var mee = this;
            mee.dragging = true;
            var e = this.parentNode;
            ({
                min: me.attrib.summaryFilter.active.minV,
                max: me.attrib.summaryFilter.active.maxV,
            });
            d3$k.select("body")
                .on("mousemove.range", function (event2) {
                me.valueScale.invert(d3$k.pointer(event2, e)[0]);
                me.browser.preventAxisScaleTransition = true;
            })
                .on("mouseup.range", function () {
                delete me.browser.preventAxisScaleTransition;
                mee.dragging = false;
                mee.classList.remove("dragging");
                me.browser.DOM.root
                    .classed("adjustingWidth", null)
                    .classed("noPointerEvents", false);
                d3$k.select("body")
                    .style("cursor", "auto")
                    .on("mousemove.range", null)
                    .on("mouseup.range", null);
            });
            event.stopPropagation();
        });
        this.DOM.recordValue = controlLine
            .append("div")
            .attr("class", "recordValue");
        this.DOM.recordValue.append("span").attr("class", "valueScaleMark");
        this.DOM.recordValueText = this.DOM.recordValue
            .append("span")
            .attr("class", "recordValueText")
            .append("span")
            .attr("class", "recordValueText-v");
        this.DOM.valueTickGroup = this.DOM.intervalSlider
            .append("div")
            .attr("class", "valueTickGroup");
    }
    onAggrHighlight(aggr) {
        var _a;
        if (this.browser.adjustMode)
            return;
        if (this.browser.mouseOverCompare.is(false))
            return;
        if (!this.browser.can_setSelect_Compare(aggr))
            return;
        var [minV, maxV] = this.attrib.sanitizeRange(aggr.minV, aggr.maxV);
        if (minV === maxV)
            return; // no selection!
        if (!this.attrib.binMatch([minV, maxV, null], aggr)) {
            aggr.updateRecords();
        }
        (_a = aggr.DOM.aggrGlyph) === null || _a === void 0 ? void 0 : _a.setAttribute("selection", "selected");
        this.browser.setSelect_Compare(aggr);
    }
    onAggrLeave(aggr) {
        if (this.browser.adjustMode)
            return;
        aggr.unselectAggregate();
        this.browser.clearSelect_Compare();
    }
    onAggrClick(event, aggr) {
        if (this.highlightRangeLimits_Active)
            return;
        if (event && event.shiftKey) {
            this.browser.lockSelect_Compare();
            return;
        }
        this.attrib.setRangeFilter(aggr);
    }
    refreshValueTickLabels() {
        var _a;
        (_a = this.DOM.valueTickGroup) === null || _a === void 0 ? void 0 : _a.selectAll(".valueTick > .text").html((tick) => this.attrib.printAbbr(tick.tickValue, false));
    }
    refreshChartsVisibleOption() {
        if (!this.DOM.inited)
            return;
        this.DOM.root.classed("chartVisibleHistogram", this.showHistogram.is(true));
    }
    onClearFilter() {
        this.attrib.noValueAggr.filtered = false;
        this.attrib.summaryFilter.active = null;
        this.zoomed.set(false);
        this.refreshIntervalSlider();
    }
    // extended by Block_Numeric to add minor ticks when using log scale
    insertMinorTicks(ticks) { }
    updateValueTicks() {
        var me = this;
        // create ticks used in the value scale / interval range slider
        var ticksOrg = this.attrib.intervalTicks.slice();
        if (this.attrib.stepTicks)
            ticksOrg.pop(); // won't insert last tick here
        let ticks = ticksOrg.map((p) => ({ tickValue: p, major: true }));
        this.insertMinorTicks(ticks);
        var finalPos = (d) => this.valueScale(d.tickValue) + "px";
        if (!this.browser.chartsLoaded)
            ;
        this.DOM.valueTickGroup
            .selectAll(".valueTick")
            .data(ticks, (t) => t.tickValue)
            .join((enter) => enter
            .append("span")
            .attr("class", "valueTick")
            .style("opacity", 1)
            .style("left", finalPos)
            .style("top", "20px")
            .call((valueTicks) => {
            valueTicks.append("span").attr("class", "line");
            valueTicks
                .append("span")
                .attr("class", "text")
                .on("mouseover", function () {
                if (this.bin)
                    me.onAggrHighlight(this.bin);
            })
                .on("mouseleave", function () {
                if (this.bin)
                    me.onAggrLeave(this.bin);
            })
                .on("click", function (event) {
                if (this.bin)
                    me.onAggrClick(event, this.bin);
            });
        }), 
        // .call((valueTicks) => {
        //   window.setTimeout(() => {
        //     valueTicks
        //       .style("pointer-events", null)
        //       .style("opacity", 1)
        //       .style("left", finalPos);
        //   }, 0);
        // })
        (update) => update, (exit) => {
            if (!this.browser.chartsLoaded) {
                exit.remove();
            }
            else {
                exit
                    .style("left", finalPos)
                    .style("opacity", 0)
                    .transition()
                    .duration(0)
                    .delay(600)
                    .remove();
            }
        })
            .classed("major", (tick) => tick.major)
            .style("left", finalPos)
            .call((valueTicks) => {
            valueTicks.transition().duration(500).delay(5).style("top", "0px");
            //.style("left", finalPos);
            valueTicks.selectAll(".text").each(function (d) {
                this.bin = null;
                var v = +d.tickValue;
                me._aggrs.some((bin) => {
                    if (+bin.minV - v)
                        return false;
                    this.bin = bin;
                    return true;
                });
            });
        });
        this.refreshValueTickLabels();
        this.DOM.valueTickGroup.style("left", (this.attrib.stepTicks ? this.aggrWidth / 2 : 0) + "px");
    }
}

const d3$j = { select, quantile };
class Block_Numeric extends Block_Interval {
    constructor(attrib) {
        super(attrib);
        // ********************************************************************
        // Percentile chart
        // ********************************************************************
        // Percentile chart stuff
        this.quantile_val = {};
        this.showPercentiles = new Config({
            cfgClass: "showPercentiles",
            cfgTitle: "Percentiles",
            iconClass: "percentileBlocks",
            default: false,
            parent: this,
            itemOptions: [
                { name: "Show", value: true },
                { name: "Hide", value: false },
            ],
            onDOM: (DOM) => {
                DOM.root
                    .select(".percentileBlocks")
                    .classed("percentileChart_Active", true)
                    .selectAll(".block")
                    .data([1, 4, 4, 3, 2, 1])
                    .enter()
                    .append("i")
                    .attr("class", (_) => "percentileBlock qG" + _);
            },
            onSet: () => {
                if (!this.DOM.inited)
                    return;
                var curHeight = this.getHeight();
                this.refreshChartsVisibleOption();
                this.updatePercentiles();
                this.setHeight(curHeight);
                this.browser.updateLayout_Height();
            },
        });
        this.attrib.configs.showPercentiles = this.showPercentiles;
    }
    /** -- */
    get height_Percentile() {
        return this.showPercentiles.is(true) ? Base.height_Percentile : 0;
    }
    /** -- */
    get height_Extra_base() {
        return super.height_Extra_base + this.height_Percentile;
    }
    /** - */
    refreshWidth() {
        this.attrib.refreshScaleType();
        super.refreshWidth();
    }
    getScaleNicing() {
        if (!this.inDashboard) {
            return this.width_histogram / 10;
        }
        var v = this.optimumBinWidth.get();
        if (this.attrib.unitName) {
            v += (v * (2 + this.attrib.unitName.length * 8)) / 45;
        }
        return this.width_histogram / v;
    }
    dragRange(initPos, curPos, initMin, initMax) {
        var targetDif;
        var r = {
            min: undefined,
            max: undefined,
        };
        if (this.attrib.isValueScale_Log) {
            targetDif = curPos - initPos;
            r.min = this.valueScale.invert(this.valueScale(initMin) + targetDif);
            r.max = this.valueScale.invert(this.valueScale(initMax) + targetDif);
            //
        }
        else if (this.attrib.isValueScale_Linear) {
            targetDif =
                this.valueScale.invert(curPos) - this.valueScale.invert(initPos);
            if (!this.attrib.hasFloat)
                targetDif = Math.round(targetDif);
            r.min = initMin + targetDif;
            r.max = initMax + targetDif;
            var diff = initMax - initMin;
            var currentLimit = this.attrib.valueScale.domain();
            // Limit the active filter to expand beyond the current min/max of the view.
            if (r.min < currentLimit[0]) {
                r.min = currentLimit[0];
                r.max = currentLimit[0] + diff;
            }
            if (r.max > currentLimit[1]) {
                r.max = currentLimit[1];
                r.min = currentLimit[1] - diff;
            }
        }
        this.attrib.setRangeFilter_Custom(r.min, r.max);
    }
    /** -- */
    showValuePicker(DOM, d) {
        var pikanum = DOM.pikanum;
        if (!pikanum) {
            DOM.pikanum = pikanum = d3$j
                .select(DOM)
                .append("input")
                .attr("class", "rangeInput")
                .attr("type", "number")
                .attr("min", this.attrib.rangeOrg[0])
                .attr("max", this.attrib.rangeOrg[1])
                .on("blur", function () {
                pikanum.style("display", "none");
            })
                .on("focusout", function () {
                pikanum.style("display", "none");
            })
                .on("keydown", function (event) {
                if (event.keyCode === 27) {
                    // Escape key
                    pikanum.node().blur();
                }
            })
                .on("change", () => {
                var v = 1 * pikanum.node().value;
                var minV = this.attrib.summaryFilter.active.minV;
                var maxV = this.attrib.summaryFilter.active.minV;
                if (d === "min")
                    minV = v;
                if (d === "max")
                    maxV = v;
                this.attrib.setRangeFilter_Custom(minV, maxV);
                pikanum.node().blur();
            });
        }
        pikanum.attr("step", 1).style("display", "block");
        pikanum.node().focus();
        pikanum.node().value = this.attrib.summaryFilter.active[d];
    }
    zoomableStatus() {
        if (this.attrib.stepTicks) {
            return this.zoomed.is(true) ? "minus" : "";
        }
        return "plus";
    }
    hasStaticHeight() {
        return this.showHistogram.is(false);
    }
    /** -- */
    initDOM(beforeDOM) {
        if (!super.initDOM(beforeDOM))
            return false;
        this.initDOM_Percentile();
        return true;
    }
    refreshChartsVisibleOption() {
        if (!this.DOM.inited)
            return;
        super.refreshChartsVisibleOption();
        this.DOM.root.classed("chartVisiblePercentile", this.showPercentiles.is(true));
    }
    insertMinorTicks(ticks) {
        if (this.attrib.isValueScale_Log) {
            Util.insertMinorTicks(this.attrib.intervalTicks, this.valueScale, ticks);
        }
    }
    /** - */
    updateAfterFilter() {
        if (!this.isVisible())
            return;
        super.updateAfterFilter();
        this.updatePercentiles();
    }
    refreshViz_Active() {
        super.refreshViz_Active();
        this.updatePercentiles("Active");
    }
    /** - */
    refreshViz_Compare(cT, curGroup, totalGroups, prevCts = []) {
        if (!this.isVisible() || !this.DOM.aggrGlyphs)
            return;
        super.refreshViz_Compare(cT, curGroup, totalGroups, prevCts);
        var baseline = this.measureLineZero;
        var maybePartial = this.attrib.isFiltered() && this.attrib.summaryFilter.active && !this.attrib.stepTicks;
        // used in partial rendering
        let filter_min, filter_max, minPos, maxPos;
        if (maybePartial) {
            filter_min = this.attrib.summaryFilter.active.minV;
            filter_max = this.attrib.summaryFilter.active.maxV;
            minPos = this.valueScale(filter_min);
            maxPos = this.valueScale(filter_max);
        }
        var _do = (withScale) => {
            this.DOM["measure_" + cT].style("transform", (aggr) => {
                let _w = this.width_Bin;
                let _translateX = 0;
                if (maybePartial) {
                    // it is within the filtered range
                    if (aggr.maxV > filter_min && aggr.minV < filter_max) {
                        if (aggr.minV < filter_min) {
                            var lostWidth = minPos - this.valueScale(aggr.minV);
                            _translateX = lostWidth;
                            _w -= lostWidth;
                        }
                        if (aggr.maxV > filter_max) {
                            _w -=
                                this.valueScale(aggr.maxV) -
                                    maxPos -
                                    Base.width_HistBarGap * 2;
                        }
                    }
                    else {
                        aggr.setScale(cT, 0);
                    }
                }
                if (!this.attrib.stackedCompare) {
                    _w = _w / totalGroups;
                    _translateX = _w * curGroup;
                }
                return `translate(${_translateX}px, ${this.height_hist - baseline - aggr.offset(cT)}px) scale(${_w}, ${withScale ? aggr.scale(cT) : 0})`;
            });
        };
        if (curGroup === totalGroups - 1 && this.browser.addedCompare) {
            _do(false);
        }
        _do(true);
        this.updatePercentiles(cT);
    }
    /** -- */
    initDOM_Percentile() {
        if (!this.DOM.summaryInterval || this.DOM.percentileGroup)
            return;
        var me = this;
        this.DOM.percentileGroup = this.DOM.summaryInterval
            .append("div")
            .attr("class", "percentileGroup");
        this.DOM.percentileGroup
            .append("span")
            .attr("class", "percentileTitle")
            .html(i18n.Percentiles);
        Base.Compare_List
            .concat("Active")
            .forEach((sT) => {
            var parent = me.DOM.percentileGroup
                .append("div")
                .attr("class", "percentileChart_" + sT);
            parent
                .selectAll(".aggrGlyph")
                .data([
                [10, 20, 1],
                [20, 30, 2],
                [30, 40, 3],
                [40, 50, 4],
                [50, 60, 4],
                [60, 70, 3],
                [70, 80, 2],
                [80, 90, 1],
            ])
                .enter()
                .append("span")
                .attr("class", (qb) => "quantile aggrGlyph q_range qG" + qb[2])
                .each(function () {
                this.__data__.summary = me;
            })
                .tooltip((qb) => `<div><span style='font-weight:400'>${qb[0]}% - ${qb[1]}%</span> Percentile:</div><div style='font-weight: 500'>${me.attrib.printAbbr(me.quantile_val[sT + qb[0]])} - ${me.attrib.printAbbr(me.quantile_val[sT + qb[1]])}</div>`, { placement: "top" })
                .on("mouseover", (_event, qb) => {
                if (this.browser.comparedAttrib && !this.attrib.isComparedAttrib())
                    return;
                if (this.browser.mouseOverCompare.is(false))
                    return;
                this.highlightRangeLimits_Active = true;
                var aggr = this.attrib.createAggregate(this.quantile_val[sT + qb[0]], this.quantile_val[sT + qb[1]]);
                aggr.updateRecords();
                this.browser.allRecordsAggr.clearCompare(this.browser.Compare_Highlight);
                this.browser.setSelect_Compare(aggr);
            })
                .on("mouseout", () => {
                if (this.browser.comparedAttrib && !this.attrib.isComparedAttrib())
                    return;
                this.browser.clearSelect_Compare();
                this.highlightRangeLimits_Active = false;
            })
                .on("click", (event, qb) => {
                if (event.shiftKey) {
                    this.browser.clearSelect_Compare(null, true, true);
                    this.highlightRangeLimits_Active = false;
                    return;
                }
                this.attrib.summaryFilter.active = this.attrib.createAggregate(this.quantile_val[sT + qb[0]], this.quantile_val[sT + qb[1]]);
                this.attrib.summaryFilter.setFiltered();
            });
            parent
                .selectAll(".q_pos")
                .data([50])
                .enter()
                .append("span")
                .attr("class", (q) => "quantile q_pos q_" + q)
                .tooltip((q) => `<u>Median</u><br><b>${me.attrib.getFormattedValue(me.quantile_val[sT + q])}</b>`, { placement: "top" });
        });
        this.refreshChartsVisibleOption();
    }
    /** - */
    refreshViz_Percentiles(distr) {
        if (!this.DOM.percentileGroup)
            return;
        if (!this.valueScale)
            return;
        if (this.showPercentiles.is(false))
            return;
        var percentileChart = this.DOM.percentileGroup.select(".percentileChart_" + distr);
        percentileChart
            .style("margin-left", "0px")
            .style("opacity", (q) => this.quantile_val[distr + "10"] == null ? 0 : 1)
            .style("transform", this.attrib.stepTicks
            ? "translateX(" + this.aggrWidth / 2 + "px)"
            : null);
        percentileChart
            .selectAll(".q_pos")
            .style("transform", (q) => "translateX(" + this.valueScale(this.quantile_val[distr + q]) + "px)");
        percentileChart
            .selectAll(".quantile.aggrGlyph")
            .style("transform", (qb) => {
            var pos_1 = this.valueScale(this.quantile_val[distr + qb[0]]);
            var pos_2 = this.valueScale(this.quantile_val[distr + qb[1]]);
            return `translateX(${pos_1}px) scaleX(${pos_2 - pos_1})`;
        });
    }
    updatePercentiles(sT = null) {
        if (sT === "Other")
            return;
        if (this.showPercentiles.is(false))
            return;
        if (!sT) {
            this.browser.activeComparisons.forEach((t) => this.updatePercentiles(t));
            this.updatePercentiles("Active");
            return;
        }
        if (sT === "Total")
            return; // no total-vis for percentiles
        if (sT !== "Active") {
            if (!this.attrib.vizActive(sT))
                return;
        }
        // the items are already sorted by their numeric value, it's just a linear pass.
        var values = this.attrib.sortedRecords
            .filter(sT === "Active"
            ? (record) => record.isIncluded
            : (record) => record.isIncluded && record.isSelected(sT))
            .map((record) => this.attrib.getRecordValue(record));
        [10, 20, 30, 40, 50, 60, 70, 80, 90].forEach((q) => {
            this.quantile_val[sT + q] = d3$j.quantile(values, q / 100);
        });
        this.refreshViz_Percentiles(sT);
    }
}

const d3$i = { format, deviation };
class Attrib_Numeric extends Attrib_Interval {
    get block() {
        return this._block;
    }
    hasTimeSeriesParent() {
        var _a;
        return ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.type) === "timeseries";
    }
    get timeseriesParent() {
        var _a;
        return ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.type) === "timeseries"
            ? this.parent
            : null;
    }
    // specialized method to consider/change behavior if with timeseries parent
    get groupPath() {
        var _a;
        return ((_a = this.timeseriesParent) === null || _a === void 0 ? void 0 : _a.attribName.split("->")) || this.pathName;
    }
    constructor(browser, name, template) {
        super(browser, name, template, "numeric", "kshfSummary_Numeric", "far fa-hashtag");
        // has floating numbers as data points
        this.tickPrecision = 3;
        this.autoScaleType = null;
        // if parent is timeseries, timeKey shows which time we are about...
        this.timeKey = null;
        this.skipZero = false;
        this._block = new Block_Numeric(this);
        this.measurable = {
            metricFuncs: Base.defaultMetricFuncs,
        };
        this.valueScaleType = new Config({
            cfgClass: "valueScaleType",
            cfgTitle: "BinScale",
            iconClass: "fa fa-arrows-h",
            parent: this,
            default: "auto",
            helparticle: "5e87eabc04286364bc97d0cf",
            itemOptions: [
                { name: "Auto", value: "auto" },
                { name: i18n.Linear + " " + i18n.LinearSequence, value: "linear" },
                { name: i18n.Log + " " + i18n.Log2Sequence, value: "log" },
            ],
            forcedValue: () => {
                if (this.timeseriesParent)
                    return this.timeseriesParent.valueScaleType.get();
                if (this.stepTicks)
                    return "linear";
                if (!this.supportsLogScale())
                    return "linear";
                if (this.valueScaleType._value === "auto")
                    return this.autoScaleType;
            },
            onSet: () => __awaiter(this, void 0, void 0, function* () {
                var _a;
                if (!this.aggr_initialized)
                    return;
                this.block.noRefreshVizAxis = true;
                yield this.applyScaleType();
                this.block.noRefreshVizAxis = false;
                yield ((_a = this.browser.recordDisplay) === null || _a === void 0 ? void 0 : _a.refreshAttribScaleType(this));
            }),
        });
        this.finishTemplateSpecial();
        // TODO: maintain good order for UI, delete showHistogram index and add it at appropriate position
    }
    createAggregate(minV, maxV) {
        return new Aggregate_Interval_Numeric(this, minV, maxV);
    }
    // ********************************************************************
    // Range and Scale...
    // ********************************************************************
    get isValueScale_Log() {
        return this.valueScaleType.is("log");
    }
    get isValueScale_Linear() {
        return this.valueScaleType.is("linear");
    }
    supportsLogScale() {
        return !this.hasNegativeValues();
    }
    sanitizeRange(minV, maxV) {
        if (!this.hasFloat) {
            maxV = Math.round(maxV);
            minV = Math.round(minV);
        }
        return super.sanitizeRange(minV, maxV);
    }
    getRecordValueExtent() {
        var _a;
        if (this.valueDomain) {
            return [...this.valueDomain];
        }
        if ((_a = this.timeseriesParent) === null || _a === void 0 ? void 0 : _a.valueDomain) {
            return [...this.timeseriesParent.valueDomain];
        }
        return super.getRecordValueExtent();
    }
    get hasFloat() {
        return this._hasFloat;
    }
    /** -- */
    fillValueCache() {
        this._hasFloat = false;
        this.records.forEach((record) => {
            var v = this.template.func.call(record.data, record);
            if (v === undefined)
                v = null;
            if (isNaN(v))
                v = null;
            if (v === 0 && this.skipZero)
                v = null;
            if (v !== null) {
                if (typeof v !== "number") {
                    v = null;
                }
                else {
                    this._hasFloat = this._hasFloat || v % 1 !== 0;
                }
            }
            record.setValue(this, v);
            if (v == null) {
                this.noValueAggr.addRecord(record);
            }
        });
    }
    /** -- */
    pofffff() {
        this.refreshScaleType();
    }
    // Also a method of Timeseries
    hasNegativeValues() {
        if (!this.aggr_initialized)
            return true; // unknown, assume it can have negative
        return this.rangeOrg[0] < 0;
    }
    /** -- */
    supportsRecordEncoding(_type) {
        if (this.isEmpty())
            return false;
        if (["text", "textBrief"].includes(_type))
            return true;
        this.initializeAggregates();
        if (!this.isComparable.get())
            return false;
        if (["sort", "scatterX", "scatterY", "color"].includes(_type))
            return true;
        if (_type === "size") {
            return !this.hasNegativeValues();
        }
        return false;
    }
    /** -- */
    get canHaveMetricFuncs() {
        if (this.isIDAttrib())
            return false;
        if (!this.aggr_initialized)
            return false;
        return true;
    }
    /** -- */
    get supportedMetricFuncs() {
        return this.canHaveMetricFuncs ? this._metricFuncs : [];
    }
    /** -- */
    getTickPrecision() {
        var _a, _b;
        return (_b = (_a = this.timeseriesParent) === null || _a === void 0 ? void 0 : _a.tickPrecision) !== null && _b !== void 0 ? _b : this.tickPrecision;
    }
    updateTickPrintFunc() {
        var t = d3$i.format("." + this.getTickPrecision() + "~s");
        if (this.getTickPrecision() === 0) {
            t = d3$i.format("~s");
        }
        this.intervalTickPrint = (v) => {
            if (!this.hasFloat)
                v = Math.round(v);
            let r = t(v);
            let _r = v.toLocaleString();
            // if value is 1021 and summary doesn't have float, formatted value returns "1,021k" - Stupid!
            if (_r.length <= r.length)
                return _r;
            if (r.substr(-1) === "m") {
                let v = parseFloat(r) / 1000;
                v = Math.round((v + 0.000001) * 1000) / 1000;
                r = v.toString();
            }
            return r;
        };
        if (this.stepTicks) {
            this.intervalTickPrint = d3$i.format("d");
        }
    }
    refreshValueScale() {
        super.refreshValueScale();
        if (!this.hasFloat) {
            this.intervalTicks = this.intervalTicks.filter((tick) => tick % 1 === 0);
        }
    }
    /** -- */
    isPercentageUnit() {
        if (this.unitName !== "%")
            return false;
        if (this.hasNegativeValues())
            return false;
        if (this.rangeOrg[1] > 100)
            return false;
        return true;
    }
    /** -- */
    refreshScaleType() {
        if (this.isEmpty())
            return;
        this.setStepTicks(false);
        if (this.timeseriesParent) {
            this.timeseriesParent.initializeAggregates();
            return;
        }
        var domain = this.valueScale.domain();
        // decide scale type based on the filtered records
        var deviation = d3$i.deviation(this.sortedRecords, (record) => {
            var v = this.getRecordValue(record);
            if (v == null)
                return undefined;
            if (v >= domain[0] && v <= domain[1])
                return v;
        });
        var range = this.valueScale.domain();
        var activeRange = range[1] - range[0];
        var optTicks = this.block.getScaleNicing();
        if (!this.hasFloat && optTicks >= activeRange) {
            // Apply step domain before you check for log - it has higher precedence
            this.setStepTicks(true);
        }
        else if (deviation / activeRange < 0.12 &&
            this.rangeOrg[0] > 0) {
            // Log scale
            this.autoScaleType = "log";
            return;
        }
        else if (!this.hasFloat && optTicks >= activeRange) {
            // The scale can be linear or step after this stage
            this.setStepTicks(true);
        }
        this.autoScaleType = "linear";
    }
    getFormattedValue(v, isSVG = false) {
        if (v == null) {
            v = "-";
        }
        else if (typeof v === "number") {
            if (!this.intervalTickPrint)
                this.refreshValueScale();
            v = this.intervalTickPrint(v);
        }
        return Util.addUnitName(v, this.unitName, isSVG);
    }
    /** -- */
    keepOnlyPositiveRecords() {
        this.sortedRecords = this.records.filter((record) => {
            var isPositive = this.getRecordValue(record) > 0;
            if (!isPositive) {
                this.setRecordValueCacheToMissing(record);
            }
            return isPositive;
        });
        this.updatedRangeOrg();
    }
    /** -- */
    applyScaleType() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.sortedRecords)
                return;
            this.initializeAggregates();
            // remove records with value:0 (because log(0) is invalid)
            if (this.isValueScale_Log && this.rangeOrg[0] <= 0) {
                this.keepOnlyPositiveRecords();
            }
            this.updateScaleAndBins();
            yield ((_a = this.browser.recordDisplay) === null || _a === void 0 ? void 0 : _a.refreshAttribScaleType(this));
        });
    }
    getValueScaleObj() {
        return Util.getD3Scale(this.isValueScale_Log);
    }
    getValuePosX(v) {
        return this.valueScale(v) + (this.stepTicks ? this.block.aggrWidth / 2 : 0);
    }
    getVizDomain() {
        if (this.timeseriesParent) {
            this.timeseriesParent.initializeAggregates();
            return this.timeseriesParent.timeSeriesScale_Value.domain();
        }
        return super.getVizDomain();
    }
    applyTemplateSpecial() {
        if (this.template.special === "TimePoint" && this.template.parent) {
            this.timeseriesParent.setTimepointAttrib(this.template.lastKey, this);
        }
        else if (this.template.special === "Hour") {
            this.unitName = ":00";
        }
    }
    /** -- */
    setSkipZero() {
        if (!this.aggr_initialized)
            return;
        if (this.rangeOrg[0] > 0)
            return;
        if (this.skipZero)
            return;
        this.skipZero = true;
        this.keepOnlyPositiveRecords();
        this.refreshScaleType();
    }
    // ********************************************************************
    // Unit name access  & updates
    // ********************************************************************
    /** -- */
    get unitName() {
        var _a, _b, _c, _d;
        return (_d = (_b = (_a = this.timeseriesParent) === null || _a === void 0 ? void 0 : _a.unitName) !== null && _b !== void 0 ? _b : (_c = this.measurable) === null || _c === void 0 ? void 0 : _c.unitName) !== null && _d !== void 0 ? _d : "";
    }
    /** -- */
    set unitName(v) {
        var _a;
        if (!v)
            v = "";
        if (this.unitName === v)
            return;
        if (this.timeseriesParent) {
            this.timeseriesParent.unitName = v;
            return;
        }
        super.unitName = v;
        this.block.refreshValueTickLabels();
        (_a = this.browser.recordDisplay.View) === null || _a === void 0 ? void 0 : _a.refreshAttribUnitName(this);
        if (this.measureSummary === this) {
            this.browser.blocks.forEach((block) => block.refreshMeasureLabelText("Active"));
            this.browser.DOM.activeRecordMeasure.html(this.browser.getGlobalActiveMeasure());
        }
    }
    // ********************************************************************
    // Import / Export
    // ********************************************************************
    /** -- */
    applyConfig(blockCfg) {
        const _super = Object.create(null, {
            applyConfig: { get: () => super.applyConfig }
        });
        return __awaiter(this, void 0, void 0, function* () {
            _super.applyConfig.call(this, blockCfg);
            this.measurable.valueDomain = blockCfg.valueDomain;
            yield this.block.showPercentiles.set(blockCfg.showPercentiles);
            yield this.valueScaleType.set(blockCfg.valueScaleType);
            if (blockCfg.unitName) {
                this.unitName = blockCfg.unitName;
            }
            if (blockCfg.skipZero) {
                this.setSkipZero();
            }
        });
    }
    // not exportable if this is just a timekey - it inherits properties from its parent
    isExportable() {
        return this.timeseriesParent === null;
    }
    /** -- */
    exportConfig() {
        var config = super.exportConfig();
        var c = {
            unitName: this.unitName,
            skipZero: this.skipZero,
            filter: this.summaryFilter.exportFilter()
        };
        return Object.assign(config, c);
    }
}

// group attribList by pathName
function groupSummaries(attribList) {
    var grouped = {};
    for (const attrib of attribList) {
        if (attrib == null) {
            grouped[""] = { item: null, name: i18n["(None)"], sub: {} };
            continue;
        }
        var target = grouped;
        attrib.pathName.forEach((_key) => {
            target[_key] = target[_key] || {
                item: _key,
                name: _key,
                sub: {}, // creates one with empty sub
            };
            target = target[_key].sub;
        });
        target[attrib.printName] = target[attrib.printName] || {
            name: attrib.printName,
            item: attrib,
            sub: {},
        };
        // overwriting it here, since the existing one might be set before as a simple group (item as key)
        target[attrib.printName].item = attrib;
    }
    return grouped;
}
class AttribDropdown {
    /** -- */
    constructor(_type, recDisp) {
        this.recordDisplay = recDisp;
        this._type = _type;
        this._element = this.recordDisplay.DOM[_type + "ControlGroup"]
            .append("span")
            .attr("class", "summaryGroup");
        this._button = this._element
            .append("div")
            .attr("class", "selectButton")
            .on("click", () => this.toggle());
        this._button.append("div").attr("class", "text");
        this._button.append("div").attr("class", "caret far fa-angle-down");
        this._popup = this._element.append("div").attr("class", "selectOptions");
        this._element
            .append("span")
            .attr("class", "summaryDescription fa fa-info")
            .tooltip("");
        this._popper = null;
    }
    /** -- */
    get browser() {
        return this.recordDisplay.browser;
    }
    /** Returns main timeseries if selected one is a timeKey */
    get activeAttrib() {
        var attrib = this.recordDisplay.codeBy[this._type];
        if (attrib instanceof Attrib_Numeric && attrib.hasTimeSeriesParent()) {
            return attrib.timeseriesParent;
        }
        return attrib;
    }
    /** -- */
    refresh() {
        var attrib = this.activeAttrib;
        var text;
        if (attrib == null) {
            text = i18n.NoAttribute;
        }
        else if (attrib === "_measure_") {
            text = (this.browser.measureFunc.is("Count"))
                ? this.browser.recordName
                : this.browser.measureSummary.get().printName;
        }
        else {
            text = attrib.printName;
        }
        this._button.select(".text").html(text);
        this._button.classed("none", attrib == null);
        // Update description tooltip
        var descSummary = attrib === "_measure_" ? this.browser.measureSummary : attrib;
        if (descSummary instanceof Attrib) {
            let description = descSummary ? descSummary.description : null;
            this._element
                .select(".summaryDescription")
                .style("display", description ? null : "none")
                .tooltip(description, { placement: "bottom" });
        }
    }
    /** -- */
    toggle() {
        if (this._popper) {
            this.hide();
        }
        else {
            this.show();
        }
    }
    /** -- */
    show() {
        if (this._popper)
            return;
        var measuring = (this._type === "size" || this._type === "color") && this.recordDisplay.hasAggregates();
        var dropdownOptions;
        if (measuring) {
            dropdownOptions = {};
            dropdownOptions[""] = {
                item: null,
                name: i18n.NoAttribute,
                sub: {},
            };
            dropdownOptions["Count"] = {
                item: null,
                measureType: "Count",
                name: `${i18n.measure_Count}: ${this.browser.recordName}`,
                sub: {},
            };
            dropdownOptions["Sum"] = {
                item: null,
                name: "Sum",
                measureType: "Sum",
                sub: groupSummaries(this.browser.getMeasurableSummaries("Sum")),
            };
            // 
        }
        else {
            dropdownOptions = groupSummaries(this.recordDisplay.getAttribOptions_UI(this._type));
        }
        this._popup.selectAll("div").remove();
        // recursiv method to add list of options
        var addList = (DOM, def, level = 0) => {
            var list = Object.values(def);
            // sort list so that items without group appear on top
            list = list.sort((a, b) => {
                if (a.item === null)
                    return 1;
                if (b.item === null)
                    return -1;
                return (Object.entries(b.sub).length - Object.entries(a.sub).length ||
                    a.name.localeCompare(b.name));
            });
            var listItems = DOM.selectAll("div")
                .data(list)
                .enter()
                .append("div")
                .attr("class", "option")
                .classed("active", (_) => {
                if (measuring) {
                    if (_.measureType === "Count") {
                        return this.activeAttrib === "_measure_";
                    }
                    if (_.measureType === "Sum") {
                        return this.activeAttrib === "_measure_";
                    }
                }
                if (_.item == this.activeAttrib)
                    return true;
                return (_.item === "Count" && this.activeAttrib === "_measure_" && this.browser.measureFunc.is("Count"));
            })
                .classed("collapsed", true)
                .attr("data-id", (_) => {
                if (_.item === null)
                    return "none";
                if (typeof _.item === "string")
                    return "_measure_"; // Count or Sum
                return _.item.attribID;
            })
                .classed("isSelectable", (_) => _.item instanceof Attrib)
                .classed("hasSubItems", (_) => Object.entries(_.sub).length > 0);
            listItems
                .append("div")
                .attr("class", "optionItem")
                .call((optionItem) => {
                optionItem
                    .append("div")
                    .attr("class", "groupControl")
                    .tooltip(i18n["Open/Close"])
                    .on("click", (event) => {
                    event.stopPropagation();
                    event.preventDefault();
                    event.currentTarget.parentNode.parentNode.classList.toggle("collapsed");
                })
                    .append("div")
                    .attr("class", "fa fa-caret-down");
                optionItem
                    .append("div")
                    .attr("class", "optionName")
                    .html((_) => _.name);
            })
                .on("click", (event, _) => __awaiter(this, void 0, void 0, function* () {
                if (measuring) {
                    if (_.measureType) {
                        yield this.browser.measureFunc.set(_.measureType);
                        this.recordDisplay.setAttrib(this._type, "_measure_", true);
                    }
                    else {
                        this.recordDisplay.setAttrib(this._type, null, true);
                    }
                    this.hide();
                    return;
                }
                if (typeof _.item === "string") {
                    // grouping only. open/close group
                    event.currentTarget.parentNode.classList.toggle("collapsed");
                    return;
                }
                // Attrib selection
                this.recordDisplay.setAttrib(this._type, _.item, true);
                this.hide();
            }));
            listItems
                .append("div")
                .attr("class", "subItems")
                .each((d, i, nodes) => {
                addList(select(nodes[i]), d.sub, level + 1);
            });
        };
        addList(this._popup, dropdownOptions, 0);
        this._popup.style("min-width", this._button.node().offsetWidth + "px");
        this._popper = createPopper(this._button.node(), this._popup.node(), {
            placement: this._type == "timeSeries" || this._type == "scatterY"
                ? "right-start"
                : "bottom-start",
            strategy: "absolute",
            modifiers: [
                {
                    name: "flip",
                    enabled: true,
                    boundary: this.browser.DOM.root.node(),
                    //fallbackPlacements: ['top', 'right', 'bottom', 'left'],
                },
            ],
        });
        setTimeout(() => this._element.classed("dropdownOpen", true), 10);
    }
    /** -- */
    hide() {
        this._element.classed("dropdownOpen", false);
        setTimeout(() => {
            if (!this._popper)
                return;
            this._popper.destroy();
            this._popper = null;
        }, 350);
    }
}

const d3$h = { select, pointer };
class ConfigPanel {
    /** -- */
    constructor(rootDOM, headerName, className, configs, browser, controlButton) {
        this.browser = browser;
        this.DOM = {
            root: rootDOM
                .append("div")
                .attr("class", "configPanel " + className)
                .classed("active", false),
            configTable: null,
        };
        this.controlButton = controlButton;
        this.DOM.root
            .append("div")
            .attr("class", "configClose fa fa-window-close")
            .tooltip(i18n.Close)
            .on("click", () => this.hide());
        this.DOM.root
            .append("div")
            .attr("class", "popupPanel_Header")
            .html(i18n[headerName])
            // Dragging support while keeping it within window
            .on("mousedown", (event) => {
            browser.DOM.root
                .classed("noPointerEvents", true)
                .attr("drag_cursor", "grabbing");
            var bodyDOM = d3$h.select("body").node();
            var initPos = d3$h.pointer(event, bodyDOM);
            var DOM = this.DOM.root.node();
            var initX = parseInt(DOM.offsetLeft);
            var initY = parseInt(DOM.offsetTop);
            d3$h.select("body")
                .on("mousemove", (event2) => {
                var newPos = d3$h.pointer(event2, bodyDOM);
                this.checkPositionSanity(initX - initPos[0] + newPos[0], initY - initPos[1] + newPos[1]);
            })
                .on("mouseup", () => {
                browser.DOM.root
                    .classed("noPointerEvents", false)
                    .attr("drag_cursor", null);
                d3$h.select("body").on("mousemove", null).on("mouseup", null);
            });
            event.preventDefault();
        });
        this.DOM.root
            .append("div")
            .attr("class", "compactSizeControl far fa-angle-double-up")
            .on("click", () => this.DOM.root.node().classList.toggle("compact"));
        this.DOM.configTable = this.DOM.root
            .append("div")
            .attr("class", "popupPanel_Content")
            .append("table")
            .attr("class", "configTable");
        configs.forEach((cfg) => this.insertConfigUI(cfg));
    }
    insertConfigUI(cfg) {
        cfg.insertControl(this.DOM.configTable);
    }
    /** -- */
    showAtPos(left, top) {
        if (this.DOM.root.classed("active")) {
            this.hide();
            return;
        }
        this.browser.closeConfigPanels();
        this.DOM.root.classed("active", true);
        this.controlButton.classed("fa-spin", true);
        this.checkPositionSanity(left, top);
    }
    /** -- */
    hide() {
        this.DOM.root.classed("active", false);
        this.controlButton.classed("fa-spin", false);
    }
    /** -- */
    checkPositionSanity(curLeft = null, curTop = null) {
        if (!Base.browser)
            return;
        var space = 8; // just to add some space around...
        var dom = this.DOM.root.node();
        var panelWidth = dom.offsetWidth + space;
        var panelHeight = dom.offsetHeight + space;
        if (curLeft == null)
            curLeft = parseFloat(dom.style.left);
        if (curTop == null)
            curTop = parseFloat(dom.style.top);
        var maxWidth = dom.offsetParent.getBoundingClientRect().width;
        var maxHeight = dom.offsetParent.getBoundingClientRect().height;
        dom.style.left =
            Math.max(space, Math.min(maxWidth - panelWidth, curLeft)) + "px";
        dom.style.top =
            Math.max(space, Math.min(maxHeight - panelHeight, curTop)) + "px";
    }
}

class Filter_Spatial extends Filter {
    constructor(_browser, attrib) {
        super(_browser);
        this.bounds = null;
    }
    get title() {
        return i18n["Spatial"];
    }
    exportFilter() {
        return {
            bounds: this.bounds,
        };
    }
    importFilter(_) {
        this.bounds = _;
        this.setFiltered(false); // no update...
        this.applyFilter();
    }
    onClear() {
        this.browser.recordDisplay.DOM.recordBase_Map
            .select(".spatialQueryBox_Filter")
            .classed("active", null);
    }
    filterView_Detail() {
        return "<i class='fa fa-square-o'></i> (Area)";
    }
    onFilter() {
        this.browser.recordDisplay.DOM.recordBase_Map
            .select(".spatialQueryBox_Filter")
            .classed("active", true);
        this.browser.records.forEach((record) => {
            var rBounds = this.attrib.getRecordValue(record)._bounds;
            record.setFilterCache(this.filterID, rBounds ? Util.intersects(rBounds, this.bounds) : false);
        }, this);
    }
}

const d3$g = { geoBounds };
/** -- */
class Aggregate_PointCluster extends Aggregate {
    /** -- */
    constructor(attrib, _cluster) {
        super(attrib);
        this.cluster = _cluster;
    }
    get tooltipTitle() {
        return i18n["Cluster"];
    }
    get label() {
        return "";
    }
}
/** Can be a point object, or polygon objects */
class Attrib_RecordGeo extends Attrib {
    constructor(browser, name, template) {
        super(browser, name, template, "recordGeo", "", "far fa-map-marker");
        this._aggrs = [];
        // ********************************************************************
        // Filtering
        // ********************************************************************
        this.summaryFilter = null;
        // ********************************************************************
        // Point cluster management
        // ********************************************************************
        this.maxNodeRecordSize = 1000;
        // ********************************************************************
        // Cluster radius management
        // ********************************************************************
        this._pointClusterRadius = 50;
        this.createSummaryFilter();
    }
    getRecordValue(record) {
        return record.getValue(this);
    }
    /** Only supports "geo" encoding */
    supportsRecordEncoding(coding) {
        return coding === "geo";
    }
    get measureRangeMax() {
        return this.geoType === "Point" ? this._pointClusterRadius : 1;
    }
    createSummaryFilter() {
        this.summaryFilter = new Filter_Spatial(this.browser, this);
    }
    // ********************************************************************
    // Aggregates / geo-cache
    // ********************************************************************
    loadGeo() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.recordGeoMap) {
                yield this.recordGeoMap.loadGeo();
            }
            this.browser.records.forEach((record) => {
                var feature = this.template.func.call(record.data, record);
                if (typeof feature === "string" && this.recordGeoMap) {
                    feature = this.recordGeoMap.getFeature(feature.toUpperCase());
                }
                if (feature) {
                    var g = {
                        geoFeat: feature,
                        _bounds: d3$g.geoBounds(feature),
                    };
                    this.geoType = feature.type;
                    record.setValue(this, g);
                }
                else {
                    record.setValue(this, null);
                    this.noValueAggr.addRecord(record);
                }
            });
        });
    }
    initializeAggregates() {
        if (this.aggr_initialized)
            return;
        this.aggr_initialized = true;
    }
    applyConfig(blockCfg) {
        const _super = Object.create(null, {
            applyConfig: { get: () => super.applyConfig }
        });
        return __awaiter(this, void 0, void 0, function* () {
            _super.applyConfig.call(this, blockCfg);
            if (blockCfg.recordGeo) {
                this.recordGeoMap = Base.maps.get(blockCfg.recordGeo);
                if (!this.recordGeoMap) {
                    this.recordGeoMap = null;
                }
            }
        });
    }
    /** -- */
    getRecordBounds(onlyIncluded) {
        let bs = [];
        this.browser.records.forEach((record) => {
            if (onlyIncluded && record.filteredOut)
                return;
            let v = this.getRecordValue(record);
            if (!v)
                return;
            if (!v._bounds)
                return;
            let b = v._bounds;
            if (isNaN(b[0][0]))
                return;
            let p1 = L.latLng(b[0][1], b[0][0]);
            let p2 = L.latLng(b[1][1], b[1][0]);
            bs.push(p1);
            bs.push(p2);
        });
        return new L.latLngBounds(bs);
    }
    prepPointCluster(leafletMap) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.pointClusterRadius === 0) {
                return;
            }
            this.PointCluster = new Supercluster({
                radius: this.pointClusterRadius,
                maxZoom: leafletMap.getMaxZoom() - 1,
                minZoom: leafletMap.getMinZoom(),
                //map: (props) => ({data: props.data}),
            });
            let points = [];
            this.records.forEach((record) => {
                let value = this.getRecordValue(record);
                if (value) {
                    points.push({
                        type: "Feature",
                        properties: record,
                        geometry: value.geoFeat,
                    });
                }
            });
            this.PointCluster.load(points);
        });
    }
    updateClusters(_bounds, zoom) {
        this.deletePointClusters();
        let _clusters = this.PointCluster.getClusters([
            _bounds.getWest(),
            _bounds.getSouth(),
            _bounds.getEast(),
            _bounds.getNorth(),
        ], Math.floor(zoom));
        _clusters.forEach((cluster) => {
            if (!cluster.id) {
                // single record
                let record = cluster.properties;
                record._view.inCluster = false;
                //
            }
            else {
                let clusterMembers = this.PointCluster.getLeaves(cluster.id, this.maxNodeRecordSize);
                let clusterAggr = new Aggregate_PointCluster(this, cluster);
                clusterMembers.forEach((member) => {
                    let record = member.properties;
                    record._view.inCluster = true;
                    if (record.isIncluded) {
                        clusterAggr.addRecord(record);
                    }
                });
                if (clusterAggr.records.length === 0)
                    return;
                if (clusterAggr.records.length === 1) {
                    // remove individual record from cluster
                    let record = clusterAggr.records[0];
                    record._view.inCluster = false;
                    clusterAggr.clearRecords();
                    return;
                }
                this._aggrs.push(clusterAggr);
                this.browser.allAggregates.push(clusterAggr);
            }
        });
        // sort aggregates by active measure size
        this._aggrs.sort((c1, c2) => c2.measure("Active") - c1.measure("Active"));
    }
    /** -- */
    deletePointClusters() {
        // delete all clusters
        this._aggrs.forEach((clusterAggr) => {
            clusterAggr.clearRecords(); // removes cluster aggregate from record's aggregate index
            clusterAggr.DOM.aggrGlyph.remove(); // removes the DOM item
            this.browser.allAggregates.splice(this.browser.allAggregates.indexOf(clusterAggr), 1);
        });
        this.records.forEach((record) => {
            record._view.inCluster = false;
        });
        this._aggrs = [];
    }
    get pointClusterRadius() {
        return this._pointClusterRadius;
    }
    setPointClusterRadius(radius, leafletRecordMap) {
        return __awaiter(this, void 0, void 0, function* () {
            // must be positive integer
            this._pointClusterRadius = Math.round(Math.max(0, radius));
            if (this.pointClusterRadius === 0) {
                this.deletePointClusters();
                return;
            }
            return yield this.prepPointCluster(leafletRecordMap);
        });
    }
    // ********************************************************************
    // Export / import config
    // ********************************************************************
    exportConfig() {
        return {
            pointClusterRadius: this._pointClusterRadius,
        };
    }
}

const d3$f = {
    scaleTime: time,
    scaleLinear: linear,
    min,
    max,
    extent,
    format,
    deviation,
    easePolyInOut: polyInOut,
};
var _tempClipPathCounter;
/** -- */
class Attrib_Timeseries extends Attrib {
    get measureRangeMax() {
        throw new Error("Not applicable.");
    }
    constructor(browser, name, template) {
        super(browser, name, template, "timeseries", "", "far fa-chart-line");
        this.tickPrecision = 3;
        this.timeKeys = [];
        this.timeKeyAttribs = [];
        this.measurable = {
            metricFuncs: Base.defaultMetricFuncs
        };
        this.valueScaleType = new Config({
            cfgClass: "valueScaleType",
            cfgTitle: "BinScale",
            iconClass: "fa fa-arrows-h",
            parent: this,
            default: "linear",
            helparticle: "5e87eabc04286364bc97d0cf",
            itemOptions: [
                { name: `${i18n.Linear} ${i18n.LinearSequence}`, value: "linear" },
                { name: `${i18n.Log} ${i18n.Log2Sequence}`, value: "log" },
            ],
            forcedValue: () => {
                if (!this.supportsLogScale())
                    return "linear";
            },
            preSet: (v) => __awaiter(this, void 0, void 0, function* () {
                if (v !== "log" && v !== "linear")
                    return;
                // don't set to log if it's not applicable
                return v;
            }),
            onSet: (v) => __awaiter(this, void 0, void 0, function* () {
                if (!this.timeSeriesScale_Value)
                    return;
                for (var c in this.timeKeyAttribs) {
                    var s = this.timeKeyAttribs[c];
                    if (s.timeKey)
                        yield s.applyScaleType();
                }
                this.timeSeriesScale_Value = Util.getD3Scale(v === "log").domain(this.getExtent_Value());
                yield this.browser.recordDisplay.refreshAttribScaleType(this);
            }),
        });
        this.numberFormat = (x) => {
            if (this.hasFloat && x < 1000) {
                return d3$f.format(",.3~f")(x);
            }
            var m = d3$f.format(".3~s")(x); // if input is 9, it returns 9.0 . ARGH!
            return m.replace(".0", "");
        };
        this.finishTemplateSpecial();
    }
    getRecordValue(record) {
        return record.getValue(this);
    }
    /** -- */
    supportsRecordEncoding(coding) {
        if (this.isEmpty())
            return false;
        this.initializeAggregates();
        if (this.isComparable.is(false))
            return false;
        if (coding === "timeSeries")
            return true;
        if (coding === "sort")
            return true;
        if (coding === "scatterX")
            return true;
        if (coding === "scatterY")
            return true;
        if (coding === "color")
            return true;
        if (coding === "size") {
            return !this.hasNegativeValues();
        }
        return false;
    }
    /** -- */
    isEmpty() {
        return !this.timeKeys || this.timeKeys.length === 0;
    }
    /** -- */
    get canHaveMetricFuncs() {
        return true;
    }
    /** -- */
    get supportedMetricFuncs() {
        return this._metricFuncs;
    }
    /** -- */
    supportsLogScale() {
        if (!this.timeSeriesScale_Value) {
            return true; // assume it supports by default
        }
        return (this.timeSeriesScale_Value &&
            this.timeSeriesScale_Value.domain().every((_) => _ > 0));
        // Do not filter by unitName!=="%" - in some cases it may make sense
    }
    /** -- */
    hasNonNegativeValueDomain() {
        return this.timeSeriesScale_Value.domain().every((_) => _ >= 0);
    }
    get attribName() {
        return super.attribName;
    }
    set attribName(name) {
        super.attribName = name;
        // name wasn't updated
        if (this.attribName !== name)
            return;
        for (var timeKey in this.timeKeyAttribs) {
            var attrib = this.timeKeyAttribs[timeKey];
            attrib.attribName = `${this.attribName} <i class="far fa-calendar-day"></i> ${attrib.timeKey._time_src}`;
        }
        // Refresh other places which is linked to this timeseries variable
        if (this.browser.recordChartType.is("timeseries")) {
            this.browser.recordDisplay.refreshAttribOptions("timeSeries");
        }
        this.browser.recordDisplay.refreshAttribOptions("sort");
    }
    /** -- */
    updateChartScale_Measure() {
        // no-op
    }
    applyTemplateSpecial() {
        if (this.template.special === "TimeseriesChange-%") {
            this.unitName = "%";
        }
    }
    /** -- */
    initializeAggregates() {
        if (this.aggr_initialized)
            return;
        var timeIndex = {};
        var extent_Time = [];
        var extent_Value = [];
        var allRecordValues = [];
        this.browser.records.forEach((record) => {
            var _ = this.template.func.call(record.data, record);
            if (_ == null) {
                record.setValue(this, null);
                return;
            }
            var ts = _;
            record.setValue(this, ts);
            ts.sortTimeseries();
            ts.computeCaches();
            // per whole attribute
            ts._timeseries_.forEach((k) => {
                timeIndex[k._time.getTime()] = k._time_src;
                allRecordValues.push(k._value);
            });
            extent_Time.push(ts.extent_Time);
            extent_Value.push(ts.extent_Value);
        });
        if (extent_Time.length === 0) {
            this.aggr_initialized = true;
            return;
        }
        // min of the min's, max of the max's
        var valueDomain = this.valueDomain || [
            d3$f.min(extent_Value, (_) => _[0]),
            d3$f.max(extent_Value, (_) => _[1]),
        ];
        var timeDomain = [
            d3$f.min(extent_Time, (_) => _[0]),
            d3$f.max(extent_Time, (_) => _[1]),
        ];
        // Figure out if the values are floating points or full integers
        this.hasFloat = allRecordValues.some((v) => v % 1 !== 0);
        if (!this.hasFloat) {
            this.tickPrecision = valueDomain[1].toLocaleString().length > 5 ? 3 : 0;
        }
        // Set scale
        var deviation = d3$f.deviation(allRecordValues);
        var activeRange = valueDomain[1] - valueDomain[0];
        this.valueScaleType.set((deviation / activeRange < 0.12 && valueDomain[0] > 0) ? "log" : "linear");
        // Currently static settings once a timeseries is selected
        this.timeSeriesScale_Time = d3$f.scaleTime().domain(timeDomain);
        this.timeSeriesScale_Value = Util.getD3Scale(this.isValueScale_Log);
        this.timeSeriesScale_Value.domain(valueDomain);
        for (var _ in timeIndex) {
            this.timeKeys.push({
                _time: new Date(Number(_)),
                _time_src: timeIndex[_],
            });
        }
        this.timeKeys.sort((a, b) => a._time.getTime() - b._time.getTime());
        this.timeKeys.forEach((timeKey, i) => {
            timeKey._index = i;
        });
        // Some records may be missing some values on some time-keys.
        // Here, we need to insert new time keys and set them to undefined
        // Charting will take care whether to interpolate the missing values or not.
        this.browser.records.forEach((record) => {
            var _ts = this.getRecordValue(record);
            if (!_ts)
                return;
            var newTimeKeyAdded = false;
            this.timeKeys.forEach((_key) => {
                if (!_ts._keyIndex[_key._time_src]) {
                    _ts.addTimeData({
                        _time: _key._time,
                        _time_src: _key._time_src,
                        _value: undefined,
                    });
                    newTimeKeyAdded = true;
                }
            });
            if (newTimeKeyAdded) {
                _ts.sortTimeseries();
            }
        });
        this.aggr_initialized = true;
    }
    /** -- */
    getExtent_Value(onlyUnfiltered = false, timeDomain = null) {
        if (!onlyUnfiltered && this.valueDomain) {
            return this.valueDomain;
        }
        var inTimeDomain = (_d) => true;
        if (timeDomain) {
            inTimeDomain = (d) => d._time >= timeDomain[0] && d._time <= timeDomain[1];
        }
        var extent_Value = [];
        var valFunc = (k) => (inTimeDomain(k) ? k._value : null);
        if (this.isValueScale_Log) {
            valFunc = (k) => (inTimeDomain(k) && k._value > 0 ? k._value : null);
        }
        this.browser.records.forEach((record) => {
            if (onlyUnfiltered && record.filteredOut)
                return;
            var _ts = this.getRecordValue(record);
            if (!_ts)
                return;
            _ts.extent_Value = d3$f.extent(_ts._timeseries_, valFunc);
            if (typeof _ts.extent_Value[0] === "number") {
                extent_Value.push(_ts.extent_Value);
            }
        });
        return [
            d3$f.min(extent_Value, (_) => _[0]),
            d3$f.max(extent_Value, (_) => _[1]),
        ];
    }
    /** -- */
    hasNegativeValues() {
        return d3$f.min(this.timeSeriesScale_Value.domain()) < 0;
    }
    /** -- */
    hasFlippedDomain() {
        var tsDomain = this.timeSeriesScale_Value.domain();
        return tsDomain[0] > tsDomain[1];
    }
    /** -- */
    computeRecordRanks() {
        this.timeKeys.forEach((timeKey) => {
            // sort records in place
            var compFunc = this.hasFlippedDomain()
                ? (vA, vB) => vA._value - vB._value
                : (vA, vB) => vB._value - vA._value;
            var getValueAtTime = (record, key) => {
                var v = this.getRecordValue(record);
                if (!v || v.isEmpty())
                    return null;
                let v2 = v._keyIndex[key];
                if (v2 == null)
                    return null;
                return v2;
            };
            // sorts a copied record list, and assigns _rank.
            Array.from(this.browser.records)
                .sort((a, b) => {
                if (a.filteredOut)
                    return 1;
                if (b.filteredOut)
                    return -1;
                var vA = getValueAtTime(a, timeKey._time_src);
                if (vA == null)
                    return 1;
                var vB = getValueAtTime(b, timeKey._time_src);
                if (vB == null)
                    return -1;
                return compFunc(vA, vB);
            })
                .forEach((record, i) => {
                var v = getValueAtTime(record, timeKey._time_src);
                if (v != null)
                    v._rank = i + 1;
            });
        });
    }
    /** -- */
    get isValueScale_Log() {
        return this.valueScaleType.is("log");
    }
    get isValueScale_Linear() {
        return this.valueScaleType.is("linear");
    }
    // No-ops
    createSummaryFilter() { }
    refreshViz_Compare() { }
    // ********************************************************************
    // Accessing specific timepoint attributes
    // ********************************************************************
    /** -- */
    setTimepointAttrib(timePoint, summary) {
        if (typeof timePoint === "string" || !timePoint._time) {
            timePoint = this.timeKeys.filter((key) => key._time_src === timePoint)[0];
            if (!timePoint)
                return; // nope
        }
        summary.timeKey = timePoint;
        this.timeKeyAttribs[timePoint._time_src] = summary;
    }
    /** -- */
    getTimepointSummary_Next(curSummary, shift = 1) {
        this.initializeAggregates(); // make sure the summary is ready
        if (this.isEmpty())
            return null;
        var timeKey = curSummary.timeKey._time_src;
        if (!timeKey)
            return null;
        // Return null if end of keys
        var curIndex = -1;
        this.timeKeys.some((key, i) => {
            if (key._time_src === timeKey) {
                curIndex = i;
                return true;
            }
        });
        // check if new value is in range
        if (shift > 0 && curIndex === this.timeKeys.length - 1) {
            return null;
        }
        if (shift < 0 && curIndex === 0) {
            return null;
        }
        var target = Math.min(this.timeKeys.length - 1, Math.max(0, curIndex + shift));
        return this.getTimepointSummary(this.timeKeys[target]);
    }
    /** - */
    getTimepointSummary(timePoint) {
        this.initializeAggregates(); // make sure the summary is ready
        var attrib = this.timeKeyAttribs[timePoint._time_src];
        if (!attrib) {
            attrib = this.browser.createAttrib(`${this.attribName} <i class="far fa-calendar-day"></i> ${timePoint._time_src}`, `${this.template}->${timePoint._time_src}`, "numeric");
            this.setTimepointAttrib(timePoint, attrib);
            attrib.initializeAggregates();
        }
        return attrib;
    }
    /** -- */
    printAbbr(v, isSVG = false) {
        // uses print from a timeKey summary
        return this.getTimepointSummary(this.timeKeys[0]).printAbbr(v._value, isSVG);
    }
    /** -- */
    getFormattedValue(v, isSVG = false) {
        var formatted = this.numberFormat(v);
        return v == null ? "-" : Util.addUnitName(formatted, this.unitName, isSVG);
    }
    /** -- */
    applyConfig(blockCfg) {
        const _super = Object.create(null, {
            applyConfig: { get: () => super.applyConfig }
        });
        return __awaiter(this, void 0, void 0, function* () {
            _super.applyConfig.call(this, blockCfg);
            this.measurable.valueDomain = blockCfg.valueDomain;
            if (blockCfg.valueScaleType) {
                yield this.valueScaleType.set(blockCfg.valueScaleType);
            }
            if (blockCfg.unitName) {
                this.unitName = blockCfg.unitName;
            }
        });
    }
    /** -- */
    exportConfig() {
        return Object.assign(super.exportConfig(), {
            unitName: this.unitName,
            valueScaleType: this.valueScaleType.get(),
        });
    }
    /** -- */
    renderRecordValue(v, d3_selection, timeKeys = null) {
        if (v instanceof Record)
            v = this.getRecordValue(v);
        if (!d3_selection || !v)
            return;
        if (!(v instanceof TimeSeriesData))
            return;
        this.initializeAggregates();
        var timeseriesWidth = this.browser.recordDisplay.config.timeseriesWidth;
        var timeScale = d3$f
            .scaleTime()
            .domain(d3$f.extent(timeKeys, (f) => f._time))
            .rangeRound([5, timeseriesWidth - 5]);
        let timeData = v._timeseries_;
        var [value_min, value_max] = d3$f.extent(timeData, (d) => d._value);
        let steadyValue;
        if (value_min === value_max) {
            steadyValue = value_max;
            value_min -= 0.00001;
            value_max += 0.00001;
        }
        else if (this.hasFlippedDomain()) {
            // if the timeseries value-axis is flipped
            [value_min, value_max] = [value_max, value_min];
        }
        var valueScale = d3$f
            .scaleLinear()
            .domain([value_min, value_max])
            .rangeRound([40, 0]);
        _tempClipPathCounter++;
        var colorOut = this.browser.colorTheme.getContinuous();
        var mapp = this.timeSeriesScale_Value.copy().range([0, 1]);
        var _timeSeriesSvg = d3_selection
            .append("svg")
            .attr("xmlns", "http://www.w3.org/2000/svg")
            .attr("class", "recordDetailTimeseries")
            .style("width", timeseriesWidth + "px");
        var defs = _timeSeriesSvg.append("defs");
        defs
            .append("clipPath")
            .attr("id", "RecordTimeseriesClip_" + _tempClipPathCounter)
            .append("rect")
            .attr("class", "recordTimeseriesClipPath")
            .attr("x", 0)
            .attr("y", -10)
            .attr("height", 70)
            .attr("width", 1)
            .transition()
            .duration(1500)
            .delay(0)
            .ease(d3$f.easePolyInOut)
            .attr("width", timeseriesWidth + 10);
        var _ = defs
            .append("linearGradient")
            .attr("id", "GradientPath_" + _tempClipPathCounter)
            .attr("x1", "0")
            .attr("x2", "0")
            .attr("y1", "0")
            .attr("y2", "1");
        _.append("stop")
            .attr("stop-color", colorOut(mapp(value_max)))
            .attr("offset", "0%");
        _.append("stop")
            .attr("stop-color", colorOut(mapp(value_min)))
            .attr("offset", "100%");
        _timeSeriesSvg
            .selectAll(".extentValueGroup")
            .data(steadyValue != null ? [steadyValue] : [value_min, value_max])
            .enter()
            .append("g")
            .attr("class", "extentValueGroup")
            .attr("transform", (d) => `translate(0,${valueScale(d)})`)
            .call((_) => {
            _.append("text")
                .attr("class", "extentText")
                .html((timeData) => this.printAbbr(timeData, true))
                .attr("x", timeseriesWidth + 6);
            _.append("line")
                .attr("class", "extentLine")
                .attr("x1", 0)
                .attr("x2", timeseriesWidth)
                .attr("y1", 0)
                .attr("y2", 0);
        });
        var maxChar = timeKeys.reduce((accum, key) => Math.max(accum, key._time_src.length), 0);
        var tickGapWidth = maxChar * 7;
        var lastTickPos = 30000;
        _timeSeriesSvg
            .append("g")
            .attr("class", "extentYearGroup")
            .selectAll(".extentYear")
            .data(timeKeys)
            .enter()
            .append("text")
            .attr("class", "extentYear")
            .attr("y", 53)
            .attr("x", (tick) => timeScale(tick._time))
            .html((tick) => tick._time_src)
            .style("opacity", (tick) => {
            var newTickPos = timeScale(tick._time);
            if (lastTickPos - newTickPos < tickGapWidth)
                return 0;
            lastTickPos = newTickPos;
            return 0.8;
        });
        _timeSeriesSvg
            .append("g")
            .attr("clip-path", 'url("#RecordTimeseriesClip_' + _tempClipPathCounter + '")')
            .call((_g) => {
            _g.append("path")
                .attr("class", "recordTimeseriesLine")
                .datum(timeData)
                .attr("d", Util.getLineGenerator(timeScale, valueScale))
                .attr("stroke", steadyValue != null
                ? colorOut(mapp(value_max))
                : "url(#GradientPath_" + _tempClipPathCounter + ")");
            _g.selectAll(".recordTimeseriesDot")
                .data(timeData.filter((_) => !!_._value)) // only use the entries which have a _value set
                .enter()
                .append("circle")
                .attr("class", "recordTimeseriesDot")
                .attr("r", 3)
                .attr("cx", (d) => timeScale(d._time))
                .attr("cy", (d) => valueScale(d._value))
                .attr("fill", (d) => colorOut(mapp(d._value)))
                .tooltip((d) => "<div class='recordColorInfo'>" +
                "<span class='mapTooltipLabel'>" +
                "<i class='far fa-calendar'></i> " +
                d._time_src +
                "</span><br> " +
                "<b><span class='mapTooltipValue'>" +
                this.getFormattedValue(d._value) +
                "</span></b>" +
                "</div>", {
                theme: "dark timeseriesRecordDot",
                placement: "top",
            })
                .on("click", (_event, d) => this.browser.recordDetailsPopup.updateFocusedTimeKey(d));
        });
    }
}

const d3$e = {
    select,
    pointer,
    max,
    format,
    hsl,
    geoBounds,
    geoPath,
    geoTransform,
    scaleQuantize: quantize,
};
class Block_Categorical extends Block {
    constructor(attrib) {
        super(attrib);
        // ********************************************************************
        // View type control
        // ********************************************************************
        this.viewType = "list";
        // ********************************************************************
        // Height
        // ********************************************************************
        this._height_Categories = 0;
        this.heightRow_category_dirty = false;
        // ********************************************************************
        // Text search
        // ********************************************************************
        this.skipTextSearchClear = false;
        this.catCount_InDisplay = 0;
        this.firstCatIndexInView = 0;
        // ********************************************************************
        // Set matrix - multi valuied control
        // ********************************************************************
        this.show_set_matrix = false;
        this.splitOnSelfCompare = true;
        // ********************************************************************
        // Mapping
        // ********************************************************************
        this.leafletAttrMap = null;
        // ********************************************************************
        // List - Sorting
        // ********************************************************************
        this.scrollTop_cache = 0;
        // ********************************************************************
        // Dropdown
        // ********************************************************************
        this.dropdown_type = "SingleSelect";
    }
    get _aggrs() {
        return this.attrib._aggrs;
    }
    get setAttrib() {
        return this.attrib.setAttrib;
    }
    // ********************************************************************
    // Collapse / add / remove pansl
    // ********************************************************************
    setCollapsed(v) {
        super.setCollapsed(v);
        if (this.leafletAttrMap && !this.collapsed) {
            setTimeout(() => {
                this.leafletAttrMap.invalidateSize();
                this.catMap_zoomToActive();
            }, 500);
        }
        if (this.collapsed && this.setAttrib) {
            this.showSetMatrix(false);
        }
    }
    onCollapse() {
        if (!this.collapsed && this.DOM.root && this.isView_List) {
            if (this.attrib.dirtySort) {
                this.updateCatSorting_now();
                this.refreshViz_All();
            }
            this.refreshLabelWidth();
            this.catList_cullCategories();
        }
    }
    addToPanel(panel, index, force = false) {
        var _do = () => {
            super.addToPanel(panel, index);
            if (this.setAttrib) {
                if (this.panel.name === "left" || this.panel.name === "right") {
                    this.setAttrib.block.refreshPopupSide();
                }
                else {
                    this.hideSetMatrix();
                }
            }
            this.browser.updateLayout();
        };
        if (this._aggrs.length > 500 &&
            this.attrib.minAggrSize.get() === 1 &&
            !force) {
            Modal.confirm("<div style='text-align:center'>There are many (" +
                this._aggrs.length.toLocaleString() +
                ") " +
                "categories in " +
                this.attrib.attribName +
                ".<br>" +
                "Adding all can make your dashboard slower.<br><br>" +
                "Would you like to hide categories with 5 or less records?</div>", "Hide small categories", "Show all categories")
                .then(() => __awaiter(this, void 0, void 0, function* () { return yield this.attrib.minAggrSize.set(5); }))
                .finally(() => _do());
        }
        else {
            _do();
        }
    }
    get isView_Dropdown() {
        return this.viewType === "dropdown";
    }
    get isView_List() {
        return this.viewType === "list";
    }
    get isView_Map() {
        return this.viewType === "map";
    }
    catViewAs(_type) {
        return __awaiter(this, void 0, void 0, function* () {
            if (_type === "map") {
                try {
                    if (!this.attrib.catGeo)
                        throw new Error("No mapping specified");
                    if (!window.L) {
                        yield import('./vendor_mapping.js').then(function (n) { return n.l; });
                    }
                    yield this.attrib.loadMap();
                    this.mapIsReady = false;
                }
                catch (error) {
                    console.log(error);
                    Modal.alert(error.message);
                    this.catViewAs("list");
                    return;
                }
            }
            this.viewType = _type;
            this.noRefreshVizAxis = this.isView_Dropdown;
            if (!this.DOM.inited)
                return;
            this.DOM.root.attr("viewType", this.viewType);
            this.DOM.root.selectAll(".summaryViewAs")
                .classed("active", false);
            this.DOM.root.selectAll(".summaryViewAs_" + this.viewType)
                .classed("active", true);
            if (this.viewType === "list") {
                this.list_prepView();
            }
            else if (this.viewType === "map") {
                this.catMap_prepView();
            }
            else if (this.viewType === "dropdown") {
                this.dropdown_prepView();
            }
        });
    }
    get height_Categories() {
        return this._height_Categories;
    }
    get height_Content() {
        if (!this.isVisible())
            return 0;
        if (this.isView_Dropdown)
            return this.height_Dropdown;
        return (this._height_Categories + this.height_Config + this.height_Bottom + 1);
    }
    get height_RangeMin() {
        if (this.attrib.isEmpty())
            return this.height_Header;
        if (this.isView_Dropdown)
            return this.height_Dropdown;
        if (this.isView_Map)
            return this.getWidth() * 0.2;
        return this.height_ListWithoutCats + 1.5 * this.heightCat;
    }
    get height_RangeMax() {
        if (this.attrib.isEmpty())
            return this.height_Header;
        if (this.isView_Dropdown)
            return this.height_Dropdown;
        if (this.isView_Map)
            return this.getWidth() * 1.5;
        return this.height_ListWithoutCats + this._aggrs.length * this.heightCat;
    }
    get heightCat() {
        return this.attrib.barHeight.get();
    }
    get height_Dropdown() {
        return 42;
    }
    get height_ListWithoutCats() {
        return this.height_Header + this.height_Config + this.height_Bottom;
    }
    get height_VisibleAttrib() {
        return this.catCount_Active * this.heightCat;
    }
    get height_Config() {
        return 18 * (this.hasTextSearch() ? 1 : 0);
    }
    get height_bar_topGap() {
        return this.heightCat > 20 ? 4 : 2;
    }
    get barHeight_Full() {
        return this.heightCat - 2 * this.height_bar_topGap;
    }
    get height_Bottom() {
        var _a, _b;
        if (!this.areAllCatsInDisplay() ||
            !this.panel.hiddenCatBars() ||
            this._aggrs.length > 4) {
            (_a = this.DOM.summaryCategorical) === null || _a === void 0 ? void 0 : _a.classed("nobottoms", false);
            return Base.height_CatBottom;
        }
        (_b = this.DOM.summaryCategorical) === null || _b === void 0 ? void 0 : _b.classed("nobottoms", true);
        return 0;
    }
    /** -- */
    get catLabelFontSize() {
        if (this.heightCat > 35)
            return 19;
        if (this.heightCat > 30)
            return 17;
        if (this.heightCat > 25)
            return 15;
        if (this.heightCat > 15)
            return 13;
        return this.heightCat - 2;
    }
    hasStaticHeight() {
        return this.isView_Dropdown;
    }
    setHeight(targetHeight) {
        if (this.attrib.isEmpty())
            return;
        // take into consideration the other components in the summary
        targetHeight -=
            this.height_Header + this.height_Config + this.height_Bottom;
        if (this.isView_Map) {
            this._height_Categories = targetHeight;
            setTimeout(() => {
                if (this.leafletAttrMap)
                    this.leafletAttrMap.invalidateSize();
            }, 700);
            return;
        }
        this._height_Categories = Math.min(targetHeight, this.heightCat * this.catCount_Active - 1);
    }
    refreshHeight_Category() {
        if (!this.DOM.inited)
            return;
        if (!this.isView_List)
            return;
        this.heightRow_category_dirty = false;
        this.browser.updateLayout();
        this.DOM.aggrGlyphs.style("transform", (_cat) => _cat.transformPos);
        this.refreshHeight_Category_do();
    }
    /** -- */
    refreshHeight_Category_do() {
        this.DOM.aggrGlyphs.style("height", this.heightCat + "px");
        this.DOM.root.selectAll(".catLabel")
            .style("font-size", this.catLabelFontSize + "px");
        this.DOM.chartBackground.style("height", this.height_VisibleAttrib + "px");
        this.DOM.catChart.classed("multiLine", this.heightCat >= 56 && // 4x
            this.DOM.root.node().style.webkitLineClamp !== undefined);
        this.refreshViz_All();
    }
    refreshHeight() {
        var _a;
        super.refreshHeight();
        if (this.attrib.isEmpty() || !this.inDashboard || !this.DOM.inited)
            return;
        if (this.isView_Dropdown)
            return;
        // It can be collapsed! - don't use "isVisible" fucntion here
        if (this.collapsed) {
            if (this.isView_Map)
                this.DOM.catMap_Base.style("height", "0px");
            return;
        }
        // update catCount_InDisplay
        let c = Math.floor(this._height_Categories / this.heightCat);
        if (c < 0)
            c = 1;
        if (c > this.catCount_Active)
            c = this.catCount_Active;
        if (this.catCount_Active <= 2) {
            c = this.catCount_Active;
        }
        else {
            c = Math.max(c, 2);
        }
        this.catCount_InDisplay = c + 1;
        this.catCount_InDisplay = Math.min(this.catCount_InDisplay, this.catCount_Active);
        this.refreshScrollDisplayMore(this.firstCatIndexInView + this.catCount_InDisplay);
        this.updateCats_IsVisible();
        this.catList_cullCategories();
        this.DOM.headerGroup.attr("allCatsInDisplay", this.areAllCatsInDisplay());
        if (this.isView_Map) {
            this.DOM.catMap_Base.style("height", null);
            (_a = this.leafletAttrMap) === null || _a === void 0 ? void 0 : _a.invalidateSize();
        }
    }
    catList_cullCategories() {
        if (!this.isView_List)
            return;
        if (!this.DOM.aggrGlyphs)
            return;
        this.DOM.aggrGlyphs
            .style("display", (ctrgry) => ctrgry.isVisible ? null : "none")
            .style("opacity", (ctrgry) => ctrgry.isVisible ? 1 : 0)
            .style("transform", (ctrgry) => ctrgry.isVisible ? `translate(0px,${ctrgry.posY}px)` : null);
        if (this.setAttrib && !this.setAttrib.block.pausePanning) {
            this.setAttrib.block.refreshSVGViewBox();
        }
    }
    refreshConfigRowCount() {
        var _a, _b, _c;
        (_a = this.DOM.summaryControls) === null || _a === void 0 ? void 0 : _a.style("display", this.hasTextSearch() ? "block" : null);
        (_b = this.DOM.wrapper) === null || _b === void 0 ? void 0 : _b.classed("showMeasureAxis_2", this.hasTextSearch());
        (_c = this.DOM.catTextSearch) === null || _c === void 0 ? void 0 : _c.classed("active", this.hasTextSearch());
    }
    // ********************************************************************
    // Width
    // ********************************************************************
    get width_CatLabel() {
        return this.isVisible() ? this.panel.width_CatLabel : 0;
    }
    get width_CatMeasureLabel() {
        return this.isVisible() ? this.panel.width_CatMeasureLabel : 0;
    }
    get width_CatText() {
        return this.isVisible() ? this.panel.width_CatText : 0;
    }
    get width_CatBars() {
        return this.isVisible() ? this.panel.width_CatBars : 0;
    }
    refreshWidth() {
        if (!this.DOM.summaryCategorical)
            return;
        this.attrib.updateChartScale_Measure(); // refreshes viz axis if needed
        if (this.isView_List) {
            this.DOM.chartAxis_Measure.style("width", `${this.width_CatBars + 5}px`);
        }
        if (this.isView_Map && this.mapIsReady) {
            this.leafletAttrMap.invalidateSize();
        }
    }
    hasTextSearch() {
        return this._aggrs.length >= 15;
    }
    initDOM_CatTextSearch() {
        var me = this;
        this.DOM.catTextSearch = this.DOM.summaryControls
            .append("div")
            .attr("class", "textSearchBox catTextSearch hasLabelWidth");
        this.DOM.catTextSearch.append("span").attr("class", "far fa-search");
        this.DOM.catTextSearch
            .append("span")
            .attr("class", "fa fa-times-circle")
            .tooltip(i18n.ClearTextSearch)
            .on("click", () => this.attrib.summaryFilter.clearFilter());
        this.DOM.catTextSearchInput = this.DOM.catTextSearch
            .append("input")
            .attr("class", "textSearchInput")
            .attr("type", "text")
            .attr("placeholder", "...")
            .tooltip(i18n.Search)
            .on("keydown", (event) => event.stopPropagation())
            .on("keypress", (event) => event.stopPropagation())
            .on("keyup", (event) => event.stopPropagation())
            .on("input", function () {
            this.tippy.hide();
            if (this.timer)
                clearTimeout(this.timer);
            var x = this;
            this.timer = setTimeout(function () {
                me.attrib.unselectAllCategories();
                var query = [];
                // split the query by " character
                var processed = x.value.toLowerCase().split('"');
                processed.forEach((block, i) => {
                    if (i % 2 === 0) {
                        block.split(/\s+/).forEach((q) => query.push(q));
                    }
                    else {
                        query.push(block);
                    }
                });
                // Remove the empty strings
                query = query.filter((v) => v !== "");
                if (query.length > 0) {
                    me.DOM.catTextSearch.classed("showClear", true);
                    me._aggrs.forEach((_cat) => {
                        var catLabel = _cat.label.toString().toLowerCase();
                        var f = query.every((query_str) => {
                            if (catLabel.indexOf(query_str) !== -1) {
                                return true;
                            }
                            return false;
                        });
                        if (f) {
                            _cat.set_OR(me.attrib.summaryFilter.selected_OR);
                        }
                        else {
                            _cat.set_NONE();
                        }
                    });
                    // All categories are process, and the filtering state is set. Now, process the summary as a whole
                    if (me.attrib.summaryFilter.selectedCount_Total() === 0) {
                        me.skipTextSearchClear = true;
                        me.attrib.summaryFilter.clearFilter();
                        me.skipTextSearchClear = false;
                    }
                    else {
                        me.attrib.summaryFilter.how = "All";
                        me.attrib.noValueAggr.filtered = false;
                        me.attrib.summaryFilter.setFiltered();
                    }
                }
                else {
                    me.attrib.summaryFilter.clearFilter();
                }
            }, 750);
        });
    }
    clearCatTextSearch() {
        if (!this.hasTextSearch())
            return;
        if (this.skipTextSearchClear)
            return;
        if (!this.DOM.catTextSearch)
            return;
        this.DOM.catTextSearch.classed("showClear", false);
        this.DOM.catTextSearchInput.node().value = "";
    }
    // ********************************************************************
    // Managing in-display / visible categories
    // ********************************************************************
    isCatActive(ctgry) {
        if (!ctgry.usedAggr)
            return false;
        if (ctgry.isFiltered())
            return true;
        if (ctgry.recCnt('Active') !== 0)
            return true;
        if (!this.attrib.isFiltered())
            return ctgry.recCnt('Active') !== 0;
        if (this.viewType === "map")
            return ctgry.recCnt('Active') !== 0;
        // Hide if multiple options are selected and selection is and
        //        if(this.summaryFilter.selecttype==="SelectAnd") return false;
        // TO-DO: Figuring out non-selected, zero-active-item attribs under "SelectOr" is tricky!
        return true;
    }
    areAllCatsInDisplay() {
        return this.catCount_Active === this.catCount_InDisplay;
    }
    updateCats_IsActive() {
        this.catCount_Active = 0;
        this._aggrs.forEach((ctrgy) => {
            ctrgy.isActiveBefore = ctrgy.isActive;
            ctrgy.isActive = this.isCatActive(ctrgy);
            if (ctrgy.isActive)
                this.catCount_Active++;
        });
        if (this.attrib.catOrder_Fixed) {
            // if fixed, categories do not roll up on each other, the total count is still original count
            this.catCount_Active = this._aggrs.length;
        }
    }
    updateCats_IsVisible() {
        var maxVisibleNumCats = Math.ceil((this.scrollTop_cache + this._height_Categories) / this.heightCat);
        this._aggrs.forEach((ctgry) => {
            ctgry.isVisibleBefore = ctgry.isVisible;
            ctgry.isVisible = this.viewType === "map"
                ? true
                : ctgry.isActive &&
                    ctgry.orderIndex >= this.firstCatIndexInView &&
                    ctgry.orderIndex < maxVisibleNumCats;
        });
    }
    // ********************************************************************
    // Active / Compare visualizations
    // ********************************************************************
    vizSideBySide() {
        if (this.browser.stackedChart)
            return false;
        if (this.browser.activeComparisonsCount < 2)
            return false;
        if (!this.attrib.isComparedAttrib())
            return true;
        return this.attrib.isMultiValued && this.splitOnSelfCompare;
    }
    refreshViz_Active() {
        if (!this.isVisible())
            return;
        if (this.isView_Dropdown)
            return;
        if (!this.attrib.chartScale_Measure)
            return;
        if (this.isView_Map && this.mapIsReady) {
            this.catMap_refreshVis("Active");
            return;
        }
        if (this.isView_List) {
            var baseline = this.measureLineZero;
            this.refreshViz_Cache("Active", null);
            this.DOM.aggrGlyphs.classed("NoActiveRecords", (aggr) => aggr.Active.measure === 0);
            this.DOM.measure_Active.style("transform", (aggr) => `translate(${baseline + aggr.offset("Active")}px, ${this.height_bar_topGap}px) ` + `scale(${aggr.scale("Active")}, ${this.barHeight_Full})`);
            this.refreshMeasureLabelText("Active");
            this.refreshMeasureLabelPos("Active", -1);
        }
    }
    refreshViz_Compare(cT, curGroup, totalGroups, prevCts = []) {
        if (!this.isVisible())
            return;
        if (this.isView_Dropdown) {
            this.dropdown_refreshCategories(); // might change the assigned colors
            return;
        }
        this.refreshMeasureLabelText(cT);
        if (cT === "Compare_A") {
            this.refreshViz_NoValueAggr();
        }
        if (this.isView_List) {
            var baseline = this.measureLineZero;
            var _translateY = this.height_bar_topGap;
            var barHeight = this.barHeight_Full;
            // adjust position if sidebyside
            if (this.vizSideBySide()) {
                barHeight = barHeight / totalGroups;
                _translateY += barHeight * curGroup;
            }
            this.refreshViz_Cache(cT, prevCts);
            this.refreshMeasureLabelPos(cT, curGroup);
            var onlySelectedNoSplit = !this.browser.stackedChart &&
                this.attrib.isComparedAttrib() &&
                this.attrib.isMultiValued &&
                !this.splitOnSelfCompare;
            var _do = (scaleX) => {
                this.DOM["measure_" + cT].style("transform", (aggr) => {
                    if (onlySelectedNoSplit)
                        scaleX = aggr.compared === cT;
                    return `translate(${baseline + aggr.offset(cT)}px, ${_translateY}px) scale(${scaleX ? aggr.scale(cT) : 0}, ${barHeight})`;
                });
            };
            if (curGroup === totalGroups - 1 && this.browser.addedCompare) {
                _do(false); // sets scaleX to zero, - I believe this was for animation purposes
            }
            _do(true);
        }
        if (this.isView_Map && this.mapIsReady && this.attrib.vizActive(cT)) {
            if (this.attrib.isComparedAttrib() && !this.attrib.isMultiValued)
                return;
            this.catMap_refreshVis(cT);
        }
    }
    // Overwrites base class
    chartAxis_Measure_TickSkip() {
        var _a;
        var width = this.width_CatBars;
        var widthPerTick = 35;
        if (this.attrib.getPeakAggr(d3$e.max, "Active") > 100000) {
            widthPerTick += 12; // k,m etc
        }
        if (this.browser.percentBreakdown) {
            widthPerTick += 11; // %
        }
        else if (this.browser.measureFunc.get() !== "Count") {
            var unitName = (_a = this.browser.measureSummary.get()) === null || _a === void 0 ? void 0 : _a.unitName;
            if (unitName)
                widthPerTick += 2 + unitName.length * 9;
        }
        return width / widthPerTick;
    }
    showSetMatrix(v) {
        if (!this.isView_List && v === true) {
            return;
        }
        this.show_set_matrix = v;
        this.refreshShowSetMatrix();
    }
    hideSetMatrix() {
        this.showSetMatrix(false);
    }
    refreshShowSetMatrix() {
        var _a;
        (_a = this.DOM.root) === null || _a === void 0 ? void 0 : _a.classed("show_set_matrix", this.show_set_matrix);
        if (this.show_set_matrix) {
            this.attrib.showSetSummary();
        }
        else if (this.setAttrib) {
            this.attrib.setSortingOption("Active"); // back to dynamic order
            this.updateCatSorting(0); // no delay, animated
        }
    }
    initDOM(beforeDOM) {
        this.attrib.initializeAggregates();
        if (this.attrib.isEmpty())
            return false;
        if (this.DOM.inited)
            return true;
        this.insertRoot(beforeDOM);
        this.DOM.root
            .attr("viewType", this.viewType)
            .classed("hasMultiAnd", this.attrib.summaryFilter.selected_AND.length > 1)
            .classed("isMultiValued", this.attrib.isMultiValued)
            .classed("supportsSetMatrix", this.attrib.supportsSetMatrix)
            .attr("hasMap", this.attrib.catGeo !== null);
        this.DOM.summaryCategorical = this.DOM.wrapper
            .append("div")
            .attr("class", "summaryCategorical");
        if (!this.isView_Dropdown) {
            this.init_DOM_Cat();
        }
        this.setCollapsed(this.collapsed);
        this.DOM.inited = true;
        this.catViewAs(this.viewType);
        this.refreshShowSetMatrix();
        return true;
    }
    // ********************************************************************
    // Main block setup (header / root)
    // ********************************************************************
    insertHeader() {
        super.insertHeader();
        [
            [
                "summaryViewAs setMatrixButton",
                "ViewSetMatrix",
                "far fa-tags",
                () => this.showSetMatrix(!this.show_set_matrix),
            ],
            [
                "summaryViewAs summaryViewAs_list",
                "ViewAsList",
                "far fa-list-ul",
                () => this.catViewAs("list"),
            ],
            [
                "summaryViewAs summaryViewAs_map",
                "ViewAsMap",
                "fal fa-globe",
                () => this.catViewAs("map"),
            ],
        ].forEach((button) => {
            this.DOM.summaryIcons
                .append("span")
                .attr("class", button[0])
                .tooltip(i18n[button[1]], { placement: "bottom" })
                .on("click", button[3])
                .append("div")
                .attr("class", button[2]);
        });
    }
    // ********************************************************************
    // Filtering
    // ********************************************************************
    onClearFilter(forceUpdate) {
        var _a;
        this.attrib.noValueAggr.filtered = false;
        this.attrib.unselectAllCategories();
        this.clearCatTextSearch();
        if (forceUpdate && this.isView_Dropdown) {
            this.dropdown_refreshCategories();
        }
        (_a = this.DOM.root) === null || _a === void 0 ? void 0 : _a.classed("hasMultiAnd", false);
    }
    updateAfterFilter(refreshViz = true) {
        if (!this.isVisible()) {
            this.attrib.dirtySort = true;
            return;
        }
        if (this.isView_Dropdown) {
            if (!this.attrib.dirtySort)
                this.updateCatSorting_now();
            this.dropdown_refreshCategories();
            return;
        }
        this.refreshViz_NoValueAggr();
        this.refreshMeasureLabelText("Active");
        if (this.isView_Map) {
            this.attrib.updateChartScale_Measure(true); // skep refresh viz
            this.updateCats_IsActive();
            this.refreshViz_Active(); // maps can only visualize "active" selection.
            return;
        }
        if (this.show_set_matrix)
            this.attrib.dirtySort = true;
        if (!this.attrib.dirtySort)
            this.updateCatSorting();
        if (refreshViz) {
            this.attrib.updateChartScale_Measure(true); // skep refresh viz
            this.refreshViz_All();
        }
    }
    refreshLabelWidth() {
        if (!this.isVisible())
            return;
        if (!this.DOM.summaryCategorical)
            return;
        if (!this.isView_List)
            return;
        this.DOM.chartCatLabelResize.style("left", `${this.width_CatLabel}px`);
        this.DOM.summaryCategorical
            .selectAll(".hasLabelWidth")
            .style("width", `${this.width_CatLabel}px`);
        this.DOM.measureLabelGroup.style("width", `${this.width_CatMeasureLabel}px`);
        this.DOM.chartAxis_Measure.style("transform", `translateX(${this.width_CatText}px)`);
    }
    refreshScrollDisplayMore(bottomItem) {
        if (!this.isView_List) {
            return;
        }
        this.DOM.catSortButton.style("display", this._aggrs.length === 1 ? "none" : null);
        if (this.catCount_Active <= 4) {
            this.DOM.scroll_display_more.style("display", "none");
            return;
        }
        var below = this.catCount_Active - bottomItem;
        var moreTxt = `<span class='rowCount ${below ? " hasMore" : ""}'>${this.catCount_Active} ${i18n.Rows}</span>`;
        if (below > 0)
            moreTxt += ` <span class='belowCount'>${below} ${i18n.More} <span class='far fa-angle-double-down'></span></span>`;
        this.DOM.scroll_display_more.html(moreTxt);
    }
    removeCatGeo() {
        var _a, _b;
        if (this.viewType === "map") {
            this.catViewAs("list");
        }
        (_a = this.DOM.root) === null || _a === void 0 ? void 0 : _a.attr("hasMap", false);
        (_b = this.leafletAttrMap) === null || _b === void 0 ? void 0 : _b.remove();
        this.leafletAttrMap = null;
    }
    catMap_projectCategories() {
        if (!this.panel)
            return;
        // the following is temporary
        var missingRegions = [];
        this.DOM.measure_Active.attr("d", (ctgry, i, nodes) => {
            if (!ctgry._geo_) {
                missingRegions.push(ctgry.label);
                nodes[i].parentNode.style.display = "none";
                return;
            }
            return this.geoPath(ctgry._geo_);
        });
        this.DOM.root
            .select(".mapView-UnmatchedData")
            .classed("active", missingRegions.length > 0);
        this.DOM.measureLabel
            .attr("transform", (ctgry) => {
            const centroid = this.geoPath.centroid(ctgry._geo_);
            return `translate(${centroid[0]},${centroid[1]})`;
        })
            .style("display", (ctgry) => {
            const bounds = this.geoPath.bounds(ctgry._geo_);
            const width = Math.abs(bounds[0][0] - bounds[1][0]);
            return width < this.width_CatMeasureLabel ? "none" : "block";
        });
    }
    catMap_refreshBounds_Active() {
        this.mapBounds_Active = this.catMap_getBounds(true);
    }
    catMap_zoomToActive(fly = false) {
        if (this.attrib.mapInitView) {
            this.leafletAttrMap.setView(L.latLng(this.attrib.mapInitView[0], this.attrib.mapInitView[1]), this.attrib.mapInitView[2]);
            this.attrib.mapInitView = null;
            return;
        }
        if (fly) {
            this.leafletAttrMap.flyToBounds(this.mapBounds_Active, this.mapConfig.flyConfig);
        }
        else {
            this.leafletAttrMap.fitBounds(this.mapBounds_Active);
            // there's a bug that makes the map not set the bounds correctly first time
            //window.setTimeout(() => this.leafletAttrMap.fitBounds(this.mapBounds_Active), 100);
        }
    }
    catMap_setMaxBounds() {
        this.leafletAttrMap.setMaxBounds(this.catMap_getBounds());
    }
    catMap_getBounds(onlyActive = false) {
        const bs = [];
        // Insert the bounds for each record path into the bs
        this._aggrs.forEach((_cat) => {
            if (!_cat._geo_)
                return;
            if (onlyActive && !_cat.isActive)
                return;
            // get bounding box, cached in _geo_ property
            let b = _cat._geo_._bounds;
            if (b === undefined) {
                b = d3$e.geoBounds(_cat._geo_);
                if (isNaN(b[0][0])) {
                    b = null;
                }
                _cat._geo_._bounds = b;
            }
            if (b === null)
                return;
            const p1 = L.latLng(b[0][1], b[0][0]);
            const p2 = L.latLng(b[1][1], b[1][0]);
            bs.push(p1);
            bs.push(p2);
        });
        if (bs.length === 0) {
            return this.catMap_getBounds(false); // not only active.
        }
        return Util.addMarginToBounds(new L.latLngBounds(bs));
    }
    catMap_invertColorTheme(v) {
        if (v == null)
            v = !this.invertedColorTheme; // invert
        this.invertedColorTheme = v;
        if (this.mapColorScale) {
            this.mapColorScale.range(this.invertedColorTheme ? [9, 0] : [0, 9]);
            this.catMap_refreshColorScale();
            this.refreshViz_All();
            this.DOM.root
                .select(".editColorTheme.fa-adjust")
                .classed("rotatedY", this.invertedColorTheme);
        }
    }
    catMap_refreshColorScale() {
        if (!this.DOM.mapColorBlocks)
            return;
        let colorTheme = this.browser.colorTheme.getDiscrete(9);
        if (this.invertedColorTheme) {
            colorTheme = colorTheme.reverse();
        }
        this.DOM.mapColorBlocks
            .style("background-color", (d) => colorTheme[d])
            .style("transform", (d) => {
            var left = (100 * d) / 9;
            var right = (100 * (d + 1)) / 9;
            return ("translateX(" +
                left +
                "%) scaleX(" +
                Math.abs(right - left) / 100 +
                ")");
        });
    }
    catMap_prepView() {
        if (this.setAttrib)
            this.showSetMatrix(false);
        if (this.leafletAttrMap) {
            // The map view was already initialized
            this.leafletAttrMap.invalidateSize();
            this.DOM.aggrGroup = this.DOM.summaryCategorical.select(".catMap_SVG > .aggrGroup");
            this.refreshDOMcats();
            this.mapIsReady = true;
            //  No longer resetting the zoom after switching back to an already existing map.
            //  this.catMap_refreshBounds_Active();
            //  this.catMap_zoomToActive();
            this.catMap_projectCategories();
            this.refreshViz_Active();
            this.refreshViz_All();
            return;
        }
        this.mapConfig = Util.mergeConfig(Base.map, this.attrib.mapConfig || {});
        var me = this;
        this.leafletAttrMap = L.map(this.DOM.catMap_Base.node(), this.mapConfig.leafConfig)
            .addLayer(new L.TileLayer(this.mapConfig.tileTemplate, this.mapConfig.tileConfig))
            .on("viewreset", () => this.catMap_projectCategories())
            .on("movestart", function () {
            me.browser.DOM.root.classed("noPointerEvents", true);
            this._zoomInit_ = this.getZoom();
            me.DOM.catMap_SVG.style("opacity", 0.3);
        })
            .on("moveend", function () {
            me.browser.DOM.root.classed("noPointerEvents", false);
            me.DOM.catMap_SVG.style("opacity", null);
            if (this._zoomInit_ !== this.getZoom())
                me.catMap_projectCategories();
        });
        this.leafletAttrMap.attributionControl.setPosition("topright");
        this.geoPath = d3$e.geoPath().projection(d3$e.geoTransform({
            // Use Leaflet latLngToLayerPoint to implement a D3 geometric transformation.
            point: function (x, y) {
                var point = me.leafletAttrMap.latLngToLayerPoint(L.latLng(y, x));
                this.stream.point(point.x, point.y);
            },
        }));
        this.DOM.catMap_SVG = d3$e
            .select(this.leafletAttrMap.getPanes().overlayPane)
            .append("svg")
            .attr("xmlns", "http://www.w3.org/2000/svg")
            .attr("class", "catMap_SVG");
        // The fill pattern definition in SVG, used to denote geo-objects with no data.
        // http://stackoverflow.com/questions/17776641/fill-rect-with-pattern
        this.DOM.catMap_SVG
            .append("defs")
            .append("pattern")
            .attr("id", "diagonalHatch")
            .attr("patternUnits", "userSpaceOnUse")
            .attr("width", 4)
            .attr("height", 4)
            .append("path")
            .attr("d", "M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2")
            .attr("stroke", "gray")
            .attr("stroke-width", 1);
        // Add custom controls
        var X;
        X = this.DOM.summaryCategorical
            .append("div")
            .attr("class", "visViewControl ViewControlGroup");
        X.append("div")
            .attr("class", "visViewControlButton far fa-plus")
            .tooltip(i18n.ZoomIn)
            .on("click", () => this.leafletAttrMap.zoomIn());
        X.append("div")
            .attr("class", "visViewControlButton far fa-minus")
            .tooltip(i18n.ZoomOut)
            .on("click", () => this.leafletAttrMap.zoomOut());
        X.append("div")
            .attr("class", "visViewControlButton viewFit far fa-expand-arrows-alt")
            .tooltip(i18n.ZoomToFit)
            .on("click", (event) => {
            this.catMap_refreshBounds_Active();
            this.catMap_zoomToActive(true);
            event.preventDefault();
            event.stopPropagation();
        });
        X.append("div")
            .attr("class", "visViewControlButton mapView-UnmatchedData fa fa-exclamation")
            .tooltip(i18n.MissingLocations)
            .on("click", () => {
            var missingRegions = [];
            this._aggrs.forEach((_cat) => {
                if (_cat._geo_ === undefined)
                    missingRegions.push(_cat.label +
                        ` <span style='color: gray; font-weight:300; font-size: 0.9em;'>[${_cat.recCnt("Total")} ${this.browser.recordName}"]</span>`);
            });
            Modal.alert("The following regions do not appear on the map.<br><br>" +
                missingRegions.join(", ") +
                "<br><br>" +
                "<span style='font-size: 0.9em; color: gray; font-weight: 300'>" +
                "Please see the list of standard region names " +
                "<a style='color: gray; text-decoration: underline;' href='https://docs.google.com/spreadsheets/d/1DKNXwsJy6_Mdy3ofwbBIZeBGrxSItYOJXNZgLyu0IM4' target='_blank'>here</a>.<br>" +
                "If the place names above are misspelled, please update your data source.<span>").then(() => {
                this.DOM.root
                    .select(".mapView-UnmatchedData")
                    .classed("active", false);
            });
        });
        X = this.DOM.summaryCategorical
            .append("div")
            .attr("class", "mapGlyphColorSetting");
        var XX = X.append("div")
            .attr("class", "colorOptions")
            .classed("active", true);
        this.DOM.aggrGroup = this.DOM.catMap_SVG
            .append("g")
            .attr("class", "leaflet-zoom-hide aggrGroup");
        // This will insert map svg component
        this.insertCategoryGlyphs();
        this.DOM.mapColorScaleGroup = XX.append("div").attr("class", "mapColorScaleGroup");
        this.DOM.mapColorHighlightedValue = this.DOM.mapColorScaleGroup
            .append("span")
            .attr("class", "mapColorHighlightedValue fa fa-caret-down");
        this.DOM.mapColorBlocks = this.DOM.mapColorScaleGroup
            .append("div")
            .attr("class", "mapColorScaleBins")
            .selectAll(".mapColorThemeBin")
            .data([0, 1, 2, 3, 4, 5, 6, 7, 8])
            .enter()
            .append("div")
            .attr("class", "mapColorThemeBin")
            .tooltip("", { placement: "bottom" })
            .on("mouseenter", (event, d) => {
            var _minValue = Math.round(this.mapColorScale.invert(d));
            var _maxValue = Math.round(this.mapColorScale.invert(d + 1));
            event.currentTarget.tippy.setContent(Math.round(_minValue) + " &mdash; " + Math.round(_maxValue));
        });
        this.DOM.mapColorScaleGroup
            .append("div")
            .attr("class", "mapColorScaleLabels")
            .call((mapColorScaleLabels) => {
            mapColorScaleLabels
                .selectAll(".asdsd")
                .data([0, 3, 6, 9])
                .enter()
                .append("div")
                .attr("class", "mapColorScaleLabel")
                .style("left", (i) => (100 * i) / 9 + "%")
                .call((ticks) => {
                ticks.append("div").attr("class", "tickLine");
                ticks.append("div").attr("class", "tickLabel");
            });
        });
        this.DOM.mapColorScaleGroup
            .append("div")
            .attr("class", "measureDescrLabel");
        this.refreshMeasureDescrLabel();
        XX.append("div")
            .attr("class", "colorThemeOptions")
            .append("div")
            .attr("class", "editColorTheme far fa-adjust")
            .tooltip(i18n["InvertColorTheme"])
            .on("click", () => this.catMap_invertColorTheme());
        this.mapIsReady = true;
        this.leafletAttrMap.invalidateSize();
        this.catMap_refreshBounds_Active();
        this.catMap_zoomToActive();
        this.catMap_setMaxBounds();
        this.catMap_projectCategories();
        this.refreshMeasureLabelText("Active");
        this.refreshMapColorScaleBounds();
        this.refreshViz_Active();
        this.catMap_refreshColorScale();
        this.refreshHeight();
    }
    refreshMapColorScaleBounds(_type = "Active") {
        this.mapColorScale = this.attrib.chartScale_Measure
            .copy()
            .range(this.invertedColorTheme ? [9, 0] : [0, 9]);
        this.DOM.mapColorScaleGroup
            .selectAll(".mapColorScaleLabels > .mapColorScaleLabel > .tickLabel")
            .html((_d, i) => this.browser.getValueLabel(this.mapColorScale.invert((this.invertedColorTheme ? 3 - i : i) * 3)));
    }
    catMap_refreshVis(sT) {
        this.DOM.root.select(".editColorTheme").attr("data-color", sT);
        this.refreshMapColorScaleBounds(sT);
        var mapColorQuantize = d3$e
            .scaleQuantize()
            .domain([0, 9])
            .range(this.browser.colorTheme.getDiscrete(9));
        this.DOM.measure_Active.each((aggr, i, nodes) => {
            var _visV = this.browser.getChartValue(aggr, sT);
            if (aggr[sT].recCnt === 0)
                _visV = null;
            var DOM = nodes[i];
            var _fill = "url(#diagonalHatch)";
            var _stroke = "#111111";
            if (_visV != null) {
                _fill = mapColorQuantize(this.mapColorScale(_visV)).toString();
                _stroke = d3$e.hsl(_fill).l > 0.5 ? "#111111" : "#EEEEEE";
            }
            DOM.style.fill = _fill;
            DOM.style.stroke = _stroke;
            DOM.classList[_visV == null ? "add" : "remove"]("noData");
        });
    }
    // ********************************************************************
    // List
    // ********************************************************************
    list_prepView() {
        this.DOM.aggrGroup = this.DOM.aggrGroup_list;
        this.attrib.updateChartScale_Measure(true);
        this.insertCategoryGlyphs();
        if (this.heightRow_category_dirty)
            this.refreshHeight_Category();
        this.updateCats_IsActive();
        this.updateCatSorting_now();
        this.refreshLabelWidth();
        this.refreshViz_All();
        this.refreshHeight();
        this.refreshLabelWidth();
        this.DOM.measureLabel.style("display", null); // default is visible
    }
    init_DOM_Cat() {
        this.DOM.summaryControls = this.DOM.summaryCategorical
            .append("div")
            .attr("class", "summaryControls");
        this.initDOM_CatTextSearch();
        this.refreshConfigRowCount();
        this.DOM.catChart = this.DOM.summaryCategorical
            .append("div")
            .attr("class", "catChart");
        this.DOM.aggrGroup = this.DOM.catChart
            .append("div")
            .attr("class", "aggrGroup")
            .on("mousedown", (event) => {
            event.stopPropagation();
            event.preventDefault();
        })
            .on("scroll", () => {
            if (Util.ignoreScrollEvents === true)
                return;
            this.scrollTop_cache = this.DOM.aggrGroup.node().scrollTop;
            this.DOM.chartCatLabelResize.style("top", "0px");
            this.firstCatIndexInView = Math.floor(this.scrollTop_cache / this.heightCat);
            this.refreshScrollDisplayMore(this.firstCatIndexInView + this.catCount_InDisplay);
            this.updateCats_IsVisible();
            this.catList_cullCategories();
            this.refreshMeasureLabelText("Active");
        });
        this.DOM.aggrGroup_list = this.DOM.aggrGroup;
        this.DOM.catMap_Base = this.DOM.catChart
            .append("div")
            .attr("class", "catMap_Base");
        // This makes sure that the (scrollable) div height is correctly set to visible number of categories
        this.DOM.chartBackground = this.DOM.aggrGroup
            .append("span")
            .attr("class", "chartBackground");
        this.DOM.chartCatLabelResize = this.DOM.catChart
            .append("span")
            .attr("class", "chartCatLabelResize dragWidthHandle")
            .tooltip(i18n["Adjust Label Width"])
            .on("mousedown", (event) => {
            var initWidth = this.width_CatLabel - d3$e.pointer(event, d3$e.select("body").node())[0];
            this.browser.activateWidthDrag(this.panel.DOM.root.node(), event, (event2) => {
                this.panel.width_CatText =
                    initWidth +
                        d3$e.pointer(event2, d3$e.select("body").node())[0] +
                        this.width_CatMeasureLabel;
            });
        });
        this.insertChartAxis_Measure(this.DOM.catChart);
        this.DOM.belowCatChart = this.DOM.summaryCategorical
            .append("div")
            .attr("class", "belowCatChart catSummary_ListOnly hasLabelWidth")
            .style("height", Base.height_CatBottom - 1 + "px"); // for some reason, chrome needs 1 more pixel for categories
        this.initDOM_CatSortButton();
        this.DOM.scroll_display_more = this.DOM.belowCatChart
            .append("div")
            .attr("class", "scroll_display_more")
            .on("click", () => Util.scrollToPos_do(this.DOM.aggrGroup, this.DOM.aggrGroup.node().scrollTop + this.heightCat));
        this.DOM.belowCatChart.append("div").attr("class", "gap");
        // move noValueAggr under belowChart
        // TODO: Fix. If it's map view or dropdown view, it shouldn't be moved under this dom element
        this.DOM.belowCatChart.node().appendChild(this.DOM.noValueAggr.node());
    }
    initDOM_CatSortButton() {
        this.DOM.catSortButton = this.DOM.belowCatChart
            .append("span")
            .attr("class", "catSortButton fa fa-sort catSummary_ListOnly") // alt icon: fa-bars
            .tooltip(i18n["Sorting"])
            .on("click", (event) => Modal.popupMenu(event, this.attrib.getSortMenuOpts(), this, {
            placement: "top-start",
        }));
    }
    insertCategoryGlyphs() {
        var me = this;
        if (this.isView_Dropdown) {
            this.dropdown_refreshCategories();
            return;
        }
        if (!this.DOM.aggrGroup)
            return;
        var aggrGlyphSelection = this.DOM.aggrGroup
            .selectAll(".aggrGlyph")
            .data(this._aggrs, (aggr) => aggr.id);
        var DOM_cats_new = aggrGlyphSelection
            .enter()
            .append(this.viewType == "list" ? "span" : "g")
            .attr("class", "aggrGlyph " + (this.viewType == "list" ? "cat" : "map") + "Glyph") // mapGlyph, catGlyph
            .tooltip((aggr) => aggr.getTooltipHTML(), {
            theme: "dark kshf-tooltip kshf-record",
            placement: "right",
            animation: "fade",
            followCursor: this.isView_Map,
            offset: [0, this.isView_Map ? 15 : 0],
            trigger: "manual",
            // don't show the tooltip if the categorical chart is made up of unique categories.
            onShow: () => !this.attrib.uniqueCategories(),
        })
            .on("mouseenter", function (_event, aggr) {
            if (me.browser.adjustMode)
                return;
            this.highlightTimeout = window.setTimeout(() => {
                this.highlightTimeout = null;
                this.classList.add("catMouseOver");
                me.attrib.onAggrHighlight(aggr);
                // Do not change.
                // If trigger is automated (not manual), mouse-over automatically shows the tooltip
                //  but, the highliht/compare setting may be old (invalid) because of the delay to apply it.
                // So, we need to keep this manual
                this.tippy.show();
            }, me.browser.movingMouseDelay);
        })
            .on("mouseleave", function (_event, aggr) {
            if (this.tippy) {
                this.tippy.hide();
            }
            if (me.browser.adjustMode)
                return;
            this.classList.remove("catMouseOver");
            if (this.highlightTimeout)
                window.clearTimeout(this.highlightTimeout);
            me.attrib.onAggrLeave(aggr);
        })
            .on("click", (event, aggr) => {
            if (this.browser.adjustMode)
                return;
            this.attrib.onAggrClick(event, aggr);
        });
        this.updateCats_IsVisible();
        if (this.isView_List) {
            DOM_cats_new.style("height", this.heightCat + "px").style("transform", "translateY(0px)");
            DOM_cats_new.append("span").attr("class", "catLabelGroup_BG hasLabelWidth");
            var domAttrLabel = DOM_cats_new.append("span").attr("class", "catLabelGroup hasLabelWidth");
            domAttrLabel
                .append("span")
                .attr("class", "filterButton far fa-filter")
                .tooltip(i18n.Filter)
                .on("click", (event, ctgry) => {
                const menuConfig = { name: "Filter", items: [] };
                let _only = true, _and = !ctgry.filtered_AND(), _or = !ctgry.filtered_OR(), _not = !ctgry.filtered_NOT(), _remove = ctgry.isFiltered();
                const _Or_And = this.attrib.summaryFilter.selected_OR.length > 0 ||
                    this.attrib.summaryFilter.selected_AND.length > 0;
                if (!this.attrib.isMultiValued) {
                    _only = !ctgry.filtered_AND();
                    _and = false;
                    _or = _or && _Or_And && !ctgry.filtered_AND();
                    _not = _not && (!_Or_And || ctgry.filtered_AND());
                }
                else {
                    _only = true;
                    _and = _and && _Or_And;
                    _or = _or && _Or_And;
                }
                const _label = `<span class='filterContextLabel'>${ctgry.label}</span>`;
                if (_remove) {
                    menuConfig.items.push({
                        id: "filterOption_Remove",
                        name: "<span class='filterContextOpt'>" + i18n.Clear + "</span>",
                        helparticle: "5e88e80a2c7d3a7e9aea63ed",
                        do: (_cat) => this.attrib.filterCategory(_cat, "NONE"),
                    });
                }
                if (_only) {
                    menuConfig.items.push({
                        id: "filterOption_Only",
                        name: `<span class='filterContextOpt'>${i18n.Only}</span> ${_label}`,
                        helparticle: "5e88e7bc2c7d3a7e9aea63e9",
                        do: (_cat) => {
                            this.attrib.noValueAggr.filtered = null;
                            this.attrib.summaryFilter
                                .selected_AndOrNot()
                                .forEach((_) => _.set_NONE());
                            this.attrib.filterCategory(_cat, "AND", "All");
                        },
                    });
                }
                if (_and) {
                    menuConfig.items.push({
                        id: "filterOption_And",
                        name: `<span class='filterContextOpt'>${i18n.And}</span> ${_label}` +
                            ` <span class='filterContextMultiple'>[${i18n.Multiple}]</span>`,
                        helparticle: "5e88e81a2c7d3a7e9aea63ee",
                        do: (_cat) => this.attrib.filterCategory(_cat, "AND"),
                    });
                }
                if (_or) {
                    menuConfig.items.push({
                        id: "filterOption_Or",
                        name: `<span class='filterContextOpt'>${i18n.Or}</span> ${_label}` +
                            ` <span class='filterContextMultiple'>[${i18n.Multiple}]</span>`,
                        helparticle: "5e88e7e22c7d3a7e9aea63ec",
                        do: (_cat) => this.attrib.filterCategory(_cat, "OR"),
                    });
                }
                if (_not) {
                    menuConfig.items.push({
                        id: "filterOption_Not",
                        name: "<span class='filterContextOpt'>" +
                            i18n.Not +
                            "</span> " +
                            _label,
                        helparticle: "5e88e7cf2c7d3a7e9aea63ea",
                        do: (_cat) => this.attrib.filterCategory(_cat, "NOT"),
                    });
                }
                Modal.popupMenu(event, menuConfig, ctgry, {
                    placement: "bottom-start",
                });
                event.stopPropagation();
                event.preventDefault();
            });
            this.insertAggrLockButton(domAttrLabel, "bottom");
            domAttrLabel.append("span").attr("class", "catLabelGap");
            domAttrLabel
                .append("span")
                .attr("class", "AndOrNot AndOrNot_And")
                .text(i18n.And);
            domAttrLabel
                .append("span")
                .attr("class", "AndOrNot AndOrNot_Or")
                .text(i18n.Or);
            domAttrLabel
                .append("span")
                .attr("class", "AndOrNot AndOrNot_Not")
                .text(i18n.Not);
            domAttrLabel
                .append("span")
                .attr("class", "catLabelOrder fa fa-bars")
                .tooltip(i18n["Reorder"])
                .on("mousedown", (event, ctgry) => {
                var catNode = event.currentTarget.parentNode.parentNode;
                var catGroupNode = event.currentTarget.parentNode.parentNode.parentNode;
                me.browser.DOM.root.classed("noPointerEvents", true);
                var srcIndex = ctgry.orderIndex;
                d3$e.select("body")
                    .on("mousemove.reordercat", function (event2) {
                    catNode.classList.add("draggedCategory");
                    var targetPos = Math.min(Math.max(d3$e.pointer(event2, catGroupNode)[1], 0), me.heightCat * (me.catCount_Active - 1));
                    var targetIndex = Math.min(Math.max(Math.round(targetPos / me.heightCat), 0), me.catCount_Active - 1);
                    var skip = { from: srcIndex, to: targetIndex };
                    me.updateCatSorting(0, true, skip); // zero-delay, animated
                    catNode.style.transform = `translate(0px, ${targetPos}px)`; // transition the moved cat directly
                })
                    .on("mouseup.reordercat", function (event3) {
                    catNode.classList.remove("draggedCategory");
                    var targetPos = Math.min(Math.max(d3$e.pointer(event3, catGroupNode)[1], 0), me.heightCat * (me.catCount_Active - 1));
                    var targetIndex = Math.min(Math.max(Math.round(targetPos / me.heightCat), 0), me.catCount_Active - 1);
                    var skip = { from: srcIndex, to: targetIndex, mult: undefined };
                    if (skip.from > skip.to) {
                        var _ = skip.to;
                        skip.to = skip.from;
                        skip.from = _;
                        skip.mult = 1;
                    }
                    else {
                        // from smaller than to
                        skip.mult = -1;
                    }
                    // update orderIndex!
                    ctgry.orderIndex = targetIndex;
                    me.DOM.aggrGlyphs
                        .filter((_cat) => _cat.label !== ctgry.label) // all but the moved one
                        .each((_cat) => {
                        if (_cat.orderIndex >= skip.from &&
                            _cat.orderIndex <= skip.to)
                            _cat.orderIndex += skip.mult;
                    });
                    me.attrib.pleaseSort = true;
                    // Save the ordering
                    me.attrib.setFixedCatOrder();
                    me.browser.DOM.root.classed("noPointerEvents", false);
                    d3$e.select("body")
                        .on("mousemove.reordercat", null)
                        .on("mouseup.reordercat", null);
                });
            });
            domAttrLabel
                .append("span")
                .attr("class", "catLabelEdit fa fa-pencil")
                .tooltip("")
                .on("mouseenter", (event, d) => {
                var info = "";
                if (me.attrib.catLabel_attr[d.id]) {
                    // Show original value
                    info = ` <span>(${d.id})</span>`;
                    if (event.shiftKey) {
                        event.currentTarget.tippy.setContent("+Shift : " + i18n.Reset + info);
                        return;
                    }
                }
                event.currentTarget.tippy.setContent(i18n.EditTitle + info);
            })
                .on("click", function (event, ctgry) {
                this.tippy.hide();
                if (event.shiftKey) {
                    delete me.attrib.catLabel_attr[ctgry.id];
                    this.nextSibling.innerHTML = purify.sanitize(ctgry.id);
                    return;
                }
                this.style.display = "none";
                this.previousSibling.style.display = "none";
                this.nextSibling.setAttribute("contenteditable", true);
                this.nextSibling.focus();
            });
            domAttrLabel
                .append("span")
                .attr("class", "catLabel")
                .html((ctgry) => ctgry.label)
                .on("focus", function () {
                this._initValue = purify.sanitize(this.innerHTML);
                document.execCommand("selectAll", false, null);
            })
                .on("blur", function () {
                this.removeAttribute("contenteditable");
                this.blur();
                this.previousSibling.style.display = "";
                this.previousSibling.previousSibling.style.display = "";
            })
                .on("keydown", function (event, ctgry) {
                if (event.keyCode === 27) {
                    // Escape key
                    // Do not apply the new label
                    this.blur();
                    this.innerHTML = purify.sanitize(this._initValue);
                    return;
                }
                if (event.key === "Enter") {
                    event.stopPropagation();
                    event.preventDefault();
                    var newLabel = purify.sanitize(this.innerHTML);
                    if (newLabel === "") {
                        this.innerHTML = purify.sanitize(this._initValue);
                        this.blur();
                        return;
                    }
                    ctgry.label = newLabel;
                    me.attrib.catLabel_attr[ctgry.id] = newLabel;
                    this.blur();
                }
            });
            var labelGroup = DOM_cats_new.append("div").attr("class", "measureLabelGroup");
            Base.Active_Compare_List.forEach((measureType) => {
                labelGroup
                    .append("span")
                    .attr("class", "measureLabel measureLabel_" + measureType);
            });
            var measureGroup = DOM_cats_new.append("div").attr("class", "measureGroup");
            Base.Total_Active_Compare_List.forEach((measureType) => {
                measureGroup
                    .append("span")
                    .attr("class", `measure_${measureType} bg_${measureType}`)
                    .on("mouseenter", (event, aggr) => {
                    aggr.DOM.aggrGlyph
                        .querySelector(".measureLabel_" + measureType)
                        .classList.add("forceShow");
                    if (Base.Compare_List.find((_) => _ === measureType)) {
                        this.browser.refreshAllMeasureLabels(measureType);
                    }
                    event.preventDefault();
                    event.stopPropagation();
                })
                    .on("mouseleave", (_event, aggr) => {
                    var labelDOM = aggr.DOM.aggrGlyph.querySelector(".measureLabel_" + measureType);
                    if (labelDOM)
                        labelDOM.classList.remove("forceShow");
                    if (Base.Compare_List.find((_) => _ === measureType)) {
                        this.browser.refreshAllMeasureLabels("Active");
                    }
                });
            });
            measureGroup.append("div").attr("class", "setMatrixLine");
        }
        else if (this.isView_Map) {
            DOM_cats_new.append("g")
                .attr("class", "measureGroup")
                .append("path")
                .attr("class", "measure_Active");
            // only "active" measure group right now
            // label on top of (after) all the rest (removed for now)
        }
        this.refreshDOMcats();
    }
    refreshMeasureLabelPos(sT = "Active", curGroup = 0) {
        if (!this.isVisible())
            return;
        if (!this.isView_List)
            return;
        if (sT === "Other")
            return;
        var _top = this.height_bar_topGap;
        var barHeight = this.barHeight_Full;
        let labelDOM = this.DOM["measureLabel_" + sT];
        if (this.attrib.stackedCompare && !this.panel.hiddenCatBars()) {
            const baseline = this.measureLineZero;
            const maxWidth = this.width_CatBars;
            const endOfBar = !this.browser.isCompared();
            labelDOM.each((aggr, i, nodes) => {
                let _width = aggr.scale(sT);
                let _left = baseline + aggr.offset(sT);
                let _right = _left + _width;
                let _hidden = this.browser.getMeasureValue(aggr, sT) == 0;
                if (!_hidden && this.browser.isCompared()) {
                    _hidden = aggr.scale(sT) < this.width_CatMeasureLabel - 4;
                }
                // label alignment
                let _labelAlign = Math.abs(_left - baseline) < 2
                    ? "left"
                    : Math.abs(_right - maxWidth) < 2 &&
                        this.browser.relativeBreakdown
                        ? "right"
                        : "middle";
                if (endOfBar) {
                    _width = this.width_CatMeasureLabel;
                    _left = Math.min(baseline + aggr.sumOffsetScale(sT), maxWidth - _width);
                    _right = _left + _width;
                    _labelAlign = _right + 10 < maxWidth ? "left" : "right";
                    _hidden = aggr.recCnt(sT) === 0;
                }
                nodes[i].classList[_hidden ? "add" : "remove"]("hidden");
                nodes[i].setAttribute("labelAlign", _labelAlign);
                nodes[i].style.width = _width + "px";
                nodes[i].style.transform = `translate(${_left}px, ${_top}px)`;
            });
        }
        else {
            if (this.vizSideBySide()) {
                barHeight = barHeight / this.browser.activeComparisonsCount;
                _top += barHeight * curGroup;
            }
            const onlySelectedNoSplit = !this.browser.stackedChart
                && this.attrib.isComparedAttrib()
                && this.attrib.isMultiValued
                && !this.splitOnSelfCompare;
            labelDOM
                .attr("labelAlign", null)
                .classed("hidden", (aggr) => {
                if (onlySelectedNoSplit)
                    return aggr.compared !== sT;
                return (barHeight < 12 ||
                    (this.attrib.isComparedAttrib() &&
                        !this.attrib.isMultiValued &&
                        (sT !== aggr.compared || this.browser.relativeBreakdown)));
            })
                .style("transform", `translateY(${_top}px)`)
                .style("width", null);
        }
        labelDOM.style("line-height", barHeight + "px");
    }
    refreshDOMcats() {
        this.DOM.aggrGlyphs = this.DOM.aggrGroup
            .selectAll(".aggrGlyph")
            .each((aggr, i, nodes) => {
            aggr.setAggrGlyph(nodes[i]);
        });
        this.DOM.measureLabelGroup =
            this.DOM.aggrGlyphs.selectAll(".measureLabelGroup");
        this.DOM.measureLabel = this.DOM.aggrGlyphs.selectAll(".measureLabel");
        Base.Active_Compare_List.forEach((t) => {
            this.DOM["measureLabel_" + t] = this.DOM.aggrGlyphs.selectAll(".measureLabel_" + t);
        });
        Base.Total_Active_Compare_List.forEach((t) => {
            this.DOM["measure_" + t] = this.DOM.aggrGlyphs.selectAll(".measure_" + t);
        });
        if (this.isView_List) {
            this.DOM.catLabel = this.DOM.aggrGlyphs.selectAll(".catLabel");
            this.DOM.lockButton = this.DOM.aggrGlyphs.selectAll(".lockButton");
            this.refreshHeight_Category_do();
        }
    }
    updateCatSorting_now() {
        this.updateCatSorting(0, false); // no delay, not animated
    }
    updateCatSorting(sortDelay = 1000, animate = true, skip = false) {
        if (this._aggrs.length === 0)
            return; // no aggregates to sort
        if (this.attrib.uniqueCategories() && !this.panel)
            return; // Nothing to sort...
        if (!this.browser.finalized)
            animate = false;
        this.updateCats_IsActive();
        if (!skip &&
            (sortDelay === 0 || !this.attrib.catOrder_Fixed || this.attrib.pleaseSort)) {
            this.attrib._sortCategories();
            // ************************************************
            // update orderIndex
            var lastRank = 0;
            this._aggrs.forEach((_cat) => {
                _cat.orderIndex = _cat.isActive ? lastRank++ : -lastRank - 1;
            });
        }
        this.updateCats_IsVisible();
        // No need to update UI if checks below fail
        if (!this.panel)
            return;
        if (!this.DOM.aggrGlyphs)
            return;
        if (!this.isView_List)
            return;
        // The rest deals with updating UI
        this.DOM.catChart.classed("catOrder_Fixed", this.attrib.catOrder_Fixed);
        if (!skip && this.setAttrib) {
            // need to handle some setAttrib updates when the categories are re-ordered
            var setAttrib = this.setAttrib;
            setAttrib.block.refreshRow();
            setAttrib.block.DOM.setPairGroup.attr("animate_position", false);
            setAttrib.block.refreshSetPair_Position();
            setTimeout(() => setAttrib.block.DOM.setPairGroup.attr("animate_position", true), 1000);
        }
        // Categories outside the view are set "invisible"
        // Her, we expand the background box. This makes the scroll bar visible.
        this.DOM.chartBackground.style("height", this.height_VisibleAttrib + "px");
        // scroll to top when re-sorted
        if (this.scrollTop_cache !== 0)
            Util.scrollToPos_do(this.DOM.aggrGroup, 0);
        this.refreshScrollDisplayMore(this.firstCatIndexInView + this.catCount_InDisplay);
        if (!animate) {
            this.DOM.aggrGlyphs
                .each((_cat) => {
                _cat.posX = 0;
            })
                .style("opacity", 1)
                .style("transform", (_cat) => _cat.transformPos);
            this.catList_cullCategories();
            return;
        }
        // Exectued only when categories are reordered through GUI
        if (skip) {
            var selfOrder = skip.from;
            // from is less than to (like, from 2 to 5 ): make 2,3,4 skip
            if (skip.from > skip.to) {
                var _ = skip.to;
                skip.to = skip.from;
                skip.from = _;
                skip.mult = 1;
            }
            else {
                skip.mult = -1;
            }
            this.DOM.aggrGlyphs
                .filter((ctgry) => ctgry.orderIndex !== selfOrder)
                .transition()
                .duration(sortDelay)
                .style("transform", (ctgry) => {
                var offset = ctgry.orderIndex >= skip.from && ctgry.orderIndex <= skip.to
                    ? this.heightCat * skip.mult
                    : 0;
                return `translate(${ctgry.posX}px, ${ctgry.posY + offset}px)`;
            });
            return;
        }
        var cats_NotActiveBeforeAndNow = this.DOM.aggrGlyphs.filter((ctgry) => !ctgry.isActiveBefore && !ctgry.isActive);
        var cats_Disappearing = this.DOM.aggrGlyphs.filter((ctgry) => ctgry.isActiveBefore && !ctgry.isActive);
        var cats_Appearing = this.DOM.aggrGlyphs.filter((ctgry) => !ctgry.isActiveBefore && ctgry.isActive);
        var cats_Active = this.DOM.aggrGlyphs.filter((ctgry) => ctgry.isActive);
        cats_NotActiveBeforeAndNow.style("display", "none");
        var xRemoveOffset = -100;
        // Disappear animation
        cats_Disappearing
            .transition()
            .duration(sortDelay)
            .on("end", function (ctgry) {
            this.style.opacity = 0;
            ctgry.posX = xRemoveOffset;
            this.style.transform = ctgry.transformPos;
        })
            .transition()
            .duration(1000)
            .on("end", function () {
            this.style.display = "none";
        });
        // Appear animation (initial position)
        cats_Appearing
            .transition()
            .duration(sortDelay)
            .on("end", (ctgry, i, nodes) => {
            var node = nodes[i];
            node.style.opacity = 0;
            node.style.display = null;
            ctgry.posX = xRemoveOffset;
            node.style.transform = ctgry.transformPos;
        });
        // Sort animation
        var perCatDelay = 30;
        cats_Active
            .style("display", null)
            .transition()
            .duration((_cat) => {
            if (_cat.isVisibleBefore && !_cat.isVisible)
                return sortDelay;
            var x = _cat.isActiveBefore
                ? 0
                : (this.catCount_InDisplay - 5) * perCatDelay; // appear animation is further delayed
            return (100 +
                sortDelay +
                x +
                Math.min(_cat.orderIndex, this.catCount_InDisplay + 2) * perCatDelay);
        })
            .on("end", (ctgry, i, nodes) => {
            ctgry.posX = 0;
            nodes[i].style.opacity = 1;
            nodes[i].style.transform = ctgry.transformPos;
        })
            .transition()
            .duration(250)
            .on("end", (ctgry, i, nodes) => {
            if (!(ctgry.isVisible || ctgry.isVisibleBefore)) {
                nodes[i].style.display = "none";
            }
        });
    }
    dropdown_prepView() {
        this.insertCategoryGlyphs();
    }
    dropdown_refreshCategories() {
        if (!this.DOM)
            return;
        if (!this.DOM.summaryCategorical)
            return;
        if (!this.inDashboard)
            return;
        if (!this.isVisible())
            return;
        import('./vendor.js').then(function (n) { return n.a4; }).then((Choices) => {
            var me = this; // callbacks set their own this context for choices library
            var cfg = {
                searchEnabled: this._aggrs.length > 15,
                searchResultLimit: 20,
                searchPlaceholderValue: i18n.Search,
                shouldSort: false,
                shouldSortItems: false,
                duplicateItemsAllowed: false,
                paste: false,
                removeItemButton: this.dropdown_type === "MultiSelect" ? true : false,
                placeholder: this.dropdown_type === "MultiSelect" ? true : "",
                placeholderValue: i18n.All,
                callbackOnCreateTemplates: () => ({
                    choice(classes, obj) {
                        const el = Choices.defaults.templates.choice.call(this, classes, obj);
                        const ctgry = me.attrib.catTable_id[obj.label];
                        if (ctgry === null || ctgry === void 0 ? void 0 : ctgry.compared) {
                            el.classList.add(ctgry.compared);
                        }
                        return el;
                    },
                    item(classes, obj) {
                        const el = Choices.defaults.templates.item.call(this, classes, obj, me.dropdown_type === "MultiSelect");
                        const ctgry = me.attrib.catTable_id[obj.label];
                        if (ctgry === null || ctgry === void 0 ? void 0 : ctgry.compared) {
                            el.classList.add("bg_" + ctgry.compared);
                        }
                        return el;
                    },
                }),
            };
            if (this.choicesUI) {
                this.choicesUI.destroy();
                this.DOM.ChoicesSelectDOM.remove();
            }
            this.DOM.ChoicesSelectDOM = this.DOM.summaryCategorical
                .append("select")
                .attr("multiple", this.dropdown_type === "MultiSelect" ? true : null);
            this.DOM.ChoicesSelectDOM.node().addEventListener("removeItem", (event) => {
                if (this.dropdown_type !== "MultiSelect")
                    return;
                var ctgry = event.detail.customProperties;
                if (!ctgry) {
                    // choices js: Update/remove after version update of library, feature just added.
                    ctgry = this.attrib.catTable_id[event.detail.label];
                }
                if (ctgry)
                    this.attrib.onAggrClick(event, ctgry);
            });
            this.DOM.ChoicesSelectDOM.node().addEventListener("choice", (_event) => {
                var selectedCat = this.attrib.summaryFilter.selected_AND[0];
                var _cat = _event.detail.choice.customProperties;
                // selecting filtered category again
                if (_cat && selectedCat && selectedCat.label === _cat.label)
                    return;
                if (_cat && _cat.recCnt("Active") === 0 && !this.attrib.isFiltered()) {
                    Modal.alert(i18n["Cannot select an option with no data in current filtered dashboard."]);
                    return;
                }
                window.setTimeout(() => {
                    if (this.dropdown_type === "MultiSelect") {
                        if (_cat) {
                            if (this.attrib.isFiltered()) {
                                this.attrib.filterCategory(_cat, this.attrib.isMultiValued ? "AND" : "OR", "All");
                            }
                            else {
                                this.attrib.filterCategory(_cat, "AND", "All");
                            }
                        }
                        else {
                            this.attrib.summaryFilter.clearFilter(_cat ? false : true);
                        }
                        return;
                    }
                    this.attrib.summaryFilter.clearFilter(_cat ? false : true);
                    if (_cat) {
                        this.attrib.filterCategory(_cat, "AND", "All");
                    }
                }, 10);
            });
            this.choicesUI = new Choices(this.DOM.ChoicesSelectDOM.node(), cfg);
            this.choicesUI.setChoices([
                // "All" option
                {
                    value: "-",
                    label: i18n.All,
                    selected: this.attrib.isFiltered() ? null : true,
                },
            ].concat(this._aggrs.map((aggr) => ({
                value: aggr.label,
                label: aggr.label,
                selected: !aggr.isFiltered() ? null : true,
                disabled: aggr.recCnt("Active") === 0 && !this.attrib.isFiltered()
                    ? true
                    : null,
                customProperties: aggr,
            }))), "value", "label", true);
        });
    }
}

/** -- */
class Aggregate_Category extends Aggregate {
    constructor(attrib, id) {
        super(attrib);
        // DOM elements
        this.DOM = {};
        this._label = null;
        // ********************************************************************
        // Filtering
        // ********************************************************************
        this.catFiltering = null;
        // ********************************************************************
        // Visualization parameters
        // ********************************************************************
        // Order index of the category among other categories in the attrib
        this.orderIndex = 0;
        /** -- Visual variable */
        this.posX = 0;
        // ********************************************************************
        // Geographic data cache
        // ********************************************************************
        this._geo_ = null;
        this._id = id;
    }
    get id() {
        return this._id;
    }
    set label(v) {
        this._label = v;
    }
    /** If a separate label has not been assigned, the id of the category. */
    get label() {
        return this._label || this._id;
    }
    get tooltipTitle() {
        return this.attrib.attribNameHTML;
    }
    get tooltipSkip1() {
        return !this.filtered_AND();
    }
    /** Overwrite */
    setAggrGlyph(v) {
        super.setAggrGlyph(v);
        this.refreshCatDOMSelected();
    }
    isFiltered() {
        return this.catFiltering !== null;
    }
    filtered_NOT() {
        return this.catFiltering === "NOT";
    }
    filtered_AND() {
        return this.catFiltering === "AND";
    }
    filtered_OR() {
        return this.catFiltering === "OR";
    }
    set_NONE() {
        if (this.inList)
            this.inList.splice(this.inList.indexOf(this), 1);
        this.catFiltering = null;
        this.refreshCatDOMSelected();
    }
    set_NOT(l) {
        if (this.filtered_NOT())
            return;
        this.catFiltering = "NOT";
        this.insertToList(l);
    }
    set_AND(l) {
        if (this.filtered_AND())
            return;
        this.catFiltering = "AND";
        this.insertToList(l);
    }
    set_OR(l) {
        if (this.filtered_OR())
            return;
        this.catFiltering = "OR";
        this.insertToList(l);
    }
    /** -- */
    unselectAggregate() {
        var _a;
        super.unselectAggregate();
        if (this.locked)
            return;
        (_a = this.DOM.matrixRow) === null || _a === void 0 ? void 0 : _a.removeAttribute("selection");
    }
    // ********************************************************************
    // Export
    // ********************************************************************
    exportAggregateInfo() {
        return {
            id: this.id,
        };
    }
    get posY() {
        return this.orderIndex * this.attrib.barHeight.get();
    }
    get transformPos() {
        return `translate(${this.posX}px, ${this.posY}px)`;
    }
    /** -- */
    insertToList(l) {
        if (this.inList)
            this.inList.splice(this.inList.indexOf(this), 1);
        this.inList = l;
        l.push(this);
        this.refreshCatDOMSelected();
    }
    /** -- */
    refreshCatDOMSelected() {
        var _a, _b;
        if (!this.catFiltering) {
            (_a = this.DOM.aggrGlyph) === null || _a === void 0 ? void 0 : _a.removeAttribute("catFiltered");
        }
        else {
            (_b = this.DOM.aggrGlyph) === null || _b === void 0 ? void 0 : _b.setAttribute("catFiltered", this.catFiltering);
        }
    }
}

/** -- */
class Aggregate_SetPair extends Aggregate {
    constructor(attrib, set_1, set_2) {
        super(attrib);
        this.mst_distance = 0;
        this.set_1 = set_1;
        this.set_2 = set_2;
    }
    similarityScore() {
        var size_and = this.measure("Active");
        if (size_and === 0)
            return 0;
        var size_A = this.set_1.measure("Active");
        var size_B = this.set_2.measure("Active");
        return size_and / Math.min(size_A, size_B);
    }
    get label() {
        return `${this.set_1.label}<br> &amp; ${this.set_2.label}`;
    }
    exportAggregateInfo() {
        return {};
    }
}

const d3$d = {
    select,
    pointer,
    max,
    format,
    easeLinear: linear$1,
    interpolate,
    interpolateHsl,
    rgb,
};
class Block_Set extends Block {
    constructor(attrib) {
        super(attrib);
        // ********************************************************************
        // Radius / diameter
        // ********************************************************************
        this.setPairDiameter = 0;
        // ********************************************************************
        // Maximum active values
        // ********************************************************************
        this._maxSetPairAggr_Active = 0;
        this.gridPan_x = 0;
        this.pausePanning = false;
        this.panel = attrib.setListAttrib.block.panel;
    }
    // ********************************************************************
    // Shorthand
    // ********************************************************************
    get setPairs() {
        return this.attrib.setPairs;
    }
    get setListSummary() {
        return this.attrib.parent;
    }
    get rowHeight() {
        return this.setListSummary.barHeight.get();
    }
    /** -- */
    get setPairCount_Total() {
        return (this.attrib.sets.length * (this.attrib.sets.length - 1)) / 2;
    }
    get popupSide() {
        return this.setListSummary.block.panel.name === "left" ? "right" : "left";
    }
    updateSetPairDiameter() {
        this.setPairDiameter = this.rowHeight - 2;
    }
    /** Shorthand - half of diameter */
    get setPairRadius() {
        return this.setPairDiameter / 2;
    }
    /** -- */
    updateMaxAggr_Active() {
        this._maxSetPairAggr_Active = d3$d.max(this.setPairs, (aggr) => aggr.measure("Active"));
    }
    /** -- */
    getCliqueSizeRatio(setPair) {
        return this._maxSetPairAggr_Active === 0
            ? 0
            : Math.sqrt(setPair.measure("Active") / this._maxSetPairAggr_Active);
    }
    /** -- */
    usingFullSizeGlyph() {
        return this.browser.relativeBreakdown || this.browser.dependentBreakdown;
    }
    /** -- */
    setCollapsed(v) {
        this.setListSummary.block.showSetMatrix(v !== true);
    }
    // ********************************************************************
    // Height and width management
    // ********************************************************************
    /** always has static height */
    hasStaticHeight() {
        return true;
    }
    get height_Content() {
        return this.setListSummary.block.height_Content;
    }
    get height_RangeMin() {
        return this.setListSummary.block.height_RangeMin;
    }
    get height_RangeMax() {
        return this.setListSummary.block.height_RangeMax;
    }
    getHeight() {
        return this.setListSummary.block.height_Categories;
    }
    setHeight(targetHeight) {
        this.setListSummary.block.setHeight(targetHeight);
    }
    refreshHeight() {
        if (!this.isVisible())
            return;
        this.updateSetPairDiameter();
        this.DOM.chartRoot.attr("show_gridlines", this.rowHeight > 15);
        this.DOM.setPairGroup.attr("animate_position", false);
        this.refreshRow();
        this.refreshSetPair_Background();
        this.refreshSetPair_Position();
        this.refreshViz_All();
        this.refreshSetPair_Strength();
        setTimeout(() => this.DOM.setPairGroup.attr("animate_position", true), 1000);
    }
    /** -- */
    getWidth() {
        return this.browser.panels.middle.width_Real + Base.width_PanelGap;
    }
    /** -- */
    refreshWidth() {
        this.refreshWindowSize();
        if (this.popupSide === "left") {
            this.refreshRow_LineWidths();
            this.refreshSetPair_Position();
        }
    }
    initDOM(beforeDOM = null) {
        // Inserts the DOM root under the setListSummary so that the matrix view is attached...
        this.DOM.root = this.setListSummary.block.DOM.root
            .insert("div", ":first-child")
            .attr("class", "kshfSummary setPairSummary")
            .attr("data-popupSide", this.popupSide);
        // Use keshif's standard header
        this.insertHeader();
        this.DOM.chartRoot = this.DOM.wrapper
            .append("span")
            .attr("class", "Summary_Set")
            .attr("show_gridlines", true);
        this.insertSummaryControls();
        this.DOM.setMatrixSVG = this.DOM.chartRoot
            .append("svg")
            .attr("xmlns", "http://www.w3.org/2000/svg")
            .attr("class", "setMatrix");
        /** BELOW THE MATRIX **/
        this.DOM.belowMatrix = this.DOM.chartRoot
            .append("div")
            .attr("class", "belowMatrix");
        this.DOM.pairCount = this.DOM.belowMatrix
            .append("span")
            .attr("class", "pairCount matrixInfo");
        this.DOM.pairCount_Text = this.DOM.pairCount
            .append("span")
            .attr("class", "pairCount_Text")
            .html(`<i class='fa fa-circle' style='color: #b1bdc5;'></i> 
      ${this.setPairs.length} ${i18n.Pairs} (${Math.round((100 * this.setPairs.length) / this.setPairCount_Total)}%)`);
        this.DOM.subsetCount = this.DOM.belowMatrix
            .append("span")
            .attr("class", "subsetCount matrixInfo");
        this.DOM.subsetCount.append("span").attr("class", "circleeee borrderr");
        this.DOM.subsetCount_Text = this.DOM.subsetCount
            .append("span")
            .attr("class", "subsetCount_Text");
        this.DOM.strengthControl = this.DOM.belowMatrix
            .append("span")
            .attr("class", "strengthControl matrixInfo")
            .tooltip("Cell color shows strength (ratio of shared elements) between categories.");
        // ******************* STRENGTH CONFIG
        this.DOM.strengthControl
            .append("span")
            .attr("class", "strengthLabel")
            .text(i18n.Weak);
        this.DOM.strengthControl
            .append("span")
            .attr("class", "strengthText")
            .text(i18n.Strength);
        this.DOM.strengthControl
            .append("span")
            .attr("class", "strengthLabel")
            .text(i18n.Strong);
        // invisible background - Used for panning
        this.DOM.setMatrixBackground = this.DOM.setMatrixSVG
            .append("rect")
            .attr("class", "setMatrixBackground")
            .attr("x", 0)
            .attr("y", 0)
            .style("fill-opacity", "0")
            .on("mousedown", (event) => {
            this.browser.DOM.pointerBlock.attr("active", "");
            this.browser.DOM.root.attr("pointerEvents", false);
            var mouseInitPos = d3$d.pointer(event, this.browser.DOM.root.node());
            var gridPan_x_init = this.gridPan_x;
            // scroll the setlist summary too...
            var scrollDom = this.setListSummary.block.DOM.aggrGroup.node();
            var initScrollPos = scrollDom.scrollTop;
            this.getWidth();
            this.getHeight();
            var initT = this.setListSummary.block.scrollTop_cache;
            Math.min(-initT - this.gridPan_x, 0);
            this.pausePanning = true;
            d3$d.select("body")
                .on("mousemove", (event2) => {
                var mouseMovePos = d3$d.pointer(event2, this.browser.DOM.root.node());
                var difX = mouseMovePos[0] - mouseInitPos[0];
                var difY = mouseMovePos[1] - mouseInitPos[1];
                if (this.popupSide === "right")
                    difX *= -1;
                this.gridPan_x = gridPan_x_init + difX + difY;
                //this.gridPan_x = Math.min(this.getWidth(),gridPan_x_init+difX+difY);
                this.refreshSVGViewBox();
                scrollDom.scrollTop = Math.max(0, initScrollPos - difY);
                event2.preventDefault();
                event2.stopPropagation();
            })
                .on("mouseup", (event3) => {
                this.pausePanning = false;
                this.browser.DOM.root.attr("pointerEvents", null);
                this.browser.DOM.pointerBlock.attr("active", null);
                this.refreshLabel_Vert_Show();
                d3$d.select("body").on("mousemove", null).on("mouseup", null);
                event3.preventDefault();
                event3.stopPropagation();
            });
            event.preventDefault();
            event.stopPropagation();
        });
        this.DOM.setMatrixSVG
            .append("g")
            .attr("class", "rows")
            .style("transform", "translateY(0.5px)"); // adjusting to match to list-view on the side on retina displays.
        this.DOM.setPairGroup = this.DOM.setMatrixSVG
            .append("g")
            .attr("class", "aggrGroup setPairGroup")
            .attr("animate_position", true);
        this.insertRows();
        this.insertSetPairs();
        this.updateSetPairDiameter();
        this.refreshRow();
        this.refreshSetPair_Background();
        this.refreshSetPair_Position();
        this.refreshSetPair_Containment();
        this.refreshViz_Axis();
        this.refreshViz_Active();
        this.refreshViz_Compare_All();
        this.DOM.inited = true;
        return true;
    }
    /** -- */
    insertSummaryControls() {
        this.DOM.summaryControls = this.DOM.chartRoot
            .append("div")
            .attr("class", "summaryControls")
            .style("height", this.setListSummary.block.height_Config + 1 + "px");
        this.DOM.scaleLegend_SVG = this.DOM.summaryControls
            .append("svg")
            .attr("class", "sizeLegend")
            .attr("xmlns", "http://www.w3.org/2000/svg");
        this.DOM.legendHeader = this.DOM.scaleLegend_SVG
            .append("text")
            .attr("class", "legendHeader")
            .text("#");
        this.DOM.legend_Group = this.DOM.scaleLegend_SVG.append("g");
    }
    /** -- */
    insertRows() {
        var newRows = this.DOM.setMatrixSVG
            .select("g.rows")
            .selectAll("g.row")
            .data(this.attrib.sets, (aggr) => aggr.id)
            .enter()
            .append("g")
            .attr("class", "row")
            .each((aggr, i, nodes) => {
            aggr.DOM.matrixRow = nodes[i];
        })
            .on("mouseenter", (_event, aggr) => this.setListSummary.onAggrHighlight(aggr))
            .on("mouseleave", (_event, aggr) => this.setListSummary.onAggrLeave(aggr));
        // tmp is used to parse html text
        var tmp = document.createElement("div");
        newRows
            .append("line")
            .attr("class", "line line_vert")
            .attr("x1", 0)
            .attr("y1", 0)
            .attr("y1", 0)
            .attr("y2", 0);
        newRows
            .append("text")
            .attr("class", "catLabel label_horz")
            .style("font-size", this.setListSummary.block.catLabelFontSize + "px")
            .text((aggr) => {
            tmp.innerHTML = aggr.label;
            return tmp.textContent || tmp.innerText || "";
        })
            .on("click", (_event, aggr) => {
            this.setListSummary.filterCategory(aggr, "AND");
        });
        newRows
            .append("line")
            .attr("class", "line line_horz")
            .attr("x1", 0)
            .attr("y1", 0)
            .attr("y2", 0);
        newRows
            .append("text")
            .attr("class", "catLabel label_vert")
            .style("font-size", this.setListSummary.block.catLabelFontSize + "px")
            .text((aggr) => {
            tmp.innerHTML = aggr.label;
            return tmp.textContent || tmp.innerText || "";
        })
            .attr("y", -4);
        tmp.remove();
        this.DOM.setRows = this.DOM.setMatrixSVG.selectAll("g.rows > g.row");
        this.DOM.line_vert = this.DOM.setMatrixSVG.selectAll("g.rows > g.row > line.line_vert");
        this.DOM.line_horz = this.DOM.setMatrixSVG.selectAll("g.rows > g.row > line.line_horz");
        this.DOM.line_horz_label = this.DOM.setMatrixSVG.selectAll("g.rows > g.row > text.label_horz");
        this.DOM.line_vert_label = this.DOM.setMatrixSVG.selectAll("g.rows > g.row > text.label_vert");
    }
    /** -- */
    refreshViz_Active() {
        this.DOM.aggrGlyphs.attr("activesize", (aggr) => aggr.measure("Active"));
        this.DOM.measure_Active
            .transition()
            .ease(d3$d.easeLinear)
            .duration(500)
            .attr("r", this.usingFullSizeGlyph()
            ? (setPair) => this.setPairRadius + (setPair.subt ? -1 : 0)
            : (setPair) => this.getCliqueSizeRatio(setPair) * this.setPairRadius);
    }
    /** -- */
    refreshViz_Compare(cT, curGroup, totalGroups, prevCts) {
        var strokeWidth = (_aggr) => 0;
        var aggrValue = (aggr, sT) => aggr.ratioToActive(sT);
        var usingFullSizeGlyph = this.usingFullSizeGlyph();
        if (!this.attrib.stackedCompare) {
            strokeWidth = (aggr) => (this.setPairRadius / totalGroups) *
                (usingFullSizeGlyph ? 1 : this.getCliqueSizeRatio(aggr));
            prevCts = [];
        }
        if (this.browser.dependentBreakdown) {
            aggrValue = (aggr, sT) => aggr[sT].measure /
                (this.browser.allRecordsAggr[cT].measure || 10000000000000);
        }
        this.DOM["measure_" + cT]
            .style("stroke-width", strokeWidth)
            .transition()
            .ease(d3$d.easeLinear)
            .duration(curGroup === totalGroups - 1 && this.browser.addedCompare ? 500 : 0)
            .attrTween("d", (aggr, i, nodes) => {
            const DOM = nodes[i];
            const offset = prevCts.reduce((accum, sT) => accum + aggrValue(aggr, sT), 0);
            const angleInterp = d3$d.interpolate(DOM._currentPreviewAngle, aggrValue(aggr, cT));
            const r = this.setPairRadius *
                (usingFullSizeGlyph ? 1 : this.getCliqueSizeRatio(aggr)) -
                (this.attrib.stackedCompare
                    ? 0
                    : (curGroup + 0.5) * strokeWidth(aggr)); // side-by-side radius adjust
            return (t) => {
                const newAngle = angleInterp(t);
                DOM._currentPreviewAngle = newAngle;
                return Util.getPieSVGPath(offset, newAngle, r, !this.attrib.stackedCompare);
            };
        });
    }
    chartAxis_Measure_TickSkip() {
        throw new Error("Method not implemented.");
    }
    /** -- */
    updateAfterFilter(refreshViz) {
        if (!this.isVisible())
            return;
        this.updateMaxAggr_Active();
        this.refreshViz_All();
        this.refreshViz_NoValueAggr();
        this.DOM.setRows.style("opacity", (row) => row.Active.measure > 0 ? 1 : 0.3);
        this.refreshSetPair_Containment();
    }
    /** Does not work with Avg pair */
    refreshSetPair_Containment() {
        var numOfSubsets = 0;
        this.DOM.aggrGlyphs
            .each((setPair) => {
            var setPair_itemCount = setPair.Active.measure;
            var set_1_itemCount = setPair.set_1.Active.measure;
            var set_2_itemCount = setPair.set_2.Active.measure;
            if (setPair_itemCount === set_1_itemCount ||
                setPair_itemCount === set_2_itemCount) {
                numOfSubsets++;
                setPair.subset =
                    set_1_itemCount === set_2_itemCount ? "equal" : "proper";
            }
            else {
                setPair.subset = "";
            }
        })
            .classed("isSubset", (setPair) => setPair.subset !== "");
        this.DOM.subsetCount.style("display", numOfSubsets === 0 ? "none" : null);
        this.DOM.subsetCount_Text.text(numOfSubsets);
        this.refreshSetPair_Strength();
    }
    /** -- */
    onSetPairEnter(aggr) {
        var _a, _b;
        (_a = aggr.set_1.DOM.matrixRow) === null || _a === void 0 ? void 0 : _a.setAttribute("selection", "selected");
        (_b = aggr.set_2.DOM.matrixRow) === null || _b === void 0 ? void 0 : _b.setAttribute("selection", "selected");
        this.browser.setSelect_Compare(aggr);
    }
    /** -- */
    onSetPairLeave(aggr) {
        var _a, _b;
        (_a = aggr.set_1.DOM.matrixRow) === null || _a === void 0 ? void 0 : _a.removeAttribute("selection");
        (_b = aggr.set_2.DOM.matrixRow) === null || _b === void 0 ? void 0 : _b.removeAttribute("selection");
        this.browser.clearSelect_Compare();
        this.browser.refreshAllMeasureLabels("Active");
    }
    /** -- */
    refreshSetPair_Strength() {
        var strengthColor = d3$d.interpolateHsl(d3$d.rgb(169, 181, 190), d3$d.rgb(232, 235, 238));
        let _maxSimilarity = d3$d.max(this.setPairs, (aggr) => aggr.similarityScore());
        this.DOM.setPairBackground
            .style("fill", (setPair) => strengthColor(setPair.similarityScore() / _maxSimilarity))
            .each((setPair, i, nodes) => {
            var _DOM = nodes[i];
            // border
            if (setPair.subset === "")
                return;
            if (setPair.subset === "equal") {
                _DOM.style.strokeDasharray = "";
                _DOM.style.strokeDashoffset = "";
                return;
            }
            var halfCircle = (this.setPairRadius - 1) * Math.PI;
            _DOM.style.strokeDasharray = halfCircle + "px";
            // rotate halfway
            var i1 = setPair.set_1.orderIndex;
            var i2 = setPair.set_2.orderIndex;
            var c1 = setPair.set_1.Active.measure;
            var c2 = setPair.set_2.Active.measure;
            if ((i1 < i2 && c1 < c2) || (i1 > i2 && c1 > c2))
                halfCircle = halfCircle / 2;
            _DOM.style.strokeDashoffset = halfCircle + "px";
        });
    }
    /** -- */
    insertSetPairs() {
        var me = this;
        var newCliques = this.DOM.setMatrixSVG
            .select("g.setPairGroup")
            .selectAll("g.setPairGlyph")
            .data(this.setPairs, (_, i) => i)
            .enter()
            .append("g")
            .attr("class", "aggrGlyph setPairGlyph")
            .each((d, i, nodes) => {
            d.setAggrGlyph(nodes[i]);
        })
            .tooltip((aggr) => aggr.getTooltipHTML(), {
            theme: "dark kshf-tooltip kshf-record",
            placement: "right",
            animation: "fade",
            boundary: "window",
            trigger: "manual",
        })
            .on("mouseenter", (event, aggr) => {
            if (me.browser.adjustMode)
                return;
            var DOM = event.currentTarget;
            if (DOM.highlightTimeout)
                window.clearTimeout(DOM.highlightTimeout);
            DOM.highlightTimeout = window.setTimeout(() => {
                DOM.tippy.show();
                this.onSetPairEnter(aggr);
            }, me.browser.movingMouseDelay);
        })
            .on("mouseleave", (event, aggr) => {
            var DOM = event.currentTarget;
            if (DOM.highlightTimeout)
                window.clearTimeout(DOM.highlightTimeout);
            DOM.tippy.hide();
            this.onSetPairLeave(aggr);
        })
            .on("click", (_event, aggr) => {
            this.setListSummary.filterCategory(aggr.set_1, "AND");
            this.setListSummary.filterCategory(aggr.set_2, "AND");
        });
        newCliques
            .append("rect")
            .attr("class", "setPairBackground")
            .attr("rx", 3)
            .attr("ry", 3);
        var measureGroup = newCliques.append("g").attr("class", "measureGroup");
        measureGroup
            .append("circle")
            .attr("class", "measure_Active")
            .attr("cx", 0)
            .attr("cy", 0)
            .attr("r", 0);
        Base.Compare_List.forEach((cT) => {
            this.DOM["measure_" + cT] = measureGroup
                .append("path")
                .attr("class", "measure_" + cT)
                .each((_d, i, nodes) => {
                nodes[i]._currentPreviewAngle = 0;
            });
        });
        this.DOM.aggrGlyphs = this.DOM.setPairGroup.selectAll(".setPairGlyph");
        this.DOM.setPairBackground =
            this.DOM.aggrGlyphs.selectAll(".setPairBackground");
        ["Active"].concat(Base.Compare_List).forEach((t) => {
            this.DOM["measure_" + t] = this.DOM.aggrGlyphs.selectAll(".measure_" + t);
        });
    }
    /** Axis is shown as a separate legend for set summaries */
    refreshViz_Axis() {
        this.refreshSetPair_Strength();
        if (this.usingFullSizeGlyph()) {
            this.DOM.scaleLegend_SVG.style("dislay", "none");
            return;
        }
        this.DOM.scaleLegend_SVG.style("display", "block");
        this.DOM.scaleLegend_SVG
            .attr("width", this.setPairDiameter + 50)
            .attr("height", this.setPairDiameter + 10)
            .attr("viewBox", "0 0 " + (this.setPairDiameter + 35) + " " + (this.setPairDiameter + 10));
        this.DOM.legend_Group.attr("transform", `translate(${this.setPairRadius},${this.setPairRadius + 18})`);
        this.DOM.legendHeader.attr("transform", `translate(${this.setPairDiameter + 3},6)`);
        var maxVal = this._maxSetPairAggr_Active;
        var tickValues = [maxVal];
        if (this.setPairRadius > 8)
            tickValues.push(Math.round(maxVal / 4));
        this.DOM.legend_Group.selectAll("g.legendMark").remove();
        var tickDoms = this.DOM.legend_Group
            .selectAll("g.legendMark")
            .data(tickValues, (i) => i);
        this.DOM.legendCircleMarks = tickDoms
            .enter()
            .append("g")
            .attr("class", "legendMark");
        this.DOM.legendCircleMarks
            .append("circle")
            .attr("class", "legendCircle")
            .attr("cx", 0)
            .attr("cy", 0)
            .attr("r", (d) => this.setPairRadius * Math.sqrt(d / maxVal));
        this.DOM.legendCircleMarks
            .append("line")
            .attr("class", "legendLine")
            .each((d, i, nodes) => {
            var rx = this.setPairRadius + 3;
            var ry = this.setPairRadius * Math.sqrt(d / maxVal);
            var x2, y1;
            switch (i % 4) {
                case 0:
                    x2 = rx;
                    y1 = -ry;
                    break;
                case 1:
                    x2 = rx; // -rx;
                    y1 = ry; // -ry;
                    break;
                case 2:
                    x2 = rx;
                    y1 = ry;
                    break;
                case 3:
                    x2 = -rx;
                    y1 = ry;
                    break;
            }
            nodes[i].setAttribute("x1", 0);
            nodes[i].setAttribute("x2", x2);
            nodes[i].setAttribute("y1", y1);
            nodes[i].setAttribute("y2", y1);
        });
        this.DOM.legendText = this.DOM.legendCircleMarks
            .append("text")
            .attr("class", "legendLabel");
        this.DOM.legendText.each((d, i, nodes) => {
            var rx = this.setPairRadius + 3;
            var ry = this.setPairRadius * Math.sqrt(d / maxVal);
            var x2, y1;
            switch (i % 4) {
                case 0:
                    x2 = rx;
                    y1 = -ry;
                    break;
                case 1:
                    x2 = rx; // -rx;
                    y1 = ry; // -ry;
                    break;
                case 2:
                    x2 = rx;
                    y1 = ry;
                    break;
                case 3:
                    x2 = -rx;
                    y1 = ry;
                    break;
            }
            nodes[i].setAttribute("transform", `translate(${x2},${y1})`);
            nodes[i].style.textAnchor = i % 2 === 0 || true ? "start" : "end";
        });
        this.DOM.legendText.text((d) => {
            return d3$d.format("0.1s")(d);
        });
    }
    /** -- */
    refreshWindowSize() {
        var w = this.getWidth();
        var h = this.getHeight();
        this.DOM.wrapper.style("height", this.setListSummary.block.getHeight() -
            this.setListSummary.block.height_Header +
            "px");
        this.DOM.setMatrixBackground
            .attr("x", -w * 24)
            .attr("y", -h * 24)
            .attr("width", w * 50)
            .attr("height", h * 50);
        this.DOM.root
            .style(this.popupSide, -w + "px")
            .style("width", w + "px")
            .style(this.popupSide === "left" ? "right" : "left", "initial");
        if (!this.pausePanning) {
            this.refreshSVGViewBox();
        }
    }
    /** -- */
    refreshPopupSide() {
        this.DOM.root.attr("data-popupSide", this.popupSide);
        this.refreshRow();
        this.refreshSetPair_Position();
        this.refreshSVGViewBox();
    }
    /** -- */
    refreshSVGViewBox() {
        var w = this.getWidth();
        var h = this.getHeight();
        var t = this.setListSummary.block.scrollTop_cache;
        var r = Math.max(t + this.gridPan_x, 0) * (this.popupSide === "left" ? -1 : 1);
        this.DOM.setMatrixSVG
            .attr("width", w)
            .attr("height", h)
            .attr("viewBox", r + " " + t + " " + w + " " + h);
        this.refreshLabel_Vert_Show();
    }
    /** -- */
    refreshSetPair_Background() {
        this.DOM.setPairBackground
            .attr("x", -this.setPairRadius)
            .attr("y", -this.setPairRadius)
            .attr("width", this.setPairDiameter)
            .attr("height", this.setPairDiameter);
    }
    /** -- */
    refreshLabel_Vert_Show() {
        var totalWidth = this.getWidth();
        var totalHeight = this.getHeight();
        this.setListSummary.block.scrollTop_cache;
        this.DOM.line_vert_label // points up/right
            .attr("show", (d) => !d.isVisible)
            .attr("transform", (d) => {
            var i = d.orderIndex;
            var x = totalWidth - (i + 0.5) * this.rowHeight - 2;
            if (this.popupSide === "right")
                x = totalWidth - x - 4;
            var y = (this.setListSummary.block.catCount_Active - i - 1) * this.rowHeight -
                this.setListSummary.block.height_VisibleAttrib +
                this.setListSummary.block.scrollTop_cache +
                totalHeight;
            return `translate(${x} ${y}) rotate(-90)`;
        });
    }
    /** -- */
    refreshRow() {
        this.refreshWindowSize();
        this.DOM.setRows.attr("transform", (row) => `translate(0,${(row.orderIndex + 0.5) * this.rowHeight})`);
        this.refreshRow_LineWidths();
    }
    /** -- */
    refreshSetPair_Position() {
        var w = this.getWidth();
        this.DOM.aggrGlyphs.style("transform", (setPair) => {
            var i1 = setPair.set_1.orderIndex;
            var i2 = setPair.set_2.orderIndex;
            var left = (Math.min(i1, i2) + 0.5) * this.rowHeight;
            if (this.popupSide === "left")
                left = w - left;
            var top = (Math.max(i1, i2) + 0.5) * this.rowHeight;
            return `translate(${left}px,${top}px)`;
        });
    }
    /** -- */
    refreshRow_LineWidths() {
        var setPairDiameter = this.rowHeight;
        var totalWidth = this.getWidth();
        // vertical lines
        this.DOM.line_vert.each((d, i, nodes) => {
            var _DOM = nodes[i];
            var i = d.orderIndex;
            var height = (this.setListSummary.block.catCount_Active - i - 1) * setPairDiameter;
            var right = (i + 0.5) * setPairDiameter;
            var m = this.popupSide === "left" ? totalWidth - right : right;
            _DOM.setAttribute("x1", m);
            _DOM.setAttribute("x2", m);
            _DOM.setAttribute("y2", height);
        });
        // horizontal lines
        this.DOM.line_horz
            .attr("x2", this.popupSide === "left" ? totalWidth : 0)
            .attr("x1", (d) => {
            var m = (d.orderIndex + 0.5) * setPairDiameter;
            return this.popupSide === "left" ? totalWidth - m : m;
        });
        this.DOM.line_horz_label.attr("transform", (d) => {
            var m = (d.orderIndex + 0.5) * setPairDiameter + 2;
            if (this.popupSide === "left")
                m = totalWidth - m;
            return `translate(${m} 0)`;
        });
    }
}

/** -- */
class Attrib_Set extends Attrib {
    get parent() {
        return this._parent;
    }
    get setListAttrib() {
        return this._parent;
    }
    get block() {
        return this._block;
    }
    // just renaming for convenience
    get setPairs() {
        return this._aggrs;
    }
    // sets are parent summaries aggregates
    get sets() {
        return this.setListAttrib._aggrs;
    }
    // ********************************************************************
    // Constructor
    // ********************************************************************
    constructor(browser, parent) {
        super(browser, i18n.SetPairTitle(parent.attribName), null, // no template, no accessor
        "setpair", "setPairSummary", "" // not in attribute list
        );
        // ********************************************************************
        // Aggregates (setpairs)
        // ********************************************************************
        this._aggrs = [];
        this._setPairs_ID = {};
        this._parent = parent;
        this._block = new Block_Set(this);
    }
    /** -- */
    initializeAggregates() {
        if (this.aggr_initialized)
            return;
        this.createSetPairs();
        this.block.initDOM();
        this.aggr_initialized = true;
    }
    getAggregate(set_1, set_2) {
        var setPair = this._setPairs_ID[set_1.id][set_2.id];
        if (!setPair) {
            setPair = new Aggregate_SetPair(this.setListAttrib, set_1, set_2);
            set_1.setPairs.push(setPair);
            set_2.setPairs.push(setPair);
            this.setPairs.push(setPair);
            this._setPairs_ID[set_1.id][set_2.id] = setPair;
            this.browser.allAggregates.push(setPair);
        }
        return setPair;
    }
    /** For each element in the given list, checks the set membership and adds setPairs */
    createSetPairs() {
        this.sets.forEach((aggr) => {
            aggr.setPairs = [];
        });
        var insertToClique = (set_1, set_2, record) => {
            // avoid self reference and adding the same record twice
            // (insert only A-B, not B-A / A-A / B-B)
            if (set_2.id <= set_1.id)
                return;
            if (this._setPairs_ID[set_1.id] === undefined)
                this._setPairs_ID[set_1.id] = {};
            this.getAggregate(set_1, set_2).addRecord(record);
        };
        var getSetAggr = (v) => {
            return this.setListAttrib.getAggrWithLabel(v);
        };
        this.setListAttrib.records.forEach((record) => {
            // read raw values, not with labeling applied
            var values = record.getValue(this.setListAttrib);
            if (values === null)
                return; // maps to no value
            if (values.length < 2)
                return; // maps to one value
            values.forEach((v_1) => {
                var set_1 = getSetAggr(v_1);
                if (!set_1.setPairs)
                    return;
                values.forEach((v_2) => {
                    var set_2 = getSetAggr(v_2);
                    if (!set_2.setPairs)
                        return;
                    insertToClique(set_1, set_2, record);
                });
            });
        });
        this.block.updateMaxAggr_Active();
    }
    /** --*/
    updatePerceptualOrder() {
        // Edges are set-pairs with at least one element inside (based on the filtering state)
        var edges = this.setPairs.filter((aggr) => aggr.measure("Active") > 0);
        // Nodes are the set-categories
        var nodes = this.sets;
        // Initialize per-node (per-set) data structures
        nodes.forEach((node) => {
            node.MST = {
                tree: new Object(),
                childNodes: [],
                parentNode: null,
            };
        });
        // Compute the perceptual distance metric
        edges.forEach((edge) => {
            var set_1 = edge.set_1;
            var set_2 = edge.set_2;
            edge.mst_distance = 0;
            // For every intersection of set_1
            set_1.setPairs.forEach((setPair_1) => {
                if (setPair_1 === edge)
                    return;
                var set_other = setPair_1.set_1 === set_1 ? setPair_1.set_2 : setPair_1.set_1;
                // find the set-pair of set_2 and set_other;
                var setPair_2 = null;
                if (set_2.id > set_other.id) {
                    if (this._setPairs_ID[set_other.id])
                        setPair_2 = this._setPairs_ID[set_other.id][set_2.id];
                }
                else {
                    if (this._setPairs_ID[set_2.id])
                        setPair_2 = this._setPairs_ID[set_2.id][set_other.id];
                }
                if (!setPair_2) {
                    // the other intersection size is zero, there is no link
                    edge.mst_distance += setPair_1.measure("Active");
                    return;
                }
                edge.mst_distance += Math.abs(setPair_1.measure("Active") - setPair_2.measure("Active"));
            });
            // For every intersection of set_2
            set_2.setPairs.forEach((setPair_1) => {
                if (setPair_1 === edge)
                    return;
                var set_other = setPair_1.set_1 === set_2 ? setPair_1.set_2 : setPair_1.set_1;
                // find the set-pair of set_1 and set_other;
                var setPair_2 = undefined;
                if (set_1.id > set_other.id) {
                    if (this._setPairs_ID[set_other.id])
                        setPair_2 = this._setPairs_ID[set_other.id][set_1.id];
                }
                else {
                    if (this._setPairs_ID[set_1.id])
                        setPair_2 = this._setPairs_ID[set_1.id][set_other.id];
                }
                if (setPair_2 === undefined) {
                    // the other intersection size is zero, there is no link
                    edge.mst_distance += setPair_1.measure("Active");
                    return;
                }
                // If ther is setPair_2, it was already processed in the main loop above
            });
        });
        // Order the edges (setPairs) by their distance (lower score is better)
        edges.sort((e1, e2) => e1.mst_distance - e2.mst_distance);
        // Run Kruskal's algorithm...
        edges.forEach((setPair) => {
            var node_1 = setPair.set_1;
            var node_2 = setPair.set_2;
            // set_1 and set_2 are in the same tree
            if (node_1.MST.tree === node_2.MST.tree)
                return;
            // set_1 and set_2 are not in the same tree, connect set_2 under set_1
            var set_above, set_below;
            if (node_1.setPairs.length < node_2.setPairs.length) {
                set_above = node_1;
                set_below = node_2;
            }
            else {
                set_above = node_2;
                set_below = node_1;
            }
            set_below.MST.tree = set_above.MST.tree;
            set_below.MST.parentNode = set_above;
            set_above.MST.childNodes.push(set_below);
        });
        // Identify the root-nodes of resulting MSTs
        var treeRootNodes = nodes.filter((node) => {
            return node.MST.parentNode === null;
        });
        // We can have multiple trees (there can be sub-groups disconnected from each other)
        // Update tree size recursively by starting at the root nodes
        var updateTreeSize = (node) => {
            node.MST.treeSize = 1;
            node.MST.childNodes.forEach((childNode) => {
                node.MST.treeSize += updateTreeSize(childNode);
            });
            return node.MST.treeSize;
        };
        treeRootNodes.forEach((rootNode) => {
            updateTreeSize(rootNode);
        });
        // Sort the root nodes by largest tree first
        treeRootNodes.sort((node1, node2) => node1.MST.treeSize - node2.MST.treeSize);
        // For each MST, traverse the nodes and add the MST (perceptual) node index incrementally
        var mst_index = 0;
        var updateNodeIndex = (node) => {
            node.MST.childNodes.forEach((chileNode) => {
                chileNode.MST.order = mst_index++;
            });
            node.MST.childNodes.forEach((chileNode) => {
                updateNodeIndex(chileNode);
            });
        };
        treeRootNodes.forEach((node) => {
            node.MST.order = mst_index++;
            updateNodeIndex(node);
        });
    }
    isExportable() {
        return false;
    }
    // ********************************************************************
    // Not applicable
    // ********************************************************************
    /** It doesn't have its own filter - uses filter of parent category instead */
    createSummaryFilter() { }
    /** Special templates do not apply */
    applyTemplateSpecial() { }
    /** not used for set/ circle size calculations, just implementing the interface */
    get measureRangeMax() {
        return this.block.setPairRadius;
    }
    updateChartScale_Measure() {
        var _a;
        if (!this.block.isVisible())
            return;
        (_a = this.block) === null || _a === void 0 ? void 0 : _a.refreshViz_All();
    }
    chartAxis_Measure_TickSkip() {
        throw new Error("Not applicable.");
    }
    isEmpty() {
        return false;
    }
    isFiltered() {
        return this.setListAttrib.isFiltered();
    }
}

class Filter_Categorical extends Filter {
    constructor(_browser, attrib) {
        super(_browser);
        this.selected_AND = [];
        this.selected_OR = [];
        this.selected_NOT = [];
        this.attrib = attrib;
    }
    get title() {
        return this.attrib.attribName;
    }
    selectedCount_Total() {
        return (this.selected_AND.length +
            this.selected_OR.length +
            this.selected_NOT.length);
    }
    selected_Any() {
        return (this.selected_AND.length > 0 ||
            this.selected_OR.length > 0 ||
            this.selected_NOT.length > 0);
    }
    selected_None() {
        return (this.selected_AND.length === 0 &&
            this.selected_OR.length === 0 &&
            this.selected_NOT.length === 0);
    }
    selected_AndOrNot() {
        return this.selected_AND.concat(this.selected_OR).concat(this.selected_NOT);
    }
    selected_All_clear() {
        this.selected_AND = [];
        this.selected_OR = [];
        this.selected_NOT = [];
    }
    setRecordCache(record, v) {
        record.setFilterCache(this.filterID, v);
    }
    onFilter() {
        var noValueOut = this.noValueAggr.filtered === "out";
        var noValueIn = this.noValueAggr.filtered === "in";
        this.attrib.records.forEach((record) => {
            // Note: Using direct access here.
            // This prevents applying the look-up table overwrite in this class
            var recordVal_s = record.getValue(this.attrib);
            if (noValueIn) {
                return this.setRecordCache(record, recordVal_s == null);
            }
            if (recordVal_s == null) {
                if (noValueOut) {
                    return this.setRecordCache(record, false);
                }
                // survives if AND and OR is not selected
                this.setRecordCache(record, this.selected_AND.length === 0 && this.selected_OR.length === 0);
                return;
            }
            var getAggr = (v) => this.attrib.catTable_id[v];
            // If any of the record values are selected with NOT, the record will be removed
            if (this.selected_NOT.length > 0) {
                if (!recordVal_s.every((v) => !getAggr(v).filtered_NOT())) {
                    return this.setRecordCache(record, false);
                }
            }
            // All AND selections must be among the record values
            if (this.selected_AND.length > 0) {
                var t = 0; // Compute the number of record values selected with AND.
                recordVal_s.forEach((v) => {
                    if (getAggr(v).filtered_AND())
                        t++;
                });
                if (t !== this.selected_AND.length) {
                    return this.setRecordCache(record, false);
                }
            }
            // One of the OR selections must be among the record values
            if (this.selected_OR.length > 0) {
                return this.setRecordCache(record, recordVal_s.some((v) => getAggr(v).filtered_OR()));
            }
            // only NOT selection
            record.setFilterCache(this.filterID, true);
        });
        super.onFilter();
    }
    filterView_Detail() {
        if (this.noValueAggr.filtered === "in")
            return i18n.NoData;
        // 'this' is the Filter
        // go over all records and prepare the list
        var text = "";
        if (this.noValueAggr.filtered === "out")
            text = `(${i18n.ValidData})`;
        var queryStr = (_type) => ` <span class='AndOrNot AndOrNot_${_type}'>"${i18n[_type]}</span> `;
        if (this.selectedCount_Total() > 4) {
            text = `<b>${this.selectedCount_Total()}</b> selected`;
        }
        else {
            var selectedItemsCount = 0;
            // OR selections
            if (this.selected_OR.length > 0) {
                var useBracket_or = this.selected_AND.length > 0 || this.selected_NOT.length > 0;
                if (useBracket_or)
                    text += "[";
                // X or Y or ....
                this.selected_OR.forEach((_cat, i) => {
                    text +=
                        (i !== 0 || selectedItemsCount > 0 ? queryStr("Or") : "") +
                            `<span class='optionName'>${_cat.label}</span>`;
                    selectedItemsCount++;
                });
                if (useBracket_or)
                    text += "]";
            }
            // AND selections
            this.selected_AND.forEach((_cat) => {
                text +=
                    (text !== "" ? queryStr("And") : "") +
                        `<span class='optionName'>${_cat.label}</span>`;
                selectedItemsCount++;
            });
            // NOT selections
            this.selected_NOT.forEach((_cat) => {
                text += `${queryStr("Not")}<span class='optionName'>${_cat.label}</span>`;
                selectedItemsCount++;
            });
        }
        return text;
    }
    exportFilter() {
        var _ = {};
        if (this.noValueAggr.filtered) {
            _.missing = this.noValueAggr.filtered;
        }
        else {
            ["AND", "OR", "NOT"].forEach((logic) => {
                var selected_x = this["selected_" + logic];
                if (selected_x.length > 0) {
                    _[logic] = [];
                    selected_x.forEach((_cat) => {
                        _[logic].push(_cat.label);
                    });
                }
            });
        }
        return _;
    }
    importFilter(_) {
        if (_.missing) {
            this.noValueAggr.filtered = _.missing;
            this.setFiltered(false);
        }
        else {
            this.selected_All_clear();
            ["AND", "OR", "NOT"].forEach((_type) => {
                if (!_[_type])
                    return;
                // find category, and add filter
                let ar = _[_type];
                ar.forEach((catStr) => {
                    var aggr = this.attrib.catTable_id[catStr];
                    if (aggr) {
                        this.attrib.filterCategory(aggr, _type, "All", false /** skip update */);
                    }
                });
            });
        }
        if (this.isFiltered) {
            this.applyFilter();
        }
    }
}

const d3$c = { max };
class Attrib_Categorical extends Attrib {
    get block() {
        return this._block;
    }
    get measureRangeMax() {
        return this.block.width_CatBars;
    }
    applyTemplateSpecial() {
        if (this.template.special === "Year") {
            this.setSortingOption("id");
        }
        else if (this.template.special === "Month") {
            this.setSortingOption("id");
            this.setCatLabel(i18n.Lookup_Months);
        }
        else if (this.template.special === "WeekDay") {
            this.setSortingOption("id");
            this.setCatLabel(i18n.Lookup_DaysOfWeek);
        }
    }
    supportsRecordEncoding(coding) {
        if (this.isEmpty())
            return false;
        if (coding === "text")
            return true;
        if (coding === "textBrief")
            return true;
        return false;
    }
    constructor(browser, name, template) {
        super(browser, name, template, "categorical", "kshfSummary_Categorical", "far fa-font");
        this._aggrs = [];
        this.catTable_id = {};
        this.removedAggrs = [];
        // ********************************************************************
        // Set summary / Maximum degree
        // ********************************************************************
        this.setAttrib = null;
        this._maxValueDegree = 1;
        // ********************************************************************
        // Filtering
        // ********************************************************************
        this.summaryFilter = null;
        // ********************************************************************
        // Sorting
        // ********************************************************************
        this.catSortBy = "Active";
        this.catSortInverse = false;
        this.pleaseSort = false;
        this._dirtySort = true;
        this.dblClickTimer = 0;
        // ********************************************************************
        // Mapping
        // ********************************************************************
        this.catGeo = null;
        this.mapTable = null;
        this.mapInitView = null;
        // ********************************************************************
        // Cat labels
        // ********************************************************************
        this.catLabel_attr = {};
        this.createSummaryFilter();
        this._block = new Block_Categorical(this);
        this.barHeight = new Config({
            parent: this,
            cfgClass: "barHeight",
            cfgTitle: "RowHeight",
            iconClass: "fa fa-arrows-v",
            UISeperator: {
                title: "Size",
                className: "catSummary_ListOnly",
            },
            default: Base.defaultBarHeight,
            helparticle: "5e87d6d004286364bc97d079",
            itemOptions: [
                { name: "<i class='fa fa-minus'></i>", value: -99, _type: "minus" },
                { name: "1x", value: 18, max: 32 },
                { name: "2x", value: 32, max: 44 },
                { name: "3x", value: 44, max: 56 },
                { name: "4x", value: 56, max: 68 },
                { name: "5x", value: 68, max: 80 },
                { name: "6x", value: 80, max: 120 },
                { name: "<i class='fa fa-plus'></i>", value: -100, _type: "plus" }, // special value
            ],
            isActive: (d) => d.value && d.value <= this.barHeight.get() && d.max > this.barHeight.get(),
            onDOM: (DOM) => {
                DOM.root.classed("catSummary_ListOnly", true);
            },
            preSet: (v, opt) => __awaiter(this, void 0, void 0, function* () {
                if (v === -99) {
                    v = opt._value - 1;
                }
                else if (v === -100) {
                    v = opt._value + 1;
                }
                return Math.min(85, Math.max(10, v));
            }),
            onSet: () => {
                if (this.block.isView_List) {
                    this.block.refreshHeight_Category();
                }
                else {
                    this.block.heightRow_category_dirty = true;
                }
            },
        });
        let _timer;
        this.minAggrSize = new Config({
            parent: this,
            cfgClass: "minAggrSize",
            cfgTitle: "Show",
            iconClass: "fa fa-eye-slash",
            default: 1,
            itemOptions: [
                { name: "All", value: 1 },
                {
                    name: "More than one",
                    value: 10,
                },
            ],
            UI: { disabled: true },
            isActive: (d) => d.value
                ? this.minAggrSize.get() > 1
                : this.minAggrSize.get() === 1,
            onDOM: (DOM) => {
                DOM.root
                    .select(".minAggrSizeInput")
                    .attr("value", this.minAggrSize.get())
                    .attr("max", d3$c.max(this._aggrs, (_cat) => _cat.records.length))
                    .on("input", (event) => {
                    if (_timer)
                        window.clearTimeout(_timer);
                    _timer = window.setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                        yield this.minAggrSize.set(Math.max(2, 1 * event.currentTarget.value));
                    }), 500);
                });
            },
            preSet: (v) => __awaiter(this, void 0, void 0, function* () { return Math.max(1, v); }),
            onSet: (v) => this.setMinAggrSize(v),
        });
        this.setSortingOption();
        this.finishTemplateSpecial();
    }
    // TODO incomplete
    getAggrWithLabel(v) {
        return this.catTable_id[v];
    }
    getAggregate(v) {
        let aggr = this.catTable_id[v];
        if (!aggr) {
            aggr = new Aggregate_Category(this, v);
            if (this.catLabel_attr[v]) {
                aggr.label = this.catLabel_attr[v];
            }
            this.catTable_id[v] = aggr;
            this._aggrs.push(aggr);
            this.browser.allAggregates.push(aggr);
        }
        return aggr;
    }
    initializeAggregates() {
        if (this.aggr_initialized)
            return;
        this.catTable_id = {};
        this._aggrs = [];
        this.removedAggrs = [];
        var maxDegree = 0;
        this.records.forEach((record) => {
            var catValues = this.template.func.call(record.data, record);
            // make catValues an array if it is not
            if (!Array.isArray(catValues))
                catValues = [catValues];
            // trim whitespaces, remove invalid / empty string values
            catValues = catValues
                .map((e) => (e && e.trim ? e.trim() : e))
                .filter((e) => e != null && e !== "")
                .map((e) => "" + e); // convert to string
            catValues = new Set(catValues); // remove duplicates
            // Record is not mapped to any value (missing value)
            if (catValues.size === 0) {
                this.setRecordValueCacheToMissing(record);
                return;
            }
            let cats = [];
            catValues.forEach((id) => {
                cats.push(id);
                this.getAggregate(id).addRecord(record);
            });
            record.setValue(this, cats);
            maxDegree = Math.max(maxDegree, catValues.size);
        });
        this.maxValueDegree = maxDegree;
        this.aggr_initialized = true;
    }
    // Modified internal dataMap function - Skip rows with 0 active item count
    setMinAggrSize(minSize) {
        if (!this.aggr_initialized)
            return; // too early
        var newAggrs = 0;
        this.removedAggrs = this.removedAggrs.filter((cat) => {
            if (cat.records.length >= minSize) {
                this._aggrs.push(cat);
                cat.usedAggr = true;
                newAggrs++;
                return false;
            }
            return true;
        });
        this._aggrs = this._aggrs.filter((cat) => {
            if (cat.records.length >= minSize) {
                return true;
            }
            this.removedAggrs.push(cat);
            cat.usedAggr = false;
            cat.isActiveBefore = false;
            cat.isActive = false;
            cat.isVisibleBefore = false;
            cat.isVisible = false;
            delete cat.orderIndex;
            if (cat.DOM.aggrGlyph) {
                cat.DOM.aggrGlyph.remove();
                delete cat.DOM.aggrGlyph;
            }
            return false;
        });
        if (!this.block.DOM.inited)
            return;
        if (newAggrs) {
            this.block.insertCategoryGlyphs();
            this.block.refreshLabelWidth();
        }
        this.block.updateCats_IsActive();
        this.block.refreshHeight_Category();
        this.block.refreshConfigRowCount();
        this.block.updateCatSorting_now();
    }
    get maxValueDegree() {
        return this._maxValueDegree;
    }
    get isMultiValued() {
        return this.maxValueDegree > 1;
    }
    set maxValueDegree(v) {
        var _a, _b;
        var _pre = this.maxValueDegree || 1;
        this._maxValueDegree = v;
        if (this._maxValueDegree !== _pre) {
            (_a = this.block.DOM.root) === null || _a === void 0 ? void 0 : _a.classed("isMultiValued", this.isMultiValued).classed("supportsSetMatrix", this.supportsSetMatrix);
            // not ideal, need to generate the full list for now.
            (_b = this.block.DOM.nugget) === null || _b === void 0 ? void 0 : _b.select(".fa-tags").classed("active", this.isMultiValued);
        }
    }
    get supportsSetMatrix() {
        // TODO: make this a configurable option?
        return this.isMultiValued && this._aggrs.length >= 5;
    }
    showSetSummary() {
        if (this.setAttrib) {
            this.setAttrib.block.refreshPopupSide();
            return;
        }
        this.setAttrib = new Attrib_Set(this.browser, this);
        this.setAttrib.initializeAggregates();
    }
    onAggrClick(event, ctgry) {
        if (this.browser.adjustMode)
            return;
        if (!this.isCatSelectable(ctgry))
            return;
        if (event && event.altKey) {
            this.filterCategory(ctgry, "NOT");
            //
        }
        else if (event && event.shiftKey) {
            this.browser.setSelect_Compare(ctgry, null, false);
            this.browser.lockSelect_Compare();
            //
        }
        else if (this.dblClickTimer) {
            this.unselectAllCategories();
            this.filterCategory(ctgry, "AND", "All");
            //
        }
        else if (ctgry.isFiltered()) {
            this.filterCategory(ctgry, "NONE");
            //
        }
        else if (this.isMultiValued || this.summaryFilter.selected_None()) {
            this.filterCategory(ctgry, "AND");
            //
        }
        else {
            // category not filtered, summary not multi-valued, and has some selection - remove all other selections.
            this.summaryFilter.selected_AndOrNot().forEach((_) => _.set_NONE());
            this.filterCategory(ctgry, "AND", "All");
        }
        if (this.isMultiValued) {
            this.dblClickTimer = window.setTimeout(() => {
                this.dblClickTimer = null;
            }, 500);
        }
    }
    onAggrHighlight(aggr) {
        var _a;
        if (this.browser.adjustMode)
            return;
        if (!this.isCatSelectable(aggr))
            return;
        if (this.browser.mouseOverCompare.is(false))
            return;
        (_a = aggr.DOM.matrixRow) === null || _a === void 0 ? void 0 : _a.setAttribute("selection", "selected");
        // Comes after setting select type of the category - visual feedback on selection...
        if (!this.isMultiValued && this.summaryFilter.selected_AND.length !== 0)
            return;
        // Show the highlight
        if (aggr.filtered_NOT())
            return;
        if (this.isMultiValued || this.summaryFilter.selected_AND.length === 0) {
            this.browser.setSelect_Compare(aggr);
        }
    }
    onAggrLeave(aggr) {
        if (this.browser.adjustMode)
            return;
        if (aggr.locked)
            return;
        aggr.unselectAggregate();
        if (!this.isCatSelectable(aggr))
            return;
        this.browser.clearSelect_Compare();
    }
    createSummaryFilter() {
        this.summaryFilter = new Filter_Categorical(this.browser, this);
    }
    set dirtySort(v) {
        var _a;
        this._dirtySort = v;
        (_a = this.block.DOM.catSortButton) === null || _a === void 0 ? void 0 : _a.classed("resort", v);
    }
    get dirtySort() {
        return this._dirtySort || false;
    }
    setSortingOption(opt = "Active") {
        this.catSortBy = opt;
    }
    get catOrder_Dynamic() {
        if (typeof this.catSortBy === "string") {
            if (this.catSortBy === "alphanumeric")
                return false;
            if (this.catSortBy === "id")
                return false;
            return true; // "Active", "Compare_X"
        }
        return false;
    }
    get catOrder_Fixed() {
        return !this.catOrder_Dynamic;
    }
    setFixedCatOrder() {
        // generates array of strings, from categorical aggregates, with the order of orderIndex
        var m = this._aggrs.reduce((acc, aggr) => {
            acc[aggr.orderIndex] = aggr.label;
            return acc;
        }, []);
        this.setSortingOption(m);
        this.block.updateCatSorting_now();
    }
    _sortCategories() {
        var compare_int = (a, b) => a - b;
        var compare_str = (a, b) => Util.sortFunc_List_String(a, b);
        var compare_func = (v) => typeof v === "string" ? compare_str : compare_int;
        var theSortFunc = null;
        var valueFunc = null;
        if (typeof this.catSortBy === "string") {
            if (this.catSortBy === "alphanumeric") {
                valueFunc = (aggr) => aggr.label;
            }
            else if (this.catSortBy === "id") {
                valueFunc = (aggr) => aggr.id;
            }
            else {
                // Active, Compare_X
                let getV = (aggr) => this.browser.getChartValue(aggr, this.catSortBy);
                // Dynamic sorting
                theSortFunc = (a, b) => {
                    // selected on top of the list
                    if (!a.isFiltered() && b.isFiltered())
                        return 1;
                    if (a.isFiltered() && !b.isFiltered())
                        return -1;
                    // usedAggr === false => on the bottom
                    if (!a.usedAggr && b.usedAggr)
                        return 1;
                    if (a.usedAggr && !b.usedAggr)
                        return -1;
                    var x = getV(b) - getV(a);
                    if (x === 0)
                        x = b.measure("Total") - a.measure("Total");
                    return x;
                };
            }
        }
        else {
            if (Array.isArray(this.catSortBy)) {
                // convert the array into a lookup table for sort-order of the category.
                var _lookup = {};
                this.catSortBy.forEach((s, i) => {
                    _lookup[s] = i + 1;
                });
                valueFunc = (aggr) => _lookup[aggr.id] || 99999;
            }
            else {
                valueFunc = this.catSortBy.valueFunc;
                if (this.catSortBy.preSort) {
                    this.catSortBy.preSort.call(this);
                }
            }
        }
        if (valueFunc) {
            let getV = (aggr) => valueFunc(aggr);
            var valueCompareFunc = compare_func(getV(this._aggrs[0])); // int or string comparison, based on first aggr
            theSortFunc = (a, b) => valueCompareFunc(getV(a), getV(b));
        }
        var idCompareFunc = compare_func(this._aggrs[0].label);
        this._aggrs.sort((a, b) => {
            var _ = theSortFunc(a, b);
            if (_ === 0)
                _ = idCompareFunc(a.label, b.label);
            return this.catSortInverse ? -_ : _;
        });
        this.dirtySort = false;
        this.pleaseSort = false;
    }
    doSortInverse() {
        if (this.dirtySort) {
            this.dirtySort = false; // will refresh sorting on next updateCatSorting call
        }
        else {
            this.catSortInverse = !this.catSortInverse;
        }
        this.pleaseSort = true;
        this.block.updateCatSorting(0); // no delay, animated
    }
    getSortMenuOpts() {
        return {
            name: "Sorting",
            items: [
                {
                    id: "DynamicSort",
                    name: "Active",
                    iconClass: "fal fa-sort-amount-down",
                    active: this.catSortBy === "Active",
                    helparticle: "5e87dcde04286364bc97d08e",
                    do: (summary, action) => {
                        this.setSortingOption();
                        this.pleaseSort = true;
                        this.block.updateCatSorting(0, true); // no delay, with animation
                    },
                },
                {
                    id: "DynamicSort",
                    name: i18n["Compared"] +
                        ": " +
                        (this.browser.comparedAttrib
                            ? `<span class='comparedSummaryName'>${this.browser.comparedAttrib.attribName}</span>`
                            : ""),
                    iconClass: "fal fa-sort-numeric-down",
                    active: typeof this.catSortBy === "string" &&
                        this.catSortBy.startsWith("Compare"),
                    helparticle: "5e87e12704286364bc97d09e",
                    when: (_block) => _block.browser.activeComparisonsCount > 0 &&
                        (_block.attrib !== _block.browser.comparedSummary ||
                            _block.attrib.isMultiValued),
                    do: (_attrib, action) => {
                        // TODO: Take the selected comparison AND the breakdown type/values into account
                        this.setSortingOption(action);
                        this.pleaseSort = true;
                        this.block.updateCatSorting(0, true); // no delay, with animation
                    },
                    options: (_block) => this.browser.activeComparisons.map((cT) => ({
                        name: this.browser.selectedAggrs[cT].label,
                        iconClass: "colorBox bg_" + cT,
                        active: this.catSortBy === cT,
                        value: cT,
                    })),
                },
                {
                    id: "AlphaNumSort",
                    name: "Alphabetical",
                    iconClass: "fal fa-sort-alpha-down",
                    active: this.catSortBy === "alphanumeric",
                    helparticle: "5e87df292c7d3a7e9aea6032",
                    do: () => {
                        this.setSortingOption("alphanumeric");
                        this.pleaseSort = true;
                        this.block.updateCatSorting(0, true); // no delay, with animation
                    },
                },
                {
                    id: "CustomSort",
                    name: "Custom",
                    active: Array.isArray(this.catSortBy),
                    iconClass: "fal fa-sort-shapes-down",
                    helparticle: "5e87ddbf2c7d3a7e9aea602e",
                    do: () => {
                        this.setFixedCatOrder();
                    },
                },
                {
                    id: "SetMatrixSort",
                    name: "Relatedness",
                    iconClass: "fa fa-th",
                    when: (summary) => summary.setSummary && summary.show_set_matrix,
                    do: () => {
                        // Update sorting options of setListSummary (adding relatednesness metric...)
                        this.setSortingOption({
                            valueFunc: (aggr) => { var _a; return -((_a = aggr.MST) === null || _a === void 0 ? void 0 : _a.order); },
                            preSort: () => this.setAttrib.updatePerceptualOrder(),
                        });
                        this.pleaseSort = true;
                        this.block.updateCatSorting_now(); // no delay, no animation
                    },
                },
                // *************************
                {
                    id: "reverseSort",
                    name: "Inverse",
                    iconClass: "fal fa-exchange reverseSortIcon",
                    active: this.catSortInverse,
                    helparticle: "5e87e22904286364bc97d0a9",
                    do: () => this.doSortInverse(),
                },
            ],
        };
    }
    // ********************************************************************
    // Filtering!
    // ********************************************************************
    unselectAllCategories() {
        var _a;
        this._aggrs.forEach((cat) => cat.set_NONE());
        this.summaryFilter.selected_All_clear();
        (_a = this.block.DOM.noValueAggr) === null || _a === void 0 ? void 0 : _a.classed("filtered", false);
    }
    filterCategory(ctgry, what, how = null, update = true) {
        var _a;
        if (!ctgry) {
            return;
        }
        if (this.browser.skipSortingSummary) {
            // you can now sort the last filtered summary, attention is no longer there.
            this.browser.skipSortingSummary.dirtySort = false;
        }
        this.browser.skipSortingSummary = this;
        this.dirtySort = true;
        if (this.summaryFilter.selected_OR.length > 0 &&
            (this.summaryFilter.selected_AND.length > 0 ||
                this.summaryFilter.selected_NOT.length > 0)) {
            how = "All";
        }
        // if selection is in same mode, "undo" to NONE.
        if (what === "NOT" && ctgry.filtered_NOT())
            what = "NONE";
        if (what === "AND" && ctgry.filtered_AND())
            what = "NONE";
        if (what === "OR" && ctgry.filtered_OR())
            what = "NONE";
        if (what === "NONE") {
            if (ctgry.filtered_AND() || ctgry.filtered_NOT()) {
                how = how !== null && how !== void 0 ? how : "MoreResults";
            }
            if (ctgry.filtered_OR()) {
                how = (how !== null && how !== void 0 ? how : this.summaryFilter.selected_OR.length === 0)
                    ? "MoreResults"
                    : "LessResults";
            }
            ctgry.set_NONE();
            if (this.summaryFilter.selected_OR.length === 1 &&
                this.summaryFilter.selected_AND.length === 0) {
                this.summaryFilter.selected_OR.forEach((a) => {
                    a.set_NONE();
                    a.set_AND(this.summaryFilter.selected_AND);
                });
            }
            if (!this.summaryFilter.selected_Any())
                this.dirtySort = false;
            //
        }
        else if (what === "NOT") {
            if (!ctgry.isFiltered()) {
                if (ctgry.recCnt("Active") ===
                    this.browser.allRecordsAggr.recCnt("Active")) {
                    Modal.alert(i18n.DialogEmptyResultSet);
                    return;
                }
                how = how !== null && how !== void 0 ? how : "LessResults";
            }
            else {
                how = how !== null && how !== void 0 ? how : "All";
            }
            ctgry.set_NOT(this.summaryFilter.selected_NOT);
            //
        }
        else if (what === "AND") {
            if (ctgry.filtered_NOT() || ctgry.filtered_OR()) {
                how = how !== null && how !== void 0 ? how : "All"; // change from NOT to AND
            }
            else {
                how = how !== null && how !== void 0 ? how : "LessResults";
            }
            ctgry.set_AND(this.summaryFilter.selected_AND);
            //
        }
        else if (what === "OR") {
            if (!this.isMultiValued && this.summaryFilter.selected_NOT.length > 0) {
                var temp = [];
                this.summaryFilter.selected_NOT.forEach((a) => temp.push(a));
                temp.forEach((a) => a.set_NONE());
            }
            if (this.summaryFilter.selected_OR.length === 0 &&
                this.summaryFilter.selected_AND.length === 1) {
                this.summaryFilter.selected_AND.forEach((a) => {
                    a.set_NONE();
                    a.set_OR(this.summaryFilter.selected_OR);
                });
            }
            ctgry.set_OR(this.summaryFilter.selected_OR);
            how = how !== null && how !== void 0 ? how : "MoreResults";
        }
        if (this.summaryFilter.selected_OR.length > 0 &&
            (this.summaryFilter.selected_AND.length > 0 ||
                this.summaryFilter.selected_NOT.length > 0)) {
            how = "All";
        }
        if (this.noValueAggr.filtered === "in") {
            how = "All";
        }
        this.summaryFilter.how = how;
        if (this.summaryFilter.selectedCount_Total() === 0) {
            this.summaryFilter.clearFilter();
            return;
        }
        this.block.clearCatTextSearch();
        // if no-values were filtered in, this causes conflict, so reset to not filtered
        if (this.noValueAggr.filtered === "in") {
            this.noValueAggr.filtered = false;
        }
        (_a = this.block.DOM.root) === null || _a === void 0 ? void 0 : _a.classed("hasMultiAnd", this.summaryFilter.selected_AND.length > 1);
        this.summaryFilter.setFiltered(update);
    }
    isCatSelectable(category) {
        if (category.isFiltered())
            return true;
        if (category.recCnt("Active") !== 0)
            return true;
        // Show if multiple attributes are selected and the summary does not include multi value records
        if (this.isFiltered() && !this.isMultiValued)
            return true;
        // Hide
        return false;
    }
    autoCompare() {
        var _autoCompare = () => {
            var _index = 0;
            Base.Compare_List.forEach((cT) => {
                if (this.browser.vizActive(cT))
                    return;
                var aggr;
                while (true) {
                    aggr = this._aggrs[_index];
                    if (!aggr)
                        return;
                    if (!aggr.locked && aggr.Active.measure > 0)
                        break;
                    _index++;
                }
                this.browser.setSelect_Compare(aggr, cT, false);
                this.browser.lockSelect_Compare(false);
            });
            this.browser.refreshConfigs();
        };
        if (this.browser.comparedAttrib && !this.isComparedAttrib()) {
            Modal.confirm(i18n.DialogChangeCompare(this.attribNameHTML, this.browser.comparedAttrib.attribNameHTML), i18n.Confirm).then(() => {
                this.browser.clearSelect_Compare(this.browser.activeComparisons, false, true); // don't finalize yet
                _autoCompare();
            }, () => { });
        }
        else {
            _autoCompare();
        }
    }
    loadMap() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.mapTable)
                return;
            this.mapTable = Base.maps.get(this.catGeo);
            if (!this.mapTable) {
                throw new Error(i18n.Error_CannotFindMap(this.catGeo));
            }
            yield this.mapTable.loadGeo();
            // Call mapping function to store category geometry
            this.catMap_storeCatGeo();
            // Abort if none of the categories match to map data.
            if (this._aggrs.length > 0 && this._aggrs.every((_cat) => !_cat._geo_)) {
                this.removeCatGeo();
                throw new Error(i18n.Error_CannotMatchMap(this.catGeo));
            }
        });
    }
    hasMap() {
        return this.catGeo !== null;
    }
    catMap_storeCatGeo() {
        this._aggrs.forEach((aggr) => {
            aggr._geo_ =
                this.mapTable.getFeature(aggr.id.toUpperCase()) ||
                    this.mapTable.getFeature(aggr.label.toUpperCase());
            if (
            // not found
            !aggr._geo_ ||
                // only accept geojson definitions. A crude approximation.
                typeof aggr._geo_ !== "object" ||
                typeof aggr._geo_.type === undefined) {
                aggr._geo_ = null;
            }
        });
    }
    setCatGeo(template) {
        var _a;
        this.catGeo = template;
        (_a = this.block.DOM.root) === null || _a === void 0 ? void 0 : _a.attr("hasMap", true);
    }
    removeCatGeo() {
        this.catGeo = null;
        this._aggrs.forEach((_cat) => {
            _cat._geo_ = null;
        });
        this.block.removeCatGeo();
        this.mapTable = null;
    }
    uniqueCategories() {
        return (!this.isEmpty() &&
            this._aggrs.length === this.browser.records.length &&
            !this.isMultiValued);
    }
    setCatGeo_(template) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.uniqueCategories()) {
                this.setCatGeo(template);
                this.block.catViewAs("map");
            }
            else {
                // Per-record map: Define new summary
                this.browser.recordDisplay.setAttrib("geo", this.browser.createAttrib("_REGION", 
                // replace [*] with [*.]
                template
                    .replace("[*]", "[*." + this.template + "]")
                    .replace("[UPPERCASE(*)]", "[UPPERCASE(*." + this.template + ")]"), "recordGeo"));
                if (this.browser.recordChartType.is("none")) {
                    yield this.browser.recordChartType.set("map");
                }
                this.browser.refreshAttribList();
            }
        });
    }
    setCatLabel(template = {}) {
        var _a, _b;
        this.catLabel_attr = template;
        this._aggrs.forEach((aggr) => {
            aggr.label = this.catLabel_attr[aggr.id] || "";
        });
        (_b = (_a = this.block) === null || _a === void 0 ? void 0 : _a.DOM.catLabel) === null || _b === void 0 ? void 0 : _b.html((aggr) => aggr.label);
    }
    getRecordValue(record) {
        var r = record.getValue(this);
        if (r == null)
            return r;
        return r.map((_) => this.catLabel_attr[_] || _);
    }
    getFormattedValue(v, _isSVG) {
        return this.renderRecordValue(v);
    }
    renderRecordValue(v, d3_selection = null) {
        if (v instanceof Record)
            v = this.getRecordValue(v);
        var getHTML = (_url) => {
            var _href = _url.href;
            if (_url.protocol === "http:" || _url.protocol === "https:") {
                if (/\.(gif|jpg|jpeg|tiff|png|svg)$/i.test(_url.pathname)) {
                    // show as image
                    return `<img src='${_href}' class='autoDetectedImg'>`;
                }
                // show as link
                return `<a class='linkInData' href='${_href}' rel='noopener noreferrer' target='_blank'>" ${_href}</a>`;
            }
            return _href;
        };
        var _finalize = (_value) => {
            if (d3_selection)
                d3_selection.html(_value);
            else
                return _value;
        };
        var _value = v
            .map((_) => {
            if (this.catTable_id[_])
                return this.catTable_id[_].label;
            if (_ == null)
                return "-";
            return _ + "";
        })
            .map((_) => {
            try {
                var _url = new URL(_);
                if (_url.protocol === "gs:" && window.firebase) {
                    return window.firebase
                        .storage()
                        .refFromURL(_url.href)
                        .getDownloadURL()
                        .then((url) => {
                        var __url = new URL(url);
                        // update lookup table label to resolved URL
                        if (this.catTable_id[_])
                            this.catTable_id[_].label = __url.href;
                        return _finalize(getHTML(__url));
                    });
                }
                _ = getHTML(_url);
            }
            catch (exception) {
            }
            finally {
                return _;
            }
        })
            .join("<br>");
        return _finalize(_value);
    }
    // ********************************************************************
    // Export / import
    // ********************************************************************
    applyConfig(blockCfg) {
        const _super = Object.create(null, {
            applyConfig: { get: () => super.applyConfig }
        });
        return __awaiter(this, void 0, void 0, function* () {
            _super.applyConfig.call(this, blockCfg);
            if (blockCfg.mapInitView) {
                this.mapInitView = blockCfg.mapInitView;
            }
            if (blockCfg.mapConfig) {
                this.mapConfig = blockCfg.mapConfig;
            }
            yield this.measureScaleType.set(blockCfg.measureScaleType);
            yield this.barHeight.set(blockCfg.barHeight);
            yield this.minAggrSize.set(blockCfg.minAggrSize);
            if (blockCfg.catLabel) {
                this.setCatLabel(blockCfg.catLabel);
            }
            if (blockCfg.catGeo) {
                this.setCatGeo(blockCfg.catGeo);
            }
            if (blockCfg.invertedColorTheme) {
                this.block.catMap_invertColorTheme(blockCfg.invertedColorTheme);
            }
            if (blockCfg.splitOnSelfCompare === false) {
                this.block.splitOnSelfCompare = false;
            }
            if (["SingleSelect", "MultiSelect"].includes(blockCfg.dropdown_type)) {
                this.block.dropdown_type = blockCfg.dropdown_type;
            }
            if (blockCfg.filter) {
                this.summaryFilter.importFilter(blockCfg.filter);
            }
            else if (this.isFiltered()) {
                this.summaryFilter.clearFilter();
            }
            // SORTING RELATED CONFIGURATION
            if (blockCfg.catSortInverse) {
                this.catSortInverse = true;
            }
            if (blockCfg.catSortBy) {
                this.setSortingOption(blockCfg.catSortBy);
            }
            if (blockCfg.viewAs) {
                // map vs list
                this.block.catViewAs(blockCfg.viewAs);
            }
            if (blockCfg.showSetMatrix) {
                this.block.showSetMatrix(blockCfg.showSetMatrix);
            }
        });
    }
    exportConfig() {
        var config = super.exportConfig();
        var t = {
            viewAs: this.block.viewType,
            catGeo: this.catGeo,
            catLabel: this.catLabel_attr,
            catSortBy: this.catSortBy,
            catSortInverse: this.catSortInverse,
            invertedColorTheme: this.block.invertedColorTheme,
            barHeight: this.barHeight.exportValue(),
            splitOnSelfCompare: this.block.splitOnSelfCompare,
            dropdown_type: this.block.isView_Dropdown
                ? this.block.dropdown_type
                : undefined,
            filter: this.summaryFilter.exportFilter()
        };
        return Object.assign({}, config, t);
    }
}

const d3$b = {
    select,
    easePoly: polyInOut,
};
class RecordView {
    get browser() {
        return this.rd.browser;
    }
    get textAttrib() {
        return this.rd.codeBy.text;
    }
    get textBriefAttrib() {
        return this.rd.codeBy.textBrief || this.rd.codeBy.text;
    }
    get sortAttrib() {
        return this.rd.codeBy.sort;
    }
    get scatterXAttrib() {
        return this.rd.codeBy.scatterX;
    }
    get scatterYAttrib() {
        return this.rd.codeBy.scatterY;
    }
    get colorAttrib() {
        return this.rd.codeBy.color;
    }
    get sizeAttrib() {
        return this.rd.codeBy.size;
    }
    get geoAttrib() {
        return this.rd.codeBy.geo;
    }
    get DOM() {
        return this.rd.DOM;
    }
    constructor(rd) {
        this.initialized = false;
        this.animStepDelayMs = 1000;
        this.rd = rd;
    }
    refreshRecordSizes() { }
    refreshRecordColors() { }
    refreshLabelOverlaps() { }
    refreshAttribScaleType(attrib) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    onRecordMouseOver(record) { }
    onRecordMouseLeave(record) { }
    // can be extended in sub-classes
    refreshQueryBox_Filter(bounds) { }
    zoomIn() { }
    zoomOut() { }
    zoomToFit() { }
    // can be extended by subclasses
    updateRecordVisibility() { }
    getRecordsForDOM() {
        return this.browser.records;
    }
    isComparable() {
        var _a;
        // Scatterplot and Map views can share the same code here!
        if (this.browser.activeComparisonsCount === 0)
            return false;
        if (!this.browser.comparedAttrib)
            return false;
        if (!this.DOM.kshfRecords)
            return false;
        if (this.rd.viewRecAs === "map" &&
            ((_a = this.rd.codeBy.geo) === null || _a === void 0 ? void 0 : _a.geoType) !== "Point") {
            return false;
        }
        return true;
    }
    stepTimeAnimation(stepSize) {
        if (this.rd.currentTimeKey.get() == null)
            return false;
        // Iterates over potential time-series keys.
        // When it finds one,starts animation, and returns (executed only for one coding)
        ["sort", "scatter", "color", "size"].some((v) => {
            var attrib = this.rd.codeBy[v];
            if (!attrib)
                return false;
            if (!(attrib instanceof Attrib_Numeric))
                return false;
            if (!attrib.hasTimeSeriesParent())
                return false;
            var tsParent = attrib.timeseriesParent;
            this.rd.timeseriesAnimInterval = window.setInterval(() => {
                let a = tsParent.getTimepointSummary_Next(attrib, stepSize);
                if (attrib === null) {
                    this.rd.stopTimeseriesAnimation();
                }
                else {
                    this.rd.currentTimeKey.set(attrib.timeKey);
                    attrib = a;
                }
            }, this.animStepDelayMs);
            return true;
        });
    }
    // no-op by default
    stopTimeAnimation() { }
    /** -- */
    refreshSelect_Compare(cT = null, status = false) {
        if (!this.isComparable())
            return;
        if (!this.rd.recordDrawArc)
            return;
        var targetRecords = (record) => {
            if (!record.isIncluded)
                return false;
            if (!record.DOM.record)
                return false;
            if (cT && record.isSelected(cT) !== status)
                return false;
            if (this.rd.viewRecAs === "map") {
                if (!this.rd.codeBy.geo.getRecordValue(record))
                    return false;
            }
            return true;
        };
        let _do = (d, cT, arcGen) => {
            d.select(".glyph_" + cT)
                .transition()
                .ease(d3$b.easePoly.exponent(3))
                .duration(700)
                .attr("d", arcGen);
        };
        if (!this.browser.isComparedSummaryMultiValued()) {
            // renders as point
            this.DOM.kshfRecords.each((record) => {
                if (!targetRecords(record))
                    return;
                var d = d3$b.select(record.DOM.record);
                record.activeComparisons.forEach((cT) => _do(d, cT, (record) => this.rd.recordDrawArc(record)()));
            });
            //
        }
        else {
            // renders as pies
            this.DOM.kshfRecords.each((record) => {
                if (!targetRecords(record))
                    return;
                var numPies = record.activeComparisons.length;
                if (numPies === 0)
                    return;
                var arcGen = this.rd.recordDrawArc(record);
                var arcLen = (2 * Math.PI) / numPies;
                var d = d3$b.select(record.DOM.record);
                record.activeComparisons.forEach((cT, i) => {
                    arcGen.startAngle(arcLen * i).endAngle(arcLen * (i + 1));
                    _do(d, cT, arcGen());
                });
            });
        }
        this.rd.refreshCompareLegend();
    }
    // Utility/ helper
    extendRecordDOM_Point(newRecords) {
        newRecords.classed("pointGeo", true);
        ["Main"]
            .concat(Base.Compare_List)
            .forEach((cT) => newRecords.append("path").attr("class", "glyph_" + cT));
        newRecords.append("text").attr("class", "sizeValueText");
        // initializes to tiny circles
        newRecords.selectAll("path").attr("d", Util.getCirclePath());
    }
    /** -- */
    insertQueryBoxes(parent, setSizeCb, dragCb, clearCb) {
        var queryBoxes = parent
            .selectAll(".spatialQueryBox")
            .data(["Filter"].concat(Base.Compare_List))
            .enter()
            .append("div")
            .attr("class", (d) => `spatialQueryBox spatialQueryBox_${d} leaflet-zoom-hide`);
        queryBoxes
            .selectAll(".setSize")
            .data(["l", "r", "t", "b"])
            .enter()
            .append("div")
            .attr("class", (k) => "setSize-" + k)
            .on("mousedown", setSizeCb);
        queryBoxes
            .append("div")
            .attr("class", "dragSelection fa fa-arrows")
            .tooltip("Drag")
            .on("mousedown", dragCb);
        queryBoxes
            .append("div")
            .attr("class", "clearFilterButton fa")
            .tooltip((_) => i18n[_ === "Filter" ? "RemoveFilter" : "Unlock"])
            .on("mouseup", (event) => {
            event.stopPropagation();
            event.preventDefault();
        })
            .on("mousedown", (event) => {
            event.stopPropagation();
            event.preventDefault();
        })
            .on("click", clearCb);
    }
}

const d3$a = {
    select,
    selection,
    pointer,
    min,
    max,
    extent,
    line,
    curveMonotoneX: monotoneX,
    curveLinear,
    scaleLinear: linear,
    easePoly: polyInOut,
    schemeCategory10,
    format,
};
/** -- */
class LabelSpacer {
    constructor() {
        this.clear();
    }
    clear() {
        this.usedList = [];
    }
    isEmpty(pixel) {
        return !this.isUsed(pixel);
    }
    isUsed(pixel) {
        return this.usedList.some((_) => pixel < _._max && pixel > _._min);
    }
    /** returns the entity that hee given pixel intersects with */
    intersectsWith(pixel) {
        return this.usedList.find((_) => pixel < _._max && pixel > _._min);
    }
    insertUsed(pos, range, entity) {
        this.usedList.push({
            _min: pos - range,
            _max: pos + range,
            _entity: entity,
        });
    }
}
function hideAllPoppers() {
    var poppers = [].slice.call(document.querySelectorAll("[data-tippy-root]"));
    poppers.forEach(function (popper) {
        var tippy = popper._tippy;
        if (tippy) {
            tippy.hide();
            tippy.reference.classList.remove("visible");
        }
    });
}
class RecordView_Timeseries extends RecordView {
    get timeseriesAttrib() {
        return this.rd.codeBy.timeSeries;
    }
    /** -- */
    prepareAttribs() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.timeseriesAttrib) {
                yield this.rd.setAttrib("timeSeries", this.rd.config.timeSeriesBy || 0);
            }
            return Promise.resolve(true);
        });
    }
    constructor(rd, config) {
        super(rd);
        this.timeKeys_Active = [];
        this.scale_Value = null;
        this.scale_Time = null;
        this.scale_Time_prev = null;
        this.timeseriesRange_noUpdate = false;
        // ********************************************************************
        // Size / width / height / margins
        // ********************************************************************
        // is dyanmically updated, needs a setter too, so setting this as regular var.
        this.marginLeft = 85;
        this.wideTimeScale = false;
        this.ts_Type = new Config({
            cfgClass: "ts_Type",
            cfgTitle: "Timeseries Plot",
            iconClass: "far fa-chart-line",
            default: "Value",
            parent: this,
            helparticle: "5eaf64de042863474d1a0efc",
            tooltip: `Timeseries plot chart type`,
            itemOptions: [
                { name: "# Value", value: "Value" },
                { name: "⩔ Rank", value: "Rank" },
                { name: "#-Change", value: "ChangeAbs" },
                { name: "%-Change", value: "ChangePct" },
            ],
            preSet: (v) => __awaiter(this, void 0, void 0, function* () { return v === "Change" ? "ChangePct" /* old value*/ : v; }),
            onSet: () => this.refreshTimeSeriesPlotType(),
        });
        this.timeSeriesChangeVsTimeKey = new Config({
            parent: this,
            cfgClass: "ts_ChangeVsTimeKey",
            cfgTitle: "Change vs.",
            iconClass: "far fa-calendar",
            default: null,
            helparticle: "5e87f81e2c7d3a7e9aea60a4",
            onDOM: (DOM) => {
                var _ = DOM.root.select(".configItem_Options");
                DOM.keySelect = _.append("select")
                    .attr("class", "keySelect")
                    .on("change", (event) => __awaiter(this, void 0, void 0, function* () {
                    yield this.timeSeriesChangeVsTimeKey.set(event.currentTarget.selectedOptions[0].__data__._time_src);
                }));
            },
            onRefreshDOM: (cfg) => {
                if (!cfg.get())
                    return; // nothing to do!
                cfg.DOM.root.classed("hidden", !this.isTimeseriesChange());
                cfg.DOM.keySelect
                    .selectAll("option")
                    .data(this.timeKeys_Active || [], (d) => d._time_src)
                    .join((enter) => enter.append("option").text((d) => d._time_src), (update) => update, (exit) => exit.remove())
                    .attr("selected", (d) => d._time_src === cfg.get()._time_src ? true : null);
            },
            preSet: (v, obj) => __awaiter(this, void 0, void 0, function* () {
                if (!this.timeseriesAttrib)
                    return; // NOT SET now
                if (typeof v === "string") {
                    v = this.timeseriesAttrib.timeKeys.find((k) => k._time_src === v);
                }
                // if not set, use first timeKey
                if (!v)
                    return this.timeseriesAttrib.timeKeys[0];
                return v;
            }),
            onSet: (v, obj) => {
                this.refreshScaleValue();
                this.refreshKeyLine();
            },
        });
        this.ts_timeKeysStep = new Config({
            parent: this,
            cfgClass: "ts_timeKeysStep",
            cfgTitle: "Time Keys",
            iconClass: "far fa-calendar",
            UISeperator: {
                title: "Axis",
                className: "ts_only",
            },
            default: "all",
            helparticle: "5e891b8504286364bc97d544",
            itemOptions: [
                { name: "All", value: "all" },
                { name: "1st &amp; Last (Slope)", value: "limits" },
            ],
            forcedValue: () => {
                if (!this.timeseriesAttrib)
                    return;
                if (this.timeseriesAttrib.timeKeys.length < 3)
                    return "limits";
            },
            onSet: () => this.refreshTimeRange(),
        });
        this.ts_valueAxisScale = new Config({
            cfgClass: "ts_valueAxisScale",
            cfgTitle: "Value Axis Scale",
            iconClass: "fa fa-arrows-v",
            default: config.ts_valueAxisScale || "linear",
            parent: this,
            helparticle: "5f137b5304286306f8070db3",
            itemOptions: [
                { name: i18n.Linear + " " + i18n.LinearSequence, value: "linear" },
                { name: i18n.Log + " " + i18n.Log10Sequence, value: "log" },
            ],
            noExport: true,
            forcedValue: () => {
                if (this.ts_Type.get() !== "Value")
                    return "linear";
                if (this.timeseriesAttrib && !this.timeseriesAttrib.supportsLogScale())
                    return "linear";
            },
            onSet: (v) => __awaiter(this, void 0, void 0, function* () {
                if (this.timeseriesAttrib) {
                    yield this.timeseriesAttrib.valueScaleType.set(v);
                }
            }),
        });
        // Timeseries-only?
        this.fitValueAxis = new Config({
            cfgClass: "fitValueAxis",
            cfgTitle: "Fit Value Axis",
            iconClass: "fa fa-arrows-v",
            default: false,
            parent: this,
            helparticle: "5e891b992c7d3a7e9aea64fb",
            itemOptions: [
                { name: "Static", value: false },
                { name: "Dynamic", value: true },
            ],
            forcedValue: () => {
                if (!this.browser.isFiltered())
                    return false; // full
                if (this.ts_Type.is("Rank"))
                    return false; // full
                if (this.isTimeseriesChange())
                    return true; // fit
            },
            onSet: () => {
                this.refreshScaleValue();
            },
        });
        this.timeSeriesSelectMode = new Config({
            cfgClass: "timeSeriesSelectMode",
            cfgTitle: "Mouse Select",
            iconClass: "fa fa-hand-pointer",
            UISeperator: {
                title: "Control",
                className: "ts_only",
            },
            default: "record",
            parent: this,
            helparticle: "5e88c11004286364bc97d3c0",
            itemOptions: [
                { name: "Nearest Record", value: "record" },
                { name: "Nearest Time-Key", value: "time" },
                // {name: "Filter", value: "filter" },
            ],
            onSet: (v) => {
                // TODO
                // this.visMouseMode.val = (v==='filter')?'filter':'pan';
            },
        });
        [
            "ts_Type",
            "timeSeriesChangeVsTimeKey",
            "timeSeriesSelectMode",
            "ts_timeKeysStep",
            "fitValueAxis",
            "ts_valueAxisScale",
        ].forEach((t) => {
            this[t].val = config[t];
            this.rd.configs[t] = this[t];
            this.rd.recordConfigPanel.insertConfigUI(this[t]);
        });
        var me = this;
        this.timeRange = {
            _src: {},
            get min() {
                return this.val("min");
            },
            get max() {
                return this.val("max");
            },
            set min(v) {
                this._src.min = v ? v._time_src : null;
            },
            set max(v) {
                this._src.max = v ? v._time_src : null;
            },
            val: function (t) {
                var v = this._src[t];
                if (!v || !me.timeseriesAttrib || !me.timeseriesAttrib.timeKeys)
                    return null;
                return me.timeseriesAttrib.timeKeys.find((_) => _._time_src === v);
            },
            minActive() {
                return this.min._index > 0;
            },
            maxActive() {
                return this.max._index < me.timeseriesAttrib.timeKeys.length - 1;
            },
            isActive(t) {
                if (t === "min")
                    return this.minActive();
                if (t === "max")
                    return this.maxActive();
                return this.minActive() || this.maxActive();
            },
            exportConfig() {
                var o = {};
                if (this._src.min)
                    o["min"] = this._src.min;
                if (this._src.max)
                    o["max"] = this._src.max;
                return o;
            },
            importConfig(o) {
                if (!o)
                    return;
                ["min", "max"].forEach((t) => {
                    if (o[t])
                        this._src[t] = o[t];
                });
            },
        };
        this.timeRange.importConfig(config.timeRange);
    }
    /** -- */
    initView() {
        this.recordInView = (record) => {
            var _ts = this.timeseriesAttrib.getRecordValue(record);
            if (!_ts || _ts.isEmpty())
                return false;
            if (this.isTimeseriesChange()) {
                var _compareKey = this.timeSeriesChangeVsTimeKey.get()._time_src;
                var _index = _ts._keyIndex[_compareKey];
                return _index != null && _index._value != null;
            }
            return true;
        };
        this.refreshTimeSeriesPlotType();
        this.refreshScaleTime();
        this.rd.refreshRecordDOM();
        this.rd.refreshRecordVis();
        this.refreshTimeseriesTicks();
        this.refreshTicks_AxisY();
        this.updateDotVisibility();
        this.refreshFilterRanges();
    }
    /** -- */
    initView_DOM() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.DOM.recordBase_Timeseries) {
                this.DOM.recordGroup =
                    this.DOM.recordBase_Timeseries.select(".recordGroup");
                this.DOM.kshfRecords = this.DOM.recordGroup.selectAll(".kshfRecord");
                return;
            }
            var me = this;
            let prevClosestRecord = null;
            let prevClosestTime = null;
            var changeFormat = d3$a.format("+.2");
            function refreshDotTooltip(d) {
                var _c, _d;
                var record = d.DOM.parentNode.__data__;
                var recordText = me.textBriefAttrib.getRecordValue(record) || "";
                var recordValue = me.timeseriesAttrib.getFormattedValue(d._value);
                var _recordRank = me.ts_Type.is("Rank")
                    ? ` <span class='extraInfo'>(#${d._rank})</span>`
                    : "";
                var recordChange = "";
                if (me.isTimeseriesChange()) {
                    var _key = me.timeSeriesChangeVsTimeKey.get()._time_src;
                    var ref = (_d = (_c = me.timeseriesAttrib.getRecordValue(record)) === null || _c === void 0 ? void 0 : _c._keyIndex[_key]) === null || _d === void 0 ? void 0 : _d._value;
                    var _v = changeFormat((100 * (d._value - ref)) / (ref || 1)) + "%"; // avoid divide by zero
                    if (me.ts_Type.is("ChangeAbs")) {
                        _v = me.timeseriesAttrib.getFormattedValue(d._value - ref);
                    }
                    recordChange = ` <span class='extraInfo'>(${_v} vs. ${_key})</span>`;
                }
                var x;
                var fullValue = recordValue + _recordRank + recordChange;
                if (me.timeSeriesSelectMode.is("time")) {
                    x = `<span class='asdsdadsada'>${recordText}: <b>${fullValue}</b></span>`;
                }
                else {
                    x =
                        `<span class='mapItemName'>${recordText}</span>` +
                            "<div class='recordColorInfo'>" +
                            "<div class='mapTooltipLabel'>" +
                            `<b>${me.timeseriesAttrib.attribName}</b>` +
                            ` <i class='fal fa-calendar'></i> ${d._time_src}` +
                            "</div><br>" +
                            `<span class='mapTooltipValue'>${fullValue}</span>` +
                            "</div>";
                }
                d.DOM.tippy.popper.children[0].children[0].innerHTML =
                    purify.sanitize(x);
            }
            var spacer_left = new LabelSpacer();
            var spacer_right = new LabelSpacer();
            function pofff(c, record, _placement = "right") {
                if (!c.DOM)
                    return; // no tooltip
                c.DOM.tippy = tippy(c.DOM, Object.assign({}, d3$a.selection.tippyDefaultConfig, {
                    theme: "dark kshf-tooltip kshf-record",
                    placement: _placement,
                    animation: "fade",
                    trigger: "manual",
                    delay: 0,
                    duration: [500, 100],
                    appendTo: Base.browser.DOM.root.node(),
                }));
                refreshDotTooltip(c);
                c.DOM.tippy.show();
            }
            this.DOM.recordBase_Timeseries = this.DOM.recordDisplayWrapper
                .append("div")
                .attr("class", "recordBase_Timeseries");
            this.refreshTimeSeriesChartWidth();
            // Y & X axis
            ["Y", "X"].forEach((a) => {
                var _ = this.DOM.recordBase_Timeseries
                    .append("div")
                    .attr("class", "recordAxis recordAxis_" + a);
                _.append("div").attr("class", "tickGroup");
                _.append("div")
                    .attr("class", "keyLine")
                    .style("display", this.isTimeseriesChange() ? "block" : null);
            });
            // X-axis min/max time key setting
            ["min", "max"].forEach((limit) => {
                var __ = this.DOM.recordBase_Timeseries
                    .append("span")
                    .attr("class", "timeLimit timeLimit-" + limit);
                __.append("select").on("change", (event) => {
                    this.setTimeRange({
                        [limit]: event.currentTarget.selectedOptions[0].__data__._index,
                    });
                });
                __.append("span").attr("class", limit === "min"
                    ? "far fa-angle-double-right"
                    : "far fa-angle-double-left");
            });
            this.refreshTimeSeriesRangeOpts();
            // ******************************************************
            this.DOM.recordGroup = this.DOM.recordBase_Timeseries
                .append("svg")
                .attr("class", "recordGroup recordGroup_Timeseries")
                .attr("xmlns", "http://www.w3.org/2000/svg")
                .on("click", () => {
                if (this.rd.visMouseMode === "filter")
                    return;
                if (prevClosestRecord) {
                    hideAllPoppers();
                    this.browser.recordDetailsPopup.updateRecordDetailPanel(prevClosestRecord);
                    this.browser.recordDetailsPopup.updateFocusedTimeKey(prevClosestTime);
                }
                this.rd.setDimmed(false);
            })
                .on("mouseleave", () => {
                if (this.rd.visMouseMode === "filter")
                    return;
                if (this.timeSeriesSelectMode.is("time")) {
                    hideAllPoppers();
                    this.browser.records.forEach((record) => {
                        var _c, _d, _e;
                        // remove "visible" from dots
                        if (record.filteredOut)
                            return;
                        if (!prevClosestTime)
                            return;
                        (_e = (_d = (_c = this.timeseriesAttrib.getRecordValue(record)) === null || _c === void 0 ? void 0 : _c._keyIndex[prevClosestTime._time_src]) === null || _d === void 0 ? void 0 : _d.DOM) === null || _e === void 0 ? void 0 : _e.classList.remove("visible");
                    });
                    prevClosestTime = null;
                }
                this.rd.onRecordMouseLeave(prevClosestRecord);
                prevClosestRecord = null;
            })
                .on("mousemove", (event) => {
                var _c, _d, _e;
                if (this.rd.visMouseMode === "filter")
                    return;
                var _m = d3$a.pointer(event);
                if (_m[1] > event.currentTarget.offsetHeight || _m[1] < 0) {
                    // out of chart bounds
                    if (this.timeSeriesSelectMode.is("record")) {
                        this.rd.onRecordMouseLeave(prevClosestRecord);
                        prevClosestRecord = null;
                    }
                    if (this.timeSeriesSelectMode.is("time") && prevClosestTime) {
                        hideAllPoppers();
                        this.browser.records.forEach((record) => {
                            var _c, _d, _e;
                            if (record.filteredOut)
                                return;
                            if (!prevClosestTime)
                                return;
                            (_e = (_d = (_c = this.timeseriesAttrib
                                .getRecordValue(record)) === null || _c === void 0 ? void 0 : _c._keyIndex[prevClosestTime._time_src]) === null || _d === void 0 ? void 0 : _d.DOM) === null || _e === void 0 ? void 0 : _e.classList.remove("visible");
                        });
                    }
                    return;
                }
                var _m_Time = this.scale_Time.invert(_m[0]);
                var _compareKey = ((_c = this.timeSeriesChangeVsTimeKey.get()) === null || _c === void 0 ? void 0 : _c._time_src) || null;
                var closestTimeKey = null;
                if (_m_Time.getTime() <= this.scale_Time.domain()[1].getTime() &&
                    _m_Time.getTime() >= this.scale_Time.domain()[0].getTime()) {
                    var closestTimeDist = 999999999999999;
                    this.timeKeys_Active.every((timeKey) => {
                        var _dist = Math.abs(timeKey._time.getTime() - _m_Time.getTime());
                        if (_dist < closestTimeDist) {
                            closestTimeKey = timeKey;
                            closestTimeDist = _dist;
                            return true;
                        }
                        return false; // getting farther away. We already found the closest
                    });
                }
                // Select closest time
                if (this.timeSeriesSelectMode.is("time")) {
                    if (closestTimeKey === prevClosestTime)
                        return;
                    if (prevClosestTime) {
                        hideAllPoppers();
                        this.browser.records.forEach((record) => {
                            var _c, _d, _e;
                            if (record.filteredOut)
                                return;
                            (_e = (_d = (_c = this.timeseriesAttrib.getRecordValue(record)) === null || _c === void 0 ? void 0 : _c._keyIndex[prevClosestTime._time_src]) === null || _d === void 0 ? void 0 : _d.DOM) === null || _e === void 0 ? void 0 : _e.classList.remove("visible");
                        });
                    }
                    if (closestTimeKey) {
                        spacer_right.clear();
                        spacer_left.clear();
                        this.browser.records.forEach((record) => {
                            var _c, _d;
                            if (!this.recordInView(record) || record.filteredOut)
                                return;
                            var c = (_c = this.timeseriesAttrib.getRecordValue(record)) === null || _c === void 0 ? void 0 : _c._keyIndex[closestTimeKey._time_src];
                            if (!c)
                                return;
                            c.DOM.classList.add("visible"); // timeSeriesDot
                            var placement;
                            var ref = this.isTimeseriesChange()
                                ? (_d = this.timeseriesAttrib.getRecordValue(record)) === null || _d === void 0 ? void 0 : _d._keyIndex[_compareKey]._value
                                : 0;
                            var top = this.y_Generator(c, ref);
                            if (spacer_right.isEmpty(top)) {
                                placement = "right";
                                spacer_right.insertUsed(top, 30, record);
                            }
                            else if (spacer_left.isEmpty(top)) {
                                placement = "left";
                                spacer_left.insertUsed(top, 30, record);
                            }
                            else {
                                return;
                            }
                            pofff(c, record, placement);
                        });
                    }
                    prevClosestTime = closestTimeKey;
                    return;
                }
                // Select closest point
                var closestRecord = null;
                if (!closestTimeKey) {
                    this.rd.onRecordMouseLeave(prevClosestRecord);
                    prevClosestRecord = null;
                    return;
                }
                var closestValueDist = 999999999999999;
                this.browser.records.forEach((record) => {
                    var _c, _d;
                    if (!this.recordInView(record) || record.filteredOut)
                        return;
                    var _ = (_c = this.timeseriesAttrib.getRecordValue(record)) === null || _c === void 0 ? void 0 : _c._keyIndex[closestTimeKey._time_src];
                    if (!_)
                        return;
                    var ref = this.isTimeseriesChange()
                        ? (_d = this.timeseriesAttrib.getRecordValue(record)) === null || _d === void 0 ? void 0 : _d._keyIndex[_compareKey]._value
                        : 0;
                    var _v = this.y_Generator(_, ref);
                    var _dist = Math.abs(_v - _m[1]);
                    if (_dist < 50 && _dist < closestValueDist) {
                        closestRecord = record;
                        closestValueDist = _dist;
                    }
                });
                if (prevClosestRecord !== closestRecord) {
                    this.rd.onRecordMouseLeave(prevClosestRecord);
                    prevClosestRecord = null;
                    if (closestRecord) {
                        this.rd.onRecordMouseOver(closestRecord);
                        var c = (_d = this.timeseriesAttrib.getRecordValue(closestRecord)) === null || _d === void 0 ? void 0 : _d._keyIndex[closestTimeKey._time_src];
                        if (c) {
                            pofff(c);
                        }
                    }
                    prevClosestRecord = closestRecord;
                }
                else if (closestRecord) {
                    // maybe record is the same, but the time changed?
                    if (prevClosestTime !== closestTimeKey) {
                        hideAllPoppers();
                        var c = (_e = this.timeseriesAttrib.getRecordValue(closestRecord)) === null || _e === void 0 ? void 0 : _e._keyIndex[closestTimeKey._time_src];
                        if (c) {
                            pofff(c);
                        }
                    }
                }
                prevClosestTime = closestTimeKey;
                this.rd.setDimmed(!!prevClosestRecord);
            });
            this.DOM.recordLineClippath = this.DOM.recordGroup
                .append("clipPath")
                .attr("id", "recordLineClippath")
                .append("rect")
                .attr("x", 0)
                .attr("y", 0)
                .attr("height", 4000);
            // annotations
            this.DOM.ts_annotations = this.DOM.recordBase_Timeseries
                .append("span")
                .attr("class", "ts_annotations");
            this.DOM.recordBase_Timeseries
                .append("div")
                .attr("class", "TimeseriesColorInfo")
                .html(i18n["Line colors are random"]);
            // ******************************************************
            this.DOM.timeSeriesControlGroup = this.DOM.recordBase_Timeseries
                .append("div")
                .attr("class", "timeSeriesControlGroup attribControlGroup");
            this.rd.initDOM_AttribSelect("timeSeries");
            // ******************************************************
            this.DOM.timeAnimationClearRange.on("click", () => this.setTimeRange({ min: 0, max: 10000 })); // max is just a very large number
            noUiSlider.create(this.DOM.timeseriesRange.node(), {
                start: [50, 50],
                connect: true,
                step: 1,
                behaviour: "tap-drag",
                margin: 1,
                range: {
                    min: 0,
                    max: 100,
                },
            });
            this.timeseriesRange = this.DOM.timeseriesRange.node().noUiSlider;
            var _update_2 = (_values, _handle, unencoded) => {
                if (this.timeseriesRange_noUpdate)
                    return;
                unencoded = unencoded.map((_) => Math.round(_));
                this.timeseriesRange_noUpdate = true;
                this.setTimeRange({ min: unencoded[0], max: unencoded[1] });
                delete this.timeseriesRange_noUpdate;
            };
            this.timeseriesRange.on("set", _update_2);
        });
    }
    /** -- */
    isTimeseriesChange() {
        return this.ts_Type.is("ChangePct") || this.ts_Type.is("ChangeAbs");
    }
    extendRecordDOM(newRecords) {
        newRecords.append("path");
        newRecords.append("g").attr("class", "dotGroup");
        newRecords
            .append("foreignObject")
            .attr("width", "120")
            .attr("height", "1")
            .call((fO) => {
            fO.append("xhtml:div")
                .attr("xmlns", "http://www.w3.org/1999/xhtml")
                .attr("class", "recordText_side")
                .html((record) => { var _c; return (_c = this.textBriefAttrib) === null || _c === void 0 ? void 0 : _c.renderRecordValue(record); });
            fO.append("xhtml:div")
                .attr("xmlns", "http://www.w3.org/1999/xhtml")
                .attr("class", "recordText_Dot");
        });
    }
    // ********************************************************************
    // Time range
    // ********************************************************************
    /** -- Parameters are integer index of the active timeseries attribute timekeys */
    setTimeRange({ min = -1, max = -1 } = {}) {
        if (min >= 0) {
            this.timeRange.min = this.timeseriesAttrib.timeKeys[min];
        }
        if (max >= 0) {
            max = Math.min(max, this.timeseriesAttrib.timeKeys.length - 1);
            this.timeRange.max = this.timeseriesAttrib.timeKeys[max];
        }
        this.refreshTimeRange();
    }
    /** -- */
    refreshTimeRange() {
        var _c, _d;
        this.refreshScaleTime();
        this.refreshTimeseriesTicks();
        if (this.timeRange.min._time > ((_c = this.timeSeriesChangeVsTimeKey.get()) === null || _c === void 0 ? void 0 : _c._time)) {
            this.timeSeriesChangeVsTimeKey.set(this.timeRange.min);
            this.refreshTimeSeriesRangeOpts(); // updates combobox for vs.
        }
        else if (this.timeRange.max._time < ((_d = this.timeSeriesChangeVsTimeKey.get()) === null || _d === void 0 ? void 0 : _d._time)) {
            this.timeSeriesChangeVsTimeKey.set(this.timeRange.max);
            this.refreshTimeSeriesRangeOpts(); // updates combobox for vs.
        }
        else {
            this.refreshScaleValue();
        }
    }
    /** -- */
    refreshTimeSeriesRangeOpts() {
        ["min", "max"].forEach((limit) => {
            this.DOM.root
                .select(".timeLimit-" + limit)
                .classed("filtered", this.timeRange.isActive(limit));
            this.DOM.root
                .select(".timeLimit-" + limit + " > select")
                .selectAll("option")
                .data(this.timeseriesAttrib.timeKeys.filter(limit === "min"
                ? (key) => key._time < this.timeRange.max._time
                : (key) => key._time > this.timeRange.min._time), (d) => d._time_src)
                .join((enter) => enter.append("option").text((d) => d._time_src), (update) => update, (exit) => exit.remove())
                .attr("selected", (d) => d._time_src === this.timeRange[limit]._time_src ? true : null);
        });
    }
    refreshAttribScaleType(attrib) {
        return __awaiter(this, void 0, void 0, function* () {
            if (attrib instanceof Attrib_Timeseries &&
                this.timeseriesAttrib === attrib) {
                yield this.ts_valueAxisScale.set(attrib.valueScaleType.get()); // apply it back to the attribute
                if (this.ts_Type.is("Value")) {
                    this.refreshScaleValue();
                }
            }
        });
    }
    finishSetAttrib(t) {
        return __awaiter(this, void 0, void 0, function* () {
            if (t === "textBrief") {
                this.DOM.kshfRecords
                    .selectAll("foreignObject > .recordText_side")
                    .html((record) => this.textBriefAttrib.renderRecordValue(record));
                //
            }
            else if (t === "timeSeries") {
                this.scale_Time = this.timeseriesAttrib.timeSeriesScale_Time.copy();
                if (!this.timeRange.min ||
                    !this.timeseriesAttrib.timeKeys.some((_) => _._time_src === this.timeRange.min._time_src) ||
                    !this.timeRange.max ||
                    !this.timeseriesAttrib.timeKeys.some((_) => _._time_src === this.timeRange.max._time_src)) {
                    this.setTimeRange({ min: 0, max: 10000 });
                }
                yield this.ts_valueAxisScale.set(this.timeseriesAttrib.valueScaleType.get());
                if (this.ts_Type.is("Rank")) {
                    this.timeseriesAttrib.computeRecordRanks();
                }
                if (!this.timeSeriesChangeVsTimeKey.get()) {
                    yield this.timeSeriesChangeVsTimeKey.set(this.rd.config.timeSeriesChangeVsTimeKey);
                }
                this.refreshScaleTime();
                this.refreshScaleValue();
                this.refreshFilterRanges();
            }
        });
    }
    /** -- */
    refreshViewSize(_delayMS = 0) {
        this.refreshScaleTime();
        this.refreshRecordVis();
        this.refreshTimeseriesTicks();
        this.refreshTicks_AxisY();
        this.updateDotVisibility();
    }
    // ********************************************************************
    // Scale of time and values
    // ********************************************************************
    /** -- */
    refreshScaleTime() {
        if (!this.timeseriesAttrib)
            return;
        if (!this.timeseriesRange)
            return;
        this.scale_Time_prev = this.scale_Time.copy();
        this.scale_Time.domain([
            this.timeRange.min._time,
            this.timeRange.max._time,
        ]);
        var timeKeys = this.timeseriesAttrib.timeKeys;
        this.timeKeys_Active = timeKeys.filter((key) => key._time >= this.timeRange.min._time &&
            key._time <= this.timeRange.max._time);
        if (this.ts_timeKeysStep.is("limits")) {
            this.timeKeys_Active = [
                this.timeKeys_Active[0],
                this.timeKeys_Active[this.timeKeys_Active.length - 1],
            ];
            if (this.isTimeseriesChange()) {
                this.timeKeys_Active.splice(1, 0, this.timeSeriesChangeVsTimeKey.get());
            }
        }
        this.timeSeriesChangeVsTimeKey.refresh();
        this.marginLeft = 85;
        this.chartWidth = this.rd.curWidth - this.marginTotal;
        this.expandMargin();
        this.scale_Time.range([0, this.chartWidth]);
        // first time setting scale_Time should also reset prev to current
        if (!this.scale_Time_prev) {
            this.scale_Time_prev = this.scale_Time.copy();
        }
        this.refreshTimeSeriesChartWidth();
        this.refreshTimeSeriesRangeOpts();
        this.timeseriesRange_noUpdate = true;
        this.timeseriesRange.updateOptions({
            range: {
                min: 0,
                max: timeKeys.length - 1,
            },
        });
        delete this.timeseriesRange_noUpdate;
        // "false" avoid firing the "set" event
        this.timeseriesRange.setHandle(0, this.timeRange.min._index, false);
        this.timeseriesRange.setHandle(1, this.timeRange.max._index, false);
        this.DOM.timeAnimation.select(".rangeTick-min").html(timeKeys[0]._time_src);
        this.DOM.timeAnimation
            .select(".rangeTick-max")
            .html(timeKeys[timeKeys.length - 1]._time_src);
        this.DOM.timeAnimation
            .select(".clearRange")
            .classed("active", this.timeRange.isActive());
        this.addAnnotations();
    }
    /** -- */
    refreshScaleValue() {
        if (!this.ts_Type)
            return;
        if (!this.timeseriesAttrib)
            return;
        // RANK    *****************************************************
        if (this.ts_Type.is("Rank")) {
            var timeDomain = this.scale_Time.domain();
            var inTimeDomain = (d) => true;
            if (timeDomain) {
                inTimeDomain = (d) => d._time >= timeDomain[0] && d._time <= timeDomain[1];
            }
            // count number of records with data within the time domain
            var maxNumRecords = this.browser.records.reduce((accumulator, currentRecord) => {
                if (currentRecord.filteredOut)
                    return accumulator;
                var _val = this.timeseriesAttrib.getRecordValue(currentRecord);
                if (!_val)
                    return accumulator;
                // consider only values that are inTimeDomain
                if (_val._timeseries_.filter(inTimeDomain).length === 0) {
                    return accumulator;
                }
                return accumulator + 1;
            }, 0);
            this.scale_Value = d3$a.scaleLinear().domain([maxNumRecords, 1]);
        }
        // VALUE   *****************************************************
        if (this.ts_Type.is("Value")) {
            this.scale_Value = this.timeseriesAttrib.timeSeriesScale_Value
                .copy()
                .nice();
            var new_domain = this.timeseriesAttrib.getExtent_Value(this.fitValueAxis.get(), // onlyFiltered
            this.scale_Time.domain() // in current domain
            );
            var _domain = this.scale_Value.domain();
            if (_domain[0] > _domain[1])
                new_domain = [new_domain[1], new_domain[0]]; // flip domain
            this.scale_Value.domain(new_domain);
        }
        // CHANGE   *****************************************************
        if (this.isTimeseriesChange()) {
            if (!this.timeSeriesChangeVsTimeKey.get()) {
                this.timeSeriesChangeVsTimeKey.set(this.timeKeys_Active[0]);
            }
            var _key = this.timeSeriesChangeVsTimeKey.get()._time_src;
            var timeDomain = this.scale_Time.domain();
            var inTimeDomain = (d) => d._time >= timeDomain[0] && d._time <= timeDomain[1];
            var vizVal;
            if (this.ts_Type.is("ChangeAbs")) {
                vizVal = (v, ref) => v._value - ref;
            }
            else if (this.ts_Type.is("ChangePct")) {
                vizVal = (v, ref) => 100 * ((v._value - ref) / ref);
            }
            var x = this.browser.records.map((record) => {
                if (!this.recordInView(record) || record.filteredOut) {
                    return [0, 0];
                }
                var r_ts = this.timeseriesAttrib.getRecordValue(record);
                var ref = r_ts._keyIndex[_key]._value;
                if (!ref)
                    return [0, 0];
                return d3$a.extent(r_ts._timeseries_, (v) => inTimeDomain(v) ? vizVal(v, ref) : null);
            });
            this.scale_Value = d3$a
                .scaleLinear()
                .domain([d3$a.min(x, (x) => x[0]), d3$a.max(x, (x) => x[1])])
                .nice();
        }
        // FINALIZE ******************************************************
        this.refreshRecordVis();
        this.refreshTicks_AxisY();
        this.refreshFilterRanges();
    }
    /** -- */
    refreshYGenerator() {
        this.y_Generator = {
            Value: (d) => this.scale_Value(d._value),
            ChangePct: (d, ref) => this.scale_Value(ref ? (100 * (d._value - ref)) / ref : 0),
            ChangeAbs: (d, ref) => this.scale_Value(d._value - ref),
            Rank: (d) => this.scale_Value(d._rank),
        }[this.ts_Type.get()];
    }
    /** VALUE AXIS */
    refreshTicks_AxisY() {
        var screenHeight = Math.abs(this.scale_Value.range()[1] - this.scale_Value.range()[0]);
        var targetNumTicks = Math.floor(screenHeight / 40); // one tickevery 40 pixels
        var _scale = this.scale_Value.copy();
        if (_scale.base)
            _scale.base(10);
        var ticks = _scale.ticks(targetNumTicks);
        // if the values are integer only, keep only integer values here.
        if (!this.timeseriesAttrib.hasFloat || this.ts_Type.is("Rank")) {
            ticks = ticks.filter((d) => d % 1 === 0);
        }
        if (this.ts_Type.is("Rank")) {
            ticks.unshift(1);
            ticks = ticks
                .sort((a, b) => b - a)
                // keep unique values onlu=y
                .reduce((accumulator, currentValue) => {
                if (accumulator[accumulator.length - 1] !== currentValue)
                    accumulator.push(currentValue);
                return accumulator;
            }, []);
        }
        var tickTextFunc = {
            Rank: (tick) => "# " + d3$a.format("d")(tick),
            ChangePct: (tick) => (tick > 0 ? "+" : "") + d3$a.format(".3s")(tick) + "%",
            ChangeAbs: (tick) => (tick > 0 ? "+" : "") + this.timeseriesAttrib.printAbbr(tick, true),
            Value: (tick) => this.timeseriesAttrib.getFormattedValue(tick, true),
        }[this.ts_Type.get()];
        var timeAxisDOM = this.DOM.root.select(".recordBase_Timeseries .recordAxis_Y > .tickGroup");
        var visiblePos = 0;
        timeAxisDOM
            .selectAll(".hmTicks")
            .data(ticks.reverse(), (t) => t) // reverse from decreasing to increasing order
            .join((enter) => enter
            .append("div")
            .attr("class", "hmTicks")
            .classed("zero", (tick) => tick === 0)
            .style("opacity", 0)
            .call((hmTicks) => {
            hmTicks.append("div").attr("class", "tickLine");
            hmTicks.append("div").attr("class", "tickText tickText_1");
            hmTicks.transition().delay(500).duration(0).style("opacity", 1);
        }), (update) => update, (exit) => {
            exit
                .style("transform", (tick) => "translateY(" + this.scale_Value(tick) + "px) translateZ(0)")
                .style("opacity", 0)
                .transition()
                .duration(0)
                .delay(500)
                .remove();
        })
            .style("transform", (tick) => "translateY(" + this.scale_Value(tick) + "px) translateZ(0)")
            .classed("hideLabel", (tick) => {
            var pos = this.scale_Value(tick);
            if (pos >= visiblePos) {
                visiblePos = pos + 20;
                return false;
            }
            return true;
        })
            .call((ticks) => {
            ticks.selectAll(".tickText").html(tickTextFunc);
        });
    }
    refreshFilterRanges() {
        this.DOM.root
            .selectAll(".recordBase_Timeseries .recordAxis_X > .tickGroup > .hmTicks")
            .each((tick) => {
            tick._histogram = this.timeseriesAttrib.timeKeyAttribs[tick._time_src];
        })
            .classed("isFiltered", (tick) => { var _c; return ((_c = tick._histogram) === null || _c === void 0 ? void 0 : _c.isFiltered()) && this.ts_Type.is("Value"); })
            .filter((tick) => { var _c; return ((_c = tick._histogram) === null || _c === void 0 ? void 0 : _c.isFiltered()) && this.ts_Type.is("Value"); })
            .selectAll(".filterArea")
            .style("height", (event) => {
            var d = _DOM.parentNode.__data__;
            var _DOM = event.currentTarget;
            var attrib = d._histogram;
            var _a = this.scale_Value(attrib.summaryFilter.active.minV);
            var _b = this.scale_Value(attrib.summaryFilter.active.maxV);
            var _domain = this.scale_Value.domain();
            var flipped = _domain[0] > _domain[1];
            _DOM._minn = flipped ? _b : _a;
            _DOM._maxx = flipped ? _a : _b;
            // That's where printing happens
            d3$a.select(_DOM.childNodes[flipped ? 1 : 0]).html(attrib.printAbbr(attrib.summaryFilter.active.minV));
            d3$a.select(_DOM.childNodes[flipped ? 0 : 1]).html(attrib.printAbbr(attrib.summaryFilter.active.maxV));
            return Math.abs(_DOM._maxx - _DOM._minn) + 14 + "px";
        })
            .style("top", (event) => {
            var _domain = this.scale_Value.domain();
            if (_domain[0] > _domain[1])
                return event.currentTarget._minn - 5 + "px";
            return event.currentTarget._maxx - 5 + "px";
        });
    }
    /** -- */
    get marginRight() {
        return 150;
    }
    /** -- */
    get marginTotal() {
        return this.marginLeft + this.marginRight;
    }
    /** -- */
    isMarginExpandable() {
        var maxWidth = 200 * (this.timeKeys_Active.length - 1);
        return maxWidth < this.rd.curWidth - this.marginTotal;
    }
    /** -- */
    expandMargin() {
        if (this.wideTimeScale)
            return;
        // shrink the width if there are few time keys active
        var maxWidth = 200 * (this.timeKeys_Active.length - 1);
        if (maxWidth < this.chartWidth) {
            this.marginLeft += (this.chartWidth - maxWidth) / 2;
            this.chartWidth = maxWidth;
        }
    }
    /** -- */
    refreshTimeSeriesChartWidth() {
        var _c, _d;
        (_c = this.DOM.recordBase_Timeseries) === null || _c === void 0 ? void 0 : _c.style("width", this.chartWidth + "px").style("left", this.marginLeft + "px");
        (_d = this.DOM.recordLineClippath) === null || _d === void 0 ? void 0 : _d.attr("width", this.chartWidth);
    }
    /** -- */
    updateRecordVisibility() {
        this.refreshLabelOverlaps();
    }
    /** -- */
    refreshKeyLine() {
        if (!this.timeseriesAttrib)
            return;
        if (!this.timeSeriesChangeVsTimeKey.get())
            return;
        this.DOM.root
            .select(".recordAxis_X > .keyLine")
            .style("transform", `translateX(${this.scale_Time(this.timeSeriesChangeVsTimeKey.get()._time)})`);
    }
    /** -- */
    onRecordMouseLeave() {
        hideAllPoppers();
    }
    /** -- */
    onRecordMouseOver(record) {
        record.moveDOMtoTop();
    }
    /** -- */
    refreshTimeseriesTicks() {
        if (!this.timeseriesAttrib)
            return;
        var me = this;
        var timeAxisDOM = this.DOM.root.select(".recordBase_Timeseries .recordAxis_X > .tickGroup");
        var lastTickPos = -300;
        var maxChar = this.timeseriesAttrib.timeKeys.reduce((accum, key) => Math.max(accum, key._time_src.length), 0);
        var tickGapWidth = maxChar * 9;
        timeAxisDOM
            .selectAll(".hmTicks")
            .data(this.timeKeys_Active, (t) => t._time_src)
            .join((enter) => {
            var tk = enter
                .append("div")
                .attr("class", "hmTicks")
                .style("opacity", 1)
                .style("transform", (tick) => `translateX(${this.scale_Time_prev(tick._time)}px) translateZ(0)`)
                .call((tk) => tk
                .transition()
                .delay(0)
                .duration(0)
                .style("transform", (tick) => `translateX(${this.scale_Time(tick._time)}px) translateZ(0)`));
            var tickText = tk.append("div").attr("class", "tickText");
            tk.append("div").attr("class", "tickLine");
            tk.append("div")
                .attr("class", "timeSelectArea")
                .on("mousedown", (event, tick) => {
                if (event.which !== 1)
                    return; // only respond to left-click
                me.browser.DOM.root.classed("noPointerEvents", true);
                var DOM = event.currentTarget;
                var initPos = me.scale_Value.invert(d3$a.pointer(event)[1]);
                var histSummary = me.timeseriesAttrib.getTimepointSummary(tick);
                d3$a.select("body")
                    .on("mousemove.test", () => {
                    var targetPos = me.scale_Value.invert(d3$a.pointer(event, DOM)[1]);
                    var _min = initPos > targetPos ? targetPos : initPos;
                    var _max = initPos > targetPos ? initPos : targetPos;
                    if (me.ts_Type.is("Rank")) {
                        var _minRank = Math.floor(_min);
                        var _maxRank = Math.ceil(_max);
                        me.browser.records.forEach((r) => {
                            var mm = r.getValue(this.timeseriesAttrib)._keyIndex;
                            if (mm) {
                                var dasds = mm[tick._time_src];
                                if (dasds) {
                                    if (dasds._rank === _minRank)
                                        _min = dasds._value;
                                    if (dasds._rank === _maxRank)
                                        _max = dasds._value;
                                }
                            }
                        });
                        // find records with these limit ranks
                    }
                    histSummary.setRangeFilter_Custom(_min, _max);
                    me.refreshFilterRanges();
                })
                    .on("mouseup.test", () => {
                    me.browser.DOM.root.classed("noPointerEvents", false);
                    d3$a.select("body")
                        .on("mousemove.test", null)
                        .on("mouseup.test", null);
                });
                event.preventDefault();
            });
            var filterArea = tk
                .append("div")
                .attr("class", "filterArea")
                .on("mousedown", (event, tick) => {
                if (event.which !== 1)
                    return; // only respond to left-click
                me.browser.DOM.root.classed("noPointerEvents", true);
                var e = event.currentTarget.parentNode.childNodes[2]; // selectArea. TODO: Make this harder to fail!
                var DOM = event.currentTarget;
                DOM.classList.add("dragging");
                var histSummary = me.timeseriesAttrib.getTimepointSummary(tick);
                var initPos = me.scale_Value.invert(d3$a.pointer(event, e)[1]);
                d3$a.select("body")
                    .on("mousemove.test", () => {
                    var curPos = me.scale_Value.invert(d3$a.pointer(event, e)[1]);
                    histSummary.setRangeFilter_Custom(Math.min(initPos, curPos), Math.max(initPos, curPos));
                })
                    .on("mouseup.test", () => {
                    me.browser.DOM.root.classed("noPointerEvents", false);
                    DOM.classList.remove("dragging");
                    d3$a.select("body")
                        .on("mousemove.test", null)
                        .on("mouseup.test", null);
                });
                event.preventDefault();
            });
            tickText
                .append("span")
                .attr("class", "clearFilterButton fa")
                .tooltip(i18n.RemoveFilter)
                .on("click", (tick) => {
                var _ = this.timeseriesAttrib.getTimepointSummary(tick);
                if (_)
                    _.summaryFilter.clearFilter();
            });
            tickText
                .append("span")
                .attr("class", "theTextText")
                .html((tick) => tick._time_src);
            tickText
                .append("span")
                .attr("class", "openTimepointSummary fa fa-external-link-square")
                .tooltip("Create Time-Key<br>Histogram")
                .on("click", (tick) => {
                var newSummary = this.timeseriesAttrib.getTimepointSummary(tick);
                newSummary.block.addToPanel(this.browser.panels.left);
                this.browser.updateLayout();
            });
            ["min", "max"].forEach(function (endType) {
                filterArea
                    .append("div")
                    .attr("class", "filterRangeValue filterRangeValue_" + endType)
                    .on("mousedown", function (event, tick) {
                    if (event.which !== 1)
                        return; // only respond to left-click
                    me.browser.DOM.root.classed("noPointerEvents", true);
                    var e = this.parentNode.parentNode.childNodes[2]; // selectArea. TODO: Make this harder to fail!
                    var _ = this.parentNode;
                    _.classList.add("dragging");
                    var histSummary = me.timeseriesAttrib.getTimepointSummary(tick);
                    d3$a.select("body")
                        .on("mousemove.range", function () {
                        var curVal = me.scale_Value.invert(d3$a.pointer(event, e)[1]);
                        histSummary.summaryFilter.active[endType] = curVal;
                        histSummary.summaryFilter.setFiltered(true);
                        me.refreshFilterRanges();
                    })
                        .on("mouseup.range", function () {
                        _.classList.remove("dragging");
                        me.browser.DOM.root
                            .attr("adjustWidth", null)
                            .classed("noPointerEvents", false);
                        d3$a.select("body")
                            .style("cursor", "auto")
                            .on("mousemove.range", null)
                            .on("mouseup.range", null);
                    });
                    event.preventDefault();
                    event.stopPropagation();
                });
            });
            return tk;
        }, (update) => {
            return update.style("transform", (tick) => `translateX(${this.scale_Time(tick._time)}px) translateZ(0)`);
        }, (exit) => {
            return exit
                .transition()
                .duration(0)
                .delay(500)
                .style("transform", (tick) => `translateX(${this.scale_Time(tick._time)}px) translateZ(0)`)
                .style("opacity", 0)
                .remove();
        })
            .selectAll(".tickText")
            .style("display", (tick) => {
            var newTickPos = this.scale_Time(tick._time);
            if (newTickPos - lastTickPos < tickGapWidth)
                return "none";
            lastTickPos = newTickPos;
            return null;
        });
        this.refreshKeyLine();
    }
    /** -- */
    updateDotVisibility() {
        // based on chart size (width, height) and active (or truly visible) record count
        var recCount = this.browser.records.length -
            this.DOM.root.selectAll(".noTimeSeries, .filteredOut").nodes().length;
        this.browser.DOM.root.classed("noRecordDots", this.rd.curHeight / recCount < 100 ||
            this.rd.curWidth / this.timeKeys_Active.length < 30);
    }
    timeseriesWiden() {
        if (!this.isMarginExpandable())
            return;
        this.wideTimeScaleTimer = window.setTimeout(() => {
            this.wideTimeScale = true;
            this.refreshTimeRange();
        }, 500);
    }
    timeseriesWidenOff() {
        if (!this.wideTimeScaleTimer)
            return;
        window.clearTimeout(this.wideTimeScaleTimer);
        this.wideTimeScaleTimer = 0;
        if (this.wideTimeScale && !this.rd.timeseriesAnimInterval) {
            this.wideTimeScale = false;
            this.refreshTimeRange();
        }
    }
    stepTimeAnimation(stepSize) {
        this.wideTimeScale = true;
        var maxIndex = this.timeseriesAttrib.timeKeys.length - 1;
        // start from beginning
        if (this.timeRange.max._index >= maxIndex) {
            this.setTimeRange({ max: this.timeRange.min._index + 1 });
            window.setTimeout(() => this.rd.startTimeseriesAnimation(stepSize), this.animStepDelayMs); // adds double-wait, but works fine
            return true;
        }
        this.rd.timeseriesAnimInterval = window.setInterval(() => {
            if (this.timeRange.max._index >= maxIndex) {
                this.rd.stopTimeseriesAnimation();
            }
            else {
                this.setTimeRange({ max: this.timeRange.max._index + stepSize });
            }
        }, this.animStepDelayMs);
        return true;
    }
    stopTimeAnimation() {
        this.refreshTimeRange();
        this.wideTimeScale = false;
    }
    updateAfterFilter() {
        this.updateRecordVisibility();
        this.updateDotVisibility();
        this.fitValueAxis.refresh();
        if (this.ts_Type.is("Rank")) {
            this.timeseriesAttrib.computeRecordRanks();
            this.refreshScaleValue();
            //
        }
        else if (this.ts_Type.is("Value")) {
            if (!this.browser.isFiltered() || this.fitValueAxis.get()) {
                // resets to default scale
                this.refreshScaleValue();
            }
            else {
                this.rd.refreshRecordVis();
            }
        }
        else if (this.isTimeseriesChange()) {
            this.refreshScaleValue();
        }
        this.refreshLineOpacity();
    }
    /** -- */
    addAnnotations() {
        if (!this.rd.config.timeSeriesAnnotations)
            return;
        this.DOM.ts_annotations
            .selectAll("div.annotation")
            .data(this.rd.config.timeSeriesAnnotations
            .filter((_) => _._time <= this.timeRange.max._time)
            .filter((_) => _._time >= this.timeRange.min._time), (_) => _._time)
            .join((enter) => enter
            .append("div")
            .attr("class", "annotation")
            .call((annotation) => {
            annotation.append("div").attr("class", "line");
            annotation.append("div").attr("class", "annotIcon fa fa-clock");
            annotation
                .append("div")
                .attr("class", "textBox")
                .call((textBox) => {
                textBox
                    .append("div")
                    .attr("class", "timeText")
                    .text((_) => _._time_src);
                textBox
                    .append("div")
                    .attr("class", "freeText")
                    .text((_) => _._text);
            });
        }), (update) => update, (exit) => exit.remove())
            .style("left", (_) => this.scale_Time(_._time) + "px");
    }
    refreshLineOpacity() {
        var screenHeight = Math.abs(this.scale_Value.range()[1] - this.scale_Value.range()[0]);
        var _ratio = screenHeight / this.browser.allRecordsAggr.recCnt("Active");
        var _opacity = Math.max(0.4, Math.min(1.0, _ratio / 25)); // between 0.2 and 1
        var colorScheme = d3$a.schemeCategory10;
        var strokeWidth = 2;
        if (_ratio < 50) {
            strokeWidth = 2;
        }
        else if (_ratio < 70) {
            strokeWidth = 3;
        }
        else if (_ratio < 100) {
            strokeWidth = 4;
        }
        else {
            strokeWidth = 5;
        }
        this.DOM.kshfRecords
            .selectAll("path")
            .style("opacity", (r) => (((r.recordOrder % 3) + 10) / 11) * _opacity) // slight variation opacity to differentiate
            .style("stroke", (r) => colorScheme[r.recordOrder % 12])
            .style("stroke-width", strokeWidth);
        this.DOM.kshfRecords
            .selectAll(".recordText_Dot")
            .style("background-color", (r) => colorScheme[r.recordOrder % 12]);
    }
    /** -- */
    refreshLabelOverlaps() {
        var _c;
        if (!this.timeseriesAttrib)
            return;
        var maxTime = this.scale_Time.domain()[1].getTime();
        var lastTime = this.timeseriesAttrib.timeKeys.find((tk) => tk._time.getTime() === maxTime)._time_src;
        var spacer = new LabelSpacer();
        var _compareKey = ((_c = this.timeSeriesChangeVsTimeKey.get()) === null || _c === void 0 ? void 0 : _c._time_src) || null;
        this.browser.records.forEach((record) => {
            var _c;
            record._view._labelHidden = true;
            record._view._labelPos = 0;
            if (!record.filteredOut && this.recordInView(record)) {
                var _keyIndex = (_c = this.timeseriesAttrib.getRecordValue(record)) === null || _c === void 0 ? void 0 : _c._keyIndex;
                var v = _keyIndex[lastTime];
                if (v) {
                    var m = this.scale_Value(v._value);
                    if (m !== null && isFinite(m) && !isNaN(m)) {
                        record._view._labelHidden = false;
                        var ref = this.isTimeseriesChange()
                            ? _keyIndex[_compareKey]._value
                            : 0;
                        record._view._labelPos = this.y_Generator(v, ref);
                    }
                }
            }
            d3$a.select(record.DOM.record)
                .select("foreignObject")
                .classed("hidden", record._view._labelHidden);
        });
        var gapOffset = 14;
        Array.from(this.browser.records.filter((record) => !record._view._labelHidden))
            .sort((r1, r2) => r1._view._labelPos - r2._view._labelPos)
            .forEach((record) => {
            var fo = d3$a.select(record.DOM.record).select("foreignObject");
            var intersectsWith = spacer.intersectsWith(record._view._labelPos);
            var overlaps;
            if (intersectsWith) {
                let intersectsWithRecord = intersectsWith._entity;
                // intersectsWith is above current record
                // try to move it above to create extra space
                spacer.usedList = spacer.usedList.filter((_) => _._entity !== intersectsWithRecord);
                var _temp = Math.max(record._view._labelPos - gapOffset, intersectsWithRecord._view._labelPos - gapOffset / 2);
                if (spacer.isEmpty(_temp)) {
                    d3$a.select(intersectsWithRecord.DOM.record)
                        .select("foreignObject")
                        .attr("y", _temp - 8);
                    intersectsWithRecord._view._labelPos = _temp;
                }
                // insert back
                spacer.insertUsed(intersectsWithRecord._view._labelPos, gapOffset, intersectsWithRecord);
                var targetPos = Math.min(intersectsWithRecord._view._labelPos + gapOffset);
                if (spacer.isEmpty(targetPos) &&
                    targetPos <= record._view._labelPos + 10) {
                    record._view._labelPos = targetPos;
                }
                else {
                    overlaps = true;
                }
            }
            fo.classed("overlapping", overlaps);
            fo.attr("y", record._view._labelPos - 8);
            if (!overlaps) {
                spacer.insertUsed(record._view._labelPos, gapOffset, record);
            }
        });
    }
    /** -- */
    refreshTimeSeriesPlotType() {
        if (!this.ts_Type)
            return;
        if (!this.timeseriesAttrib)
            return;
        this.DOM.root.attr("data-ts_Type", this.ts_Type);
        this.refreshYGenerator();
        if (this.ts_Type.is("Rank")) {
            this.timeseriesAttrib.computeRecordRanks();
        }
        if (this.isTimeseriesChange()) {
            this.DOM.root.select(".MouseMode-filter").style("display", "none");
            if (this.rd.visMouseMode === "filter") {
                this.rd.visMouseMode = "pan";
                this.DOM.root.attr("visMouseMode", this.rd.visMouseMode);
            }
        }
        else {
            this.DOM.root.select(".MouseMode-filter").style("display", null);
        }
        this.DOM.root
            .select(".recordAxis_X > .keyLine")
            .style("display", this.isTimeseriesChange() ? "block" : null);
        this.refreshScaleValue();
    }
    /** -- */
    refreshRecordVis() {
        var _c;
        if (!this.ts_Type)
            return;
        if (!this.timeseriesAttrib)
            return;
        if (!this.DOM.recordBase_Timeseries)
            return;
        if (!this.DOM.kshfRecords)
            return;
        if (!this.y_Generator)
            return;
        if (!this.timeseriesAttrib.aggr_initialized)
            return;
        var x_Generator = (d) => this.scale_Time(d._time);
        var timeDomain = this.scale_Time.domain();
        var inTimeDomain = (d) => d._time >= timeDomain[0] && d._time <= timeDomain[1];
        // This basically extends the draw area +/- time keys. These are out of the screen, but helps
        // generate smooth looking animations.
        var timeKeys = this.timeseriesAttrib.timeKeys;
        var drawMinTime = timeKeys[Math.max(this.timeRange.min._index - 5, 0)]._time;
        var drawMaxTime = timeKeys[Math.min(this.timeRange.max._index + 5, timeKeys.length - 1)]
            ._time;
        var inWiderTimeDomain = (d) => d._time >= drawMinTime && d._time <= drawMaxTime;
        var _compareKey = ((_c = this.timeSeriesChangeVsTimeKey.get()) === null || _c === void 0 ? void 0 : _c._time_src) || "";
        var _refVal;
        var lineGenerator = d3$a
            .line()
            .curve(this.ts_Type.is("Rank") ? d3$a.curveLinear : d3$a.curveMonotoneX)
            .x(x_Generator)
            .y((d) => this.y_Generator(d, _refVal))
            .defined((d) => {
            if (!inWiderTimeDomain(d))
                return false;
            var v = this.y_Generator(d, _refVal);
            return v != null && isFinite(v) && !isNaN(v);
        });
        var topGap = 15;
        this.scale_Value.rangeRound([this.rd.curHeight - (topGap + 100), topGap]);
        var slopeOnly = this.ts_timeKeysStep.is("limits");
        var timeKeys_src = {};
        this.timeKeys_Active.forEach((_) => {
            timeKeys_src[_._time_src] = true;
        });
        var lineSelect = this.DOM.kshfRecords
            .attr("transform", null)
            .style("transform", null)
            .classed("noTimeSeries", (record) => !this.recordInView(record))
            .each((record, i, nodes) => {
            var _c;
            if (!this.recordInView(record) || record.filteredOut)
                return;
            var ts = this.timeseriesAttrib.getRecordValue(record);
            if (!ts)
                return;
            _refVal = (_c = ts._timeseries_.find((x) => x._time_src === _compareKey)) === null || _c === void 0 ? void 0 : _c._value;
            var td = ts._timeseries_.filter(inTimeDomain);
            if (slopeOnly) {
                td = td.filter((d) => timeKeys_src[d._time_src]);
            }
            d3$a.select(nodes[i])
                .select(".dotGroup")
                .selectAll(".timeSeriesDot")
                .data(td, (d) => d._time.getTime())
                .join((enter) => enter
                .append("circle")
                .attr("class", "timeSeriesDot")
                .attr("r", 3), (update) => update, (exit) => exit.remove())
                .each((d, i, nodes) => {
                d.DOM = nodes[i];
            })
                .attr("cx", x_Generator)
                .attr("cy", (d) => this.y_Generator(d, _refVal))
                .style("display", (d) => {
                var v = this.y_Generator(d, _refVal);
                return v != null && isFinite(v) && !isNaN(v) ? null : "none";
            });
        })
            .call((rec) => {
            rec
                .selectAll("foreignObject")
                .attr("x", this.scale_Time.range()[1] + 16)
                .on("mouseenter", (_event, record) => this.rd.onRecordMouseOver(record))
                .on("mouseleave", (_event, record) => this.rd.onRecordMouseLeave(record));
        })
            .selectAll("path")
            .attr("fill", "none");
        var dPath = (record) => {
            var _c, _d;
            if (record.filteredOut)
                return;
            var _td = (_c = this.timeseriesAttrib.getRecordValue(record)) === null || _c === void 0 ? void 0 : _c._timeseries_;
            if (!_td)
                return;
            _refVal = (_d = _td.find((x) => x._time_src === _compareKey)) === null || _d === void 0 ? void 0 : _d._value;
            if (slopeOnly) {
                _td = _td.filter((d) => timeKeys_src[d._time_src]);
            }
            return lineGenerator(_td);
        };
        if (this.rd.timeseriesAnimInterval) {
            var x_Generator_store = x_Generator;
            x_Generator = (d) => this.scale_Time_prev(d._time);
            lineGenerator.x(x_Generator);
            // no transition
            lineSelect.transition().duration(200).attr("d", dPath);
            x_Generator = x_Generator_store;
            lineGenerator.x(x_Generator);
        }
        // with transition
        lineSelect
            .transition()
            .duration(700)
            .ease(d3$a.easePoly.exponent(3))
            .delay(0)
            .attr("d", dPath);
        this.refreshLabelOverlaps();
        this.refreshLineOpacity();
    }
    refreshAttribUnitName(attrib) {
        this.refreshTicks_AxisY();
    }
}

const d3$9 = {
    select,
    pointer,
    geoPath,
    geoTransform,
    easePolyOut: polyOut,
    easePoly: polyInOut,
    interpolate,
    hsl,
    arc,
};
class RecordView_Map extends RecordView {
    extendRecordDOM(newRecords) {
        if (this.geoAttrib.geoType === "Point") {
            if (this.rd.config.mapUsePins) {
                newRecords
                    .append("path")
                    .attr("class", "glyph_Main")
                    .attr("d", Base.map.pinGlyphPath)
                    .attr("transform", "scale(0.0001)");
            }
            else {
                this.extendRecordDOM_Point(newRecords);
            }
        }
        else {
            newRecords.append("path").attr("class", "glyph_Main");
        }
    }
    /** -- */
    updateAfterFilter(how) {
        this.updateRecordVisibility();
        this.refreshRecordColors();
        if (this.geoAttrib.geoType === "Point") {
            this.refreshRecordVis();
        }
    }
    /** -- */
    refreshRecordSizes() {
        if (this.geoAttrib.geoType !== "Point")
            return;
        if (!this.DOM.recordGroup)
            return;
        var pathSelection = this.DOM.recordGroup
            .selectAll(".kshfRecord > path")
            .transition()
            .duration(700)
            .ease(d3$9.easePolyOut.exponent(3));
        if (!this.rd.config.mapUsePins) {
            pathSelection.attr("d", (record) => this.rd.recordDrawArc(record)());
            //
        }
        else {
            pathSelection.attr("transform", `scale(${this.rd.getMaxSizeScaleRange() / 15})`);
        }
        this.DOM.recordGroup
            .selectAll(".kshfRecord > .sizeValueText")
            .html((record) => record.measure_Self);
        this.refreshPointClusterVis();
    }
    /** -- */
    prepareAttribs() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.rd.codeBy.geo) {
                yield this.rd.setAttrib("geo", this.rd.config.geoBy || 0);
            }
            if (!this.rd.codeBy.color && this.rd.config.colorBy) {
                yield this.rd.setAttrib("color", this.rd.config.colorBy);
            }
            if (!this.rd.codeBy.size && this.rd.config.sizeBy) {
                yield this.rd.setAttrib("size", this.rd.config.sizeBy);
            }
            return Promise.resolve(true);
        });
    }
    initView() {
        if (!this.initialized) {
            this.zoomToFit();
        }
        if (this.geoAttrib.geoType === "Point") {
            this.refreshPointClusters();
        }
        this.refreshPointDOM();
        this.refreshRecordVis();
        this.refreshRecordColors();
        this.refreshRecordSizes();
        // width of color legend area may change, so refresh this
        this.rd.refreshColorLegend();
        this.rd.refreshSizeLegend(); // needed to reset usesSizeAttrib class
    }
    initView_DOM() {
        return __awaiter(this, void 0, void 0, function* () {
            // Do not initialize twice
            if (this.DOM.recordBase_Map) {
                this.DOM.recordGroup = this.DOM.recordMap_SVG.select(".recordGroup");
                this.DOM.kshfRecords = this.DOM.recordGroup.selectAll(".kshfRecord");
                this.DOM.kshfRecords_Path = this.DOM.recordGroup.selectAll(".kshfRecord > path.glyph_Main");
                this.leafletRecordMap.invalidateSize(); // chart area may have changed
                return;
            }
            if (!window.L) {
                yield import('./vendor_mapping.js').then(function (n) { return n.l; });
            }
            var me = this;
            this.DOM.recordBase_Map = this.rd.DOM.recordDisplayWrapper
                .append("div")
                .attr("class", "recordBase_Map");
            this.mapConfig = Util.mergeConfig(Base.map, this.rd.config.mapConfig || {});
            function resetPointSizes() {
                if (this.geoAttrib.geoType === "Point") {
                    if (!this.rd.config.mapUsePins) {
                        this.DOM.recordGroup
                            .selectAll(".kshfRecord > path")
                            .attr("d", Util.getCirclePath());
                    }
                    else {
                        this.DOM.recordGroup
                            .selectAll(".kshfRecord > path")
                            .attr("transform", "scale(0.0001)");
                    }
                }
            }
            this.leafletRecordMap = L.map(this.DOM.recordBase_Map.node(), this.mapConfig.leafConfig)
                .on("viewreset", function () {
                if (!this._zoomInit_)
                    return;
                this._zoomInit_ = null;
                me.rd.DOM.recordDisplayWrapper.classed("dragging", false);
                me.refreshRecordVis();
            })
                .on("movestart", function () {
                me.rd.DOM.recordDisplayWrapper.classed("dragging", true);
                me.browser.DOM.root.classed("noPointerEvents", true);
                resetPointSizes.call(me);
                this._zoomInit_ = this.getZoom();
            })
                .on("moveend", function () {
                me.rd.DOM.recordDisplayWrapper.classed("dragging", false);
                me.browser.DOM.root.classed("noPointerEvents", false);
                me.rd.refreshViz_Compare_All();
                me.rd.refreshRecordVis();
                this._zoomInit_ = null;
            })
                // When zoom is triggered by fly, the leaflet-zoom-anim is not set.
                .on("zoomstart", () => {
                resetPointSizes.call(this);
                d3$9.select(this.leafletRecordMap.getPane("mapPane"))
                    .classed("leaflet-zoom-anim", true);
            })
                .on("zoomend", () => {
                d3$9.select(this.leafletRecordMap.getPane("mapPane"))
                    .classed("leaflet-zoom-anim", false);
            });
            if (!this.mapConfig.tileConfig.disabled) {
                this.leafletRecordMap.addLayer(new L.TileLayer(this.mapConfig.tileTemplate, this.mapConfig.tileConfig));
            }
            this.leafletRecordMap.attributionControl.setPosition("topright");
            this.recordGeoPath = d3$9.geoPath().projection(d3$9.geoTransform({
                point: function (x, y) {
                    var point = me.leafletRecordMap.latLngToLayerPoint(new L.latLng(y, x));
                    this.stream.point(point.x, point.y);
                },
            }));
            this.recordGeoPath.pointRadius(this.rd.recordPointSize.get());
            this.DOM.recordBase_Map.select(".leaflet-tile-pane");
            this.DOM.recordMap_SVG = d3$9
                .select(this.leafletRecordMap.getPanes().overlayPane)
                .append("svg")
                .attr("xmlns", "http://www.w3.org/2000/svg")
                .attr("class", "recordMap_SVG");
            var _defs = this.DOM.recordMap_SVG.append("defs");
            _defs
                .append("filter")
                .attr("id", "pointDropShadow")
                .attr("height", "200%")
                .attr("width", "200%")
                .call((filter) => {
                filter
                    .append("feGaussianBlur")
                    .attr("in", "SourceAlpha")
                    .attr("stdDeviation", 3);
                filter
                    .append("feOffset")
                    .attr("dx", 2)
                    .attr("dy", 2)
                    .attr("result", "offsetblur");
                filter
                    .append("feComponentTransfer")
                    .append("feFuncA")
                    .attr("type", "linear")
                    .attr("slope", 0.5);
                filter.append("feMerge").call((merge) => {
                    merge.append("feMergeNode");
                    merge.append("feMergeNode").attr("in", "SourceGraphic");
                });
            });
            // The fill pattern definition in SVG, used to denote geo-objects with no data.
            // http://stackoverflow.com/questions/17776641/fill-rect-with-pattern
            _defs
                .append("pattern")
                .attr("id", "diagonalHatch")
                .attr("patternUnits", "userSpaceOnUse")
                .attr("width", 4)
                .attr("height", 4)
                .append("path")
                .attr("d", "M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2")
                .attr("stroke", "gray")
                .attr("stroke-width", 1);
            this.DOM.clusterGroup = this.DOM.recordMap_SVG
                .append("g")
                .attr("class", "leaflet-zoom-hide clusterGroup");
            this.DOM.recordGroup = this.DOM.recordMap_SVG
                .append("g")
                .attr("class", "leaflet-zoom-hide recordGroup");
        });
    }
    finishSetAttrib(t) {
        return __awaiter(this, void 0, void 0, function* () {
            if (t === "color") {
                this.refreshRecordColors();
                //
            }
            else if (t === "geo") {
                this.rd.config.geo = this.geoAttrib.attribName;
                this.DOM.root.attr("data-geotype", this.geoAttrib.geoType);
                this.DOM.root.select(".mapView-UnmatchedData")
                    .classed("active", this.geoAttrib.noValueAggr.records.length > 0);
                if (this.geoAttrib.geoType === "Point") {
                    this.geoAttrib.setPointClusterRadius(this.rd.config.pointClusterRadius, this.leafletRecordMap);
                    // size
                    if (!this.rd.codeBy.size && this.rd.config.sizeBy) {
                        yield this.rd.setAttrib("size", this.rd.config.sizeBy);
                    }
                    else {
                        this.rd.refreshAttribOptions("size");
                    }
                    // color
                    this.rd.refreshAttribOptions("color");
                    // prapare color cache
                    yield this.geoAttrib.prepPointCluster(this.leafletRecordMap);
                }
            }
        });
    }
    refreshSelect_Compare(cT = null, status = false) {
        if (!this.isComparable())
            return;
        // update rendering of point clusters
        if (this.rd.hasAggregates()) {
            // compute "offset" for each aggregate
            this.geoAttrib._aggrs.forEach((aggr) => {
                let _offset = 0;
                aggr._glyphOrder = {};
                // re-order the comparisons so that the larger ones come first
                this.browser.activeComparisons
                    .slice()
                    .sort((a, b) => aggr.measure(b) - aggr.measure(a))
                    .forEach((cT2, i_cT) => {
                    aggr._glyphOrder[cT2] = i_cT;
                    aggr.setOffset(cT2, _offset);
                    _offset += aggr.measure(cT2);
                });
            });
            const sideBySide = this.browser.stackedCompare.is(false);
            const numComparisons = this.browser.activeComparisonsCount;
            this.browser.activeComparisons.forEach((cT2) => {
                this.DOM["clusterGlyphs_" + cT2]
                    .style("stroke-width", (aggr) => {
                    if (!sideBySide)
                        return 0;
                    return aggr.cluster._radius / numComparisons;
                })
                    .transition()
                    .ease(d3$9.easePoly.exponent(3))
                    .duration(700)
                    .attrTween("d", (aggr, i, nodes) => {
                    const DOM = nodes[i];
                    const offset = sideBySide
                        ? 0
                        : aggr.offset(cT2) / (aggr.measure("Active") || 1);
                    const angleInterp = d3$9.interpolate(DOM._currentPreviewAngle, aggr.ratioToActive(cT2));
                    let r = aggr.cluster._radius;
                    if (sideBySide) {
                        r -=
                            (aggr._glyphOrder[cT2] + 0.5) *
                                (aggr.cluster._radius / numComparisons);
                    }
                    return (t) => {
                        const newAngle = angleInterp(t);
                        DOM._currentPreviewAngle = newAngle;
                        return Util.getPieSVGPath(offset, newAngle, r - 1, sideBySide);
                    };
                });
            });
        }
        // normal comparison rendering
        super.refreshSelect_Compare(cT, status);
    }
    constructor(rd, _config) {
        super(rd);
        this.zoomedBefore = false;
    }
    refreshQueryBox_Filter(bounds = null) {
        if (this.rd.collapsed)
            return;
        let isVisible = false;
        if (typeof L === "undefined") {
            throw Error("Leaflet not initialized");
        }
        let north_west, south_east;
        if (bounds === null) {
            isVisible = this.geoAttrib.isFiltered();
            if (!isVisible)
                return;
            north_west = this.leafletRecordMap.latLngToLayerPoint(this.geoAttrib.summaryFilter.bounds.getNorthWest());
            south_east = this.leafletRecordMap.latLngToLayerPoint(this.geoAttrib.summaryFilter.bounds.getSouthEast());
        }
        else if (!(bounds instanceof L.LatLngBounds)) {
            north_west = this.leafletRecordMap.latLngToLayerPoint(bounds.getNorthWest());
            south_east = this.leafletRecordMap.latLngToLayerPoint(bounds.getSouthEast());
        }
        else {
            throw Error("Invalud value");
        }
        let _left = north_west.x;
        let _right = south_east.x;
        let _top = north_west.y;
        let _bottom = south_east.y;
        this.rd.DOM.recordDisplayWrapper
            .select(".recordBase_Map  .spatialQueryBox_Filter")
            .classed("active", bounds || isVisible)
            .style("left", _left + "px")
            .style("top", _top + "px")
            .style("width", Math.abs(_right - _left) + "px")
            .style("height", Math.abs(_bottom - _top) + "px");
    }
    /** -- */
    refreshViewSize(delayMs = 500) {
        this.rd.refreshColorLegendTicks();
        setTimeout(() => this.leafletRecordMap.invalidateSize(), delayMs);
    }
    /** -- */
    refreshAttribUnitName(_attrib) {
        this.rd.refreshColorLegendTicks();
    }
    /** -- */
    zoomIn() {
        this.leafletRecordMap.zoomIn();
    }
    /** -- */
    zoomOut() {
        this.leafletRecordMap.zoomOut();
    }
    /** -- */
    zoomToFit() {
        if (!this.zoomedBefore) {
            if (this.rd.config.mapInitView) {
                var _c = this.rd.config.mapInitView;
                if (_c[3] === undefined || _c[3] === false) {
                    this.zoomedBefore = true;
                }
                this.leafletRecordMap.setView(L.latLng(_c[0], _c[1]), _c[2]);
                return;
            }
        }
        this.zoomToBounds(Util.addMarginToBounds(this.geoAttrib.getRecordBounds(true)));
    }
    /** -- */
    zoomToBounds(bounds) {
        this.rd.DOM.recordDisplayWrapper.classed("dragging", true);
        this.leafletRecordMap.fitBounds(bounds);
    }
    /** -- */
    setMaxBounds() {
        if (this.rd.config.map_NoFitBounds)
            return;
        this.leafletRecordMap.setMaxBounds(Util.addMarginToBounds(this.geoAttrib.getRecordBounds(false)));
    }
    translate_glyph(v) {
        let point = this.leafletRecordMap.latLngToLayerPoint(new L.latLng(v[1], v[0]));
        return `translate(${point.x},${point.y})`;
    }
    /** -- */
    refreshPointClusters() {
        var _a;
        if (!this.geoAttrib)
            return;
        if (((_a = this.geoAttrib) === null || _a === void 0 ? void 0 : _a.geoType) !== "Point")
            return;
        if (!this.geoAttrib.PointCluster)
            return;
        this.geoAttrib.updateClusters(this.leafletRecordMap.getBounds(), this.leafletRecordMap.getZoom());
        this.DOM.clusterGlyphs = this.DOM.clusterGroup
            .selectAll(".clusterGlyph")
            .data(this.geoAttrib._aggrs)
            .enter()
            .append("g")
            .attr("class", "clusterGlyph aggrGlyph")
            .each((aggr, i, nodes) => {
            aggr.setAggrGlyph(nodes[i]);
        })
            .tooltip((aggr) => aggr.getTooltipHTML(), {
            theme: "dark kshf-tooltip kshf-record",
            placement: "right",
            animation: "fade",
            followCursor: true,
            offset: [0, 5],
        })
            .attr("transform", (aggr) => this.translate_glyph(aggr.cluster.geometry.coordinates))
            //.on("mouseenter", aggr => this.browser.setSelect_Compare(aggr) )
            //.on("mouseleave", aggr => this.browser.clearSelect_Compare() )
            .on("click", (event, aggr) => {
            if (event.shiftKey) {
                // filter - TODO needs to have its own filter logic
                return;
            }
            let latlong = aggr.cluster.geometry.coordinates;
            this.leafletRecordMap.setZoomAround(new L.latLng(latlong[1], latlong[0]), this.leafletRecordMap.getZoom() + 1);
        })
            .call((clusterGlyph) => {
            clusterGlyph
                .append("g")
                .attr("class", "measureGroup")
                .call((measureGroup) => {
                ["Active"].concat(Base.Compare_List).forEach((cT) => {
                    this.DOM["clusterGlyphs_" + cT] = measureGroup
                        .append("path")
                        .attr("class", "measure_" + cT)
                        .each((aggr, i, nodes) => {
                        nodes[i]._currentPreviewAngle = 0;
                    });
                });
            });
            clusterGlyph
                .append("text")
                .attr("class", "sizeValueText")
                .html((aggr) => "" + aggr.Active.measure);
        });
        // reset circle size
        this.DOM.clusterGlyphs_Active.attr("d", Util.getCirclePath());
    }
    /** -- */
    refreshPointDOM() {
        this.rd.refreshRecordDOM();
        this.rd.updateRecordSizeScale();
        this.rd.updateRecordColorScale();
    }
    /** --  */
    refreshRecordVis() {
        var _a, _b, _d;
        if (!this.geoAttrib)
            return;
        if (this.geoAttrib.geoType === "Point") {
            // POINT MAPS
            this.refreshPointClusters();
            this.refreshPointDOM();
            (_a = this.DOM.kshfRecords) === null || _a === void 0 ? void 0 : _a.attr("transform", (record) => this.translate_glyph(this.geoAttrib.getRecordValue(record).geoFeat.coordinates));
            (_b = this.DOM.clusterGlyphs) === null || _b === void 0 ? void 0 : _b.attr("transform", (aggr) => this.translate_glyph(aggr.cluster.geometry.coordinates));
        }
        else {
            // POLYGON MAPS
            (_d = this.DOM.kshfRecords_Path) === null || _d === void 0 ? void 0 : _d.attr("d", (record) => this.recordGeoPath(this.geoAttrib.getRecordValue(record).geoFeat));
        }
    }
    /** -- */
    refreshPointClusterVis() {
        if (!this.rd.hasAggregates())
            return;
        if (!this.rd.recordRadiusScale)
            return;
        let clusterArc = d3$9
            .arc()
            .innerRadius(0)
            .startAngle(0)
            .endAngle(2 * Math.PI);
        let circleDraw = (aggr) => clusterArc.outerRadius(aggr.cluster._radius)(null);
        this.DOM.clusterGlyphs
            .each((aggr) => {
            aggr.cluster._radius = this.rd.recordRadiusScale(aggr.Active.measure);
        })
            .classed("tinyCluster", (aggr) => aggr.cluster._radius < 8)
            .classed("clampedCluster", (aggr) => aggr.cluster._radius >= Base.maxRecordPointSize);
        this.DOM.clusterGlyphs_Active
            .transition()
            .duration(700)
            .ease(d3$9.easePolyOut.exponent(3))
            .attr("d", circleDraw);
        // update fill color of clusters
        if (!this.colorAttrib) {
            this.DOM.clusterGlyphs_Active.style("fill", null);
            this.DOM.clusterGlyphs.classed("darkBg", false);
            //
        }
        else {
            this.DOM.clusterGlyphs_Active.each((cluster, i, nodes) => {
                let v = cluster.Active.measure;
                let _fill = v != null ? this.rd.recordColorScale(v) : "url(#diagonalHatch)";
                let darkBg = v != null ? d3$9.hsl(_fill).l < 0.6 : false;
                nodes[i].style.fill = _fill;
                // to adjust text color by background luminance
                nodes[i].parentNode.parentNode.classList[darkBg ? "add" : "remove"]("darkBg");
            });
        }
        this.refreshSelect_Compare();
    }
    /**
     * Returns the records that fit/intersect within the bounds (if point) or has geofeat (if polygon)
     */
    getRecordsForDOM() {
        let bounds = this.leafletRecordMap.getBounds();
        return this.browser.records.filter((record) => {
            var _a;
            var _feat = (_a = this.geoAttrib.getRecordValue(record)) === null || _a === void 0 ? void 0 : _a.geoFeat;
            if (!_feat)
                return false;
            // not in a cluster - not rendered separately
            if (_feat.type === "Point" && _feat.coordinates) {
                if (record._view.inCluster)
                    return false;
                return bounds.contains(L.latLng(_feat.coordinates.slice().reverse()));
            }
            return true;
        });
    }
    /** -- */
    refreshRecordColors() {
        if (!this.DOM.kshfRecords_Path)
            return;
        if (this.colorAttrib) {
            if (!this.rd.recordColorScale)
                return;
            let s_f;
            let s_log = false;
            let s_ts = (_record) => false;
            if (this.colorAttrib instanceof Attrib_Interval) {
                s_f = this.colorAttrib.template.func;
                s_log = this.colorAttrib.isValueScale_Log;
                if (this.colorAttrib.hasTimeSeriesParent()) {
                    let f_ps = this.colorAttrib.timeseriesParent.template.func;
                    s_ts = function (record) {
                        let _ = f_ps.call(this, record);
                        if (!_ || !_._timeseries_)
                            return false;
                        return _._timeseries_.length === 0;
                    };
                }
            }
            else if (this.colorAttrib === "_measure_") {
                s_f = (record) => record.measure_Self;
            }
            else {
                console.log("IMPOSSIBLE");
            }
            this.DOM.kshfRecords_Path.each((record, i, nodes) => {
                if (record.filteredOut)
                    return;
                let DOM = nodes[i];
                let _fill = "url(#diagonalHatch)";
                let _stroke = "#111111";
                let darkBg = false;
                let v = s_f.call(record.data, record);
                if (v === "" || v == null || typeof v !== "number" || (s_log && v <= 0))
                    v = null;
                if (v != null) {
                    _fill = this.rd.recordColorScale(v);
                    darkBg = d3$9.hsl(_fill).l < 0.6;
                    _stroke = darkBg ? "#EEEEEE" : "#111111";
                }
                if (record.isSelected()) {
                    _stroke = null;
                }
                DOM.style.fill = _fill;
                DOM.style.stroke = _stroke;
                DOM.parentNode.classList[darkBg ? "add" : "remove"]("darkBg");
                DOM.classList[s_ts.call(record.data, record) ? "add" : "remove"]("noData");
            });
        }
        else {
            this.DOM.kshfRecords_Path
                .style("fill", null)
                .style("stroke", null)
                .classed("noData", false);
        }
        this.refreshPointClusterVis();
    }
}

const d3$8 = {
    select,
    pointer,
    zoom,
    zoomTransform: transform,
    zoomIdentity: identity,
    line,
    curveNatural,
    curveCatmullRomOpen,
    easePolyOut: polyOut,
};
class RecordView_Scatter extends RecordView {
    prepareAttribs() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.scatterYAttrib) {
                yield this.rd.setAttrib("scatterY", this.rd.config.scatterYBy ||
                    (this.rd.codeBy.sort instanceof Attrib_Numeric
                        ? this.rd.codeBy.sort
                        : 0));
            }
            if (!this.scatterXAttrib) {
                yield this.rd.setAttrib("scatterX", this.rd.config.scatterXBy || 0);
            }
            if (!this.rd.codeBy.color && this.rd.config.colorBy) {
                yield this.rd.setAttrib("color", this.rd.config.colorBy);
            }
            if (!this.rd.codeBy.size && this.rd.config.sizeBy) {
                yield this.rd.setAttrib("size", this.rd.config.sizeBy);
            }
            return Promise.resolve(true);
        });
    }
    constructor(rd, config) {
        super(rd);
        // ********************************************************************
        // Configurations
        // ********************************************************************
        this.configs = {};
        this.scatterTransform = { x: 0, y: 0, z: 1 };
        this.scatter_showTrails = new Config({
            cfgClass: "scatter_showTrails",
            cfgTitle: "Scatter Trails",
            iconXML: Base.custom_icons.trails,
            default: true,
            parent: this,
            helparticle: "5e89138704286364bc97d51f",
            itemOptions: [
                { name: "Show", value: true },
                { name: "Hide", value: false },
            ],
            forcedValue: () => {
                var _a, _b;
                // No trails if both of the axis are not a part of time-series.
                if (!((_a = this.scatterXAttrib) === null || _a === void 0 ? void 0 : _a.hasTimeSeriesParent()) ||
                    !((_b = this.scatterYAttrib) === null || _b === void 0 ? void 0 : _b.hasTimeSeriesParent()))
                    return false;
            },
        });
        this.scatter_xAxisScale = new Config({
            parent: this,
            cfgClass: "scatter_xAxisScale",
            cfgTitle: "X Axis Scale",
            iconClass: "fa fa-arrows-h",
            default: "linear",
            helparticle: "5f137ac32c7d3a10cbaaf048",
            itemOptions: [
                { name: i18n.Linear + " " + i18n.LinearSequence, value: "linear" },
                { name: i18n.Log + " " + i18n.Log10Sequence, value: "log" },
            ],
            noExport: true,
            forcedValue: () => {
                var _a;
                if (!((_a = this.scatterXAttrib) === null || _a === void 0 ? void 0 : _a.supportsLogScale()))
                    return "linear";
            },
            onSet: (v) => __awaiter(this, void 0, void 0, function* () {
                if (!this.scatterXAttrib)
                    return;
                if (!this.scatterXAttrib.hasTimeSeriesParent()) {
                    yield this.scatterXAttrib.valueScaleType.set(v);
                }
                else if (v !== "auto") {
                    yield this.scatterXAttrib.timeseriesParent.valueScaleType.set(v);
                }
            }),
        });
        this.scatter_yAxisScale = new Config({
            parent: this,
            cfgClass: "scatter_yAxisScale",
            cfgTitle: "Y Axis Scale",
            iconClass: "fa fa-arrows-v",
            default: "linear",
            helparticle: "5f137ac32c7d3a10cbaaf048",
            itemOptions: [
                { name: `${i18n.Linear} ${i18n.LinearSequence}`, value: "linear" },
                { name: `${i18n.Log} ${i18n.Log10Sequence}`, value: "log" },
            ],
            noExport: true,
            forcedValue: () => {
                var _a;
                if (!((_a = this.scatterYAttrib) === null || _a === void 0 ? void 0 : _a.supportsLogScale()))
                    return "linear";
            },
            onSet: (v) => __awaiter(this, void 0, void 0, function* () {
                if (!this.scatterYAttrib)
                    return;
                if (!this.scatterYAttrib.hasTimeSeriesParent()) {
                    yield this.scatterYAttrib.valueScaleType.set(v);
                }
                else if (v !== "auto") {
                    yield this.scatterYAttrib.timeseriesParent.valueScaleType.set(v);
                }
            }),
        });
        ["scatter_showTrails", "scatter_xAxisScale", "scatter_yAxisScale"].forEach((t) => {
            this[t].val = config[t];
            this.rd.configs[t] = this[t];
            this.rd.recordConfigPanel.insertConfigUI(this[t]);
        });
        this.scatterZoom = d3$8
            .zoom()
            .filter(() => this.rd.visMouseMode === "pan" && this.rd.curHeight > 0)
            .scaleExtent([1, 8]) // 1 covers the whole dataset. 2 is double-zoom-in.
            .on("start", () => {
            this.DOM.recordDisplayWrapper.classed("dragging", true);
        })
            .on("end", () => {
            this.DOM.recordDisplayWrapper.classed("dragging", false);
            this.refreshLabelOverlaps();
        })
            .on("zoom", () => {
            let t = d3$8.zoomTransform(this.DOM.recordBase_Scatter.node());
            this.scatterTransform = { x: t.x, y: t.y, z: t.k };
            this.DOM.recordGroup_Scatter.style("transform", `translate(${this.scatterTransform.x}px, ${this.scatterTransform.y}px) scale(${this.scatterTransform.z})`);
            this.refreshRecordVis();
        });
        this.refreshZoomScaleExtent();
    }
    /** -- */
    initView() {
        this.rd.refreshAttribOptions("scatterX");
        this.rd.refreshAttribOptions("scatterY");
        this.rd.refreshRecordDOM();
        this.refreshScales();
        this.zoomToFit();
        this.refreshQueryBox_Filter();
        this.rd.updateRecordSizeScale();
        this.rd.updateRecordColorScale();
    }
    /** -- */
    initView_DOM() {
        return __awaiter(this, void 0, void 0, function* () {
            // set CSS variables
            this.browser.DOM.root
                .node()
                .style.setProperty("--width_scatter_margin_left", Base.width_scatter_margin_left + "px");
            this.browser.DOM.root
                .node()
                .style.setProperty("--height_scatter_margin_bottom", Base.height_scatter_margin_bottom + "px");
            if (this.DOM.recordBase_Scatter) {
                this.DOM.recordGroup = this.DOM.recordBase_Scatter.select(".recordGroup");
                this.DOM.kshfRecords =
                    this.DOM.recordGroup_Scatter.selectAll(".kshfRecord");
                this.DOM.kshfRecords_Path = this.DOM.recordGroup.selectAll(".kshfRecord > path.glyph_Main");
                this.DOM.linkGroup = this.DOM.recordGroup_Scatter.select(".linkGroup");
                return; // Do not initialize twice
            }
            this.DOM.recordBase_Scatter = this.DOM.recordDisplayWrapper
                .append("div")
                .attr("class", "recordBase_Scatter")
                .call(this.scatterZoom);
            this.DOM.recordBase_Scatter
                .append("span")
                .attr("class", "ScatterControl-SwapAxis")
                .tooltip(i18n.SwapAxis)
                .on("mousedown", (event) => event.stopPropagation())
                .on("mouseup", (event) => event.stopPropagation())
                .on("dblclick", (event) => event.stopPropagation())
                .on("wheel", (event) => event.stopPropagation())
                .on("click", (event) => {
                this.swapAxis();
                event.stopPropagation();
            })
                .append("i")
                .attr("class", "far fa-exchange");
            // recordAxis_X, recordAxis_Y
            ["X", "Y"].forEach((a) => {
                this.DOM["recordAxis_" + a] = this.DOM.recordBase_Scatter
                    .append("div")
                    .attr("class", "recordAxis recordAxis_" + a)
                    .html("<div class='tickGroup'></div><div class='onRecordLine'><div class='tickLine'></div><div class='tickText'></div></div>");
            });
            this.DOM.recordGroup_Scatter = this.DOM.recordBase_Scatter
                .append("div")
                .attr("class", "recordGroup_Scatter_Wrapper")
                .append("div")
                .attr("class", "recordGroup_Scatter");
            ["X", "Y"].forEach((axis) => {
                this.DOM["scatter" + axis + "ControlGroup"] = this.DOM.recordBase_Scatter
                    .append("div")
                    .attr("class", "recordGroup_Scatter_" + axis + "Axis_Options")
                    .on("mousedown", (event) => event.stopPropagation())
                    .on("mouseup", (event) => event.stopPropagation())
                    .on("dbclick", (event) => event.stopPropagation())
                    .on("wheel", (event) => event.stopPropagation())
                    .append("span")
                    .attr("class", "scatter" + axis + "ControlGroup attribControlGroup");
                this.rd.initDOM_AttribSelect(axis === "X" ? "scatterX" : "scatterY");
            });
            var _svg = this.DOM.recordGroup_Scatter
                .append("svg")
                .attr("xmlns", "http://www.w3.org/2000/svg");
            this.DOM.recordGroup = _svg.append("g").attr("class", "recordGroup");
            this.DOM.recordTrail = _svg.append("g").attr("class", "recordTrail");
            this.DOM.recordTrail_Path = this.DOM.recordTrail
                .append("path")
                .attr("class", "recordTrail_Path");
            this.insertQueryBoxes(this.DOM.recordGroup_Scatter, 
            // setSizeCb
            (event, t) => {
                if (event.which !== 1)
                    return; // only respond to left-click
                this.DOM.recordDisplayWrapper
                    .classed("dragging", true)
                    .classed("drawSelecting", true);
                d3$8.select("body")
                    .on("mousemove", (event2) => {
                    var targetPos = d3$8
                        .pointer(event2, this.DOM.recordGroup_Scatter.node().parentNode)
                        .map((_, i) => this["scatterAxisScale_" + (i ? "Y" : "X")].invert(_));
                    if (t === "l") {
                        this.scatterXAttrib.setRangeFilter_Custom(targetPos[0], this.scatterXAttrib.summaryFilter.active.maxV);
                    }
                    if (t === "r") {
                        this.scatterXAttrib.setRangeFilter_Custom(this.scatterXAttrib.summaryFilter.active.minV, targetPos[0]);
                    }
                    if (t === "t") {
                        this.scatterYAttrib.setRangeFilter_Custom(this.scatterYAttrib.summaryFilter.active.minV, targetPos[1]);
                    }
                    if (t === "b") {
                        this.scatterYAttrib.setRangeFilter_Custom(targetPos[1], this.scatterYAttrib.summaryFilter.active.minV);
                    }
                    this.refreshQueryBox_Filter();
                })
                    .on("mouseup", () => {
                    this.DOM.recordDisplayWrapper
                        .classed("dragging", false)
                        .classed("drawSelecting", false);
                    d3$8.select("body").on("mousemove", null).on("mouseup", null);
                });
                event.preventDefault();
                event.stopPropagation();
            }, 
            // drag callback
            (event) => {
                if (event.which !== 1)
                    return; // only respond to left-click
                this.DOM.recordDisplayWrapper.classed("dragging", true);
                var initScreenPos = d3$8.pointer(event, this.DOM.recordGroup_Scatter.node().parentNode);
                var initMin_X = this.scatterAxisScale_X(this.scatterXAttrib.summaryFilter.active.minV);
                var initMax_X = this.scatterAxisScale_X(this.scatterXAttrib.summaryFilter.active.maxV);
                var initMin_Y = this.scatterAxisScale_Y(this.scatterYAttrib.summaryFilter.active.minV);
                var initMax_Y = this.scatterAxisScale_Y(this.scatterYAttrib.summaryFilter.active.maxV);
                d3$8.select("body")
                    .on("mousemove", (event3) => {
                    var curScreenPos = d3$8.pointer(event3, this.DOM.recordGroup_Scatter.node().parentNode);
                    var diffX = initScreenPos[0] - curScreenPos[0];
                    var diffY = initScreenPos[1] - curScreenPos[1];
                    this.scatterYAttrib.setRangeFilter_Custom(this.scatterAxisScale_Y.invert(initMin_Y - diffY), this.scatterAxisScale_Y.invert(initMax_Y - diffY));
                    this.scatterXAttrib.setRangeFilter_Custom(this.scatterAxisScale_X.invert(initMin_X - diffX), this.scatterAxisScale_X.invert(initMax_X - diffX));
                    this.refreshQueryBox_Filter();
                })
                    .on("mouseup", () => {
                    this.DOM.recordDisplayWrapper.classed("dragging", false);
                    d3$8.select("body").on("mousemove", null).on("mouseup", null);
                });
                event.preventDefault();
                event.stopPropagation();
            }, 
            // click callback
            (event, d) => {
                if (d === "Filter") {
                    this.scatterXAttrib.summaryFilter.clearFilter();
                    this.scatterYAttrib.summaryFilter.clearFilter();
                }
                else {
                    this.browser.clearSelect_Compare(d);
                    this.displayQueryBox(d, false);
                }
                event.currentTarget.tippy.hide();
            });
        });
    }
    refreshAttribScaleType(attrib) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.scatterXAttrib || !this.scatterYAttrib)
                return;
            if (this.scatterXAttrib === attrib ||
                this.scatterXAttrib.timeseriesParent === attrib) {
                yield this.scatter_xAxisScale.set(this.scatterXAttrib.valueScaleType.get());
                this.refreshRecordVis();
            }
            if (this.scatterYAttrib === attrib ||
                this.scatterYAttrib.timeseriesParent === attrib) {
                yield this.scatter_yAxisScale.set(this.scatterYAttrib.valueScaleType.get());
                this.refreshRecordVis();
            }
        });
    }
    refreshAttribUnitName(attrib) {
        this.refreshScatterTicks();
    }
    finishSetAttrib(t) {
        return __awaiter(this, void 0, void 0, function* () {
            if (t === "text") {
                this.DOM.kshfRecords
                    .selectAll("foreignObject .recordText")
                    .html((record) => this.textBriefAttrib.renderRecordValue(record));
                this.refreshRecordBounds();
                this.refreshLabelOverlaps();
                //
            }
            else if (t === "scatterX" || t === "scatterY") {
                if (t === "scatterX") {
                    this.scatter_xAxisScale.set(this.scatterXAttrib.valueScaleType.get());
                }
                if (t === "scatterY") {
                    this.scatter_yAxisScale.set(this.scatterYAttrib.valueScaleType.get());
                }
                this.refreshScales();
                this.refreshLabelOverlaps();
                this.refreshRecordVis();
                //
            }
            else if (t === "color") {
                this.refreshRecordColors();
                //
            }
            else ;
        });
    }
    /** -- */
    refreshViewSize(_delayMS = 0) {
        if (!this.scatterXAttrib || !this.scatterYAttrib)
            return;
        this.refreshZoomScaleExtent();
        this.refreshRecordVis();
        this.rd.refreshColorLegendTicks();
    }
    // ********************************************************************
    // Scale of X and Y attributes
    // ********************************************************************
    /** -- */
    get realWidth() {
        return this.rd.curWidth - Base.width_scatter_margin_left;
    }
    /** -- */
    get realHeight() {
        return (this.rd.curHeight -
            Base.height_scatter_margin_bottom -
            (this.rd.hasTimeKey ? Base.timeKeyHeight : 0));
    }
    /** -- */
    getScale(attrib) {
        return Util.getD3Scale(attrib.isValueScale_Log)
            .domain(attrib.getVizDomain())
            .clamp(false);
    }
    /** -- */
    refreshScales() {
        if (!this.scatterXAttrib || !this.scatterYAttrib)
            return;
        if (this.rd.timeseriesAnimInterval)
            return; // do not refresh scale during animation
        this.scatterScaleX = this.getScale(this.scatterXAttrib).range([
            this.realWidth * 0.05,
            this.realWidth * 0.9,
        ]);
        this.scatterScaleY = this.getScale(this.scatterYAttrib).range([
            this.realHeight * 0.9,
            this.realHeight * 0.05,
        ]);
    }
    /** -- */
    swapAxis() {
        var _ = this.scatterXAttrib;
        this.rd.codeBy.scatterX = this.scatterYAttrib;
        this.rd.codeBy.scatterY = _;
        this.rd.refreshAttribOptions("scatterX");
        this.rd.refreshAttribOptions("scatterY");
        this.refreshScales();
        this.refreshRecordVis();
    }
    // ********************************************************************
    // Zoom control
    // ********************************************************************
    /** -- */
    zoomIn() {
        this.scatterZoom.scaleBy(this.DOM.recordBase_Scatter, 2);
    }
    /** -- */
    zoomOut() {
        this.scatterZoom.scaleBy(this.DOM.recordBase_Scatter, 1 / 2);
    }
    /** -- */
    zoomToFit() {
        this.scatterZoom.transform(this.DOM.recordBase_Scatter, d3$8.zoomIdentity);
    }
    /** -- */
    refreshZoomScaleExtent() {
        this.scatterZoom.translateExtent([
            [0, 0],
            [this.realWidth, this.realHeight],
        ]);
    }
    /** -- */
    refreshLabelOverlaps() {
        if (!this.initialized)
            return;
        if (!this.DOM.kshfRecords)
            return;
        if (this.rd.timeseriesAnimInterval)
            return;
        var activeComparisons = this.browser.activeComparisons;
        var relevantRecords = this.browser.records.filter((record) => {
            // hide text labels of all records by default
            record._view.hideTextLabel = true;
            return (record.DOM.record &&
                record._view.textBounds &&
                record._view.isInScatterPlot &&
                record._view.isInRange &&
                record.isIncluded &&
                (activeComparisons.length === 0 || record.isSelected()));
        });
        var maxNumOfRecords = (this.realWidth * this.realHeight) / 7000;
        var numOfLabels = 0;
        relevantRecords.forEach((record, i) => {
            if (numOfLabels > maxNumOfRecords)
                return;
            delete record._view.hideTextLabel; // ok, now inverse logic: show by default
            // simple transformation on bounds to detect intersecting text labels
            var _ = record._view.textBounds;
            var _w = _.width / this.scatterTransform.z;
            var _h = _.height / this.scatterTransform.z;
            record._view.viewBounds = {
                width: _w,
                height: _h,
                left: record._view.x,
                right: record._view.x + _w,
                top: record._view.y,
                bottom: record._view.y + _h,
            };
            for (var j = 0; j < i; j++) {
                var record_2 = relevantRecords[j];
                if (!record_2._view.hideTextLabel &&
                    Util.intersectsDOMRect(record._view.viewBounds, record_2._view.viewBounds)) {
                    record._view.hideTextLabel = true;
                    return;
                }
            }
            numOfLabels++;
        });
        this.DOM.kshfRecords.classed("hideTextLabel", (record) => record._view.hideTextLabel);
    }
    /** -- */
    refreshRecordSizes() {
        if (!this.scatterXAttrib || !this.scatterYAttrib)
            return;
        if (!this.DOM.recordGroup)
            return;
        this.DOM.recordGroup
            .selectAll(".kshfRecord > path")
            .transition()
            .duration(700)
            .ease(d3$8.easePolyOut.exponent(3))
            .attr("d", (record) => this.rd.recordDrawArc(record)());
        this.refreshSelect_Compare(); // skip label overlap
    }
    /** -- */
    refreshRecordColors() {
        if (!this.scatterXAttrib || !this.scatterYAttrib)
            return;
        if (!this.DOM.kshfRecords)
            return;
        if (!this.DOM.kshfRecords_Path)
            return;
        var _fill = null;
        if (this.colorAttrib instanceof Attrib_Interval) {
            var c = this.colorAttrib;
            var s_log = this.colorAttrib.isValueScale_Log;
            _fill = (record) => {
                if (record.filteredOut)
                    return;
                var v = c.getRecordValue(record);
                return isNaN(v) || v == null || (s_log && v <= 0)
                    ? "url(#diagonalHatch)"
                    : this.rd.recordColorScale(v);
            };
        }
        this.DOM.kshfRecords_Path.style("fill", _fill);
    }
    refreshSelect_Compare(cT = null, status = false) {
        this.refreshLabelOverlaps();
        super.refreshSelect_Compare(cT, status);
    }
    /** -- */
    refreshRecordVis() {
        if (!this.initialized)
            return;
        if (!this.DOM.recordBase_Scatter)
            return;
        if (!this.DOM.kshfRecords)
            return;
        if (!this.rd.curHeight)
            return;
        // running this first, as it also computes scatterAxisScale_X & scatterAxisScale_Y
        this.refreshScatterTicks();
        var visibleX = this.scatterAxisScale_X.domain();
        var visibleY = this.scatterAxisScale_Y.domain();
        visibleY.reverse();
        var inRange = (x, range) => x > range[0] && x < range[1];
        this.DOM.kshfRecords.each((record) => {
            record._view.wasInScatterPlot = record._view.isInScatterPlot || false;
            var _x = this.scatterXAttrib.getRecordValue(record);
            var _y = this.scatterYAttrib.getRecordValue(record);
            record._view.isInScatterPlot = _x != null && _y != null;
            record._view.isInRange = inRange(_x, visibleX) && inRange(_y, visibleY);
        });
        // was in scatterplot, is in scatterplot
        this.DOM.kshfRecords
            .filter((record) => record._view.isInScatterPlot)
            .classed("noTransition", (record) => !record._view.wasInScatterPlot)
            .style("transform", (record) => {
            record._view.x = this.scatterScaleX(record.getValue(this.scatterXAttrib));
            record._view.y = this.scatterScaleY(record.getValue(this.scatterYAttrib));
            // scale is just based on zoom level - it reverses the affect of the zoom on parent node
            return `translate(${record._view.x}px, ${record._view.y}px) scale(${1 / this.scatterTransform.z})`;
        });
        this.DOM.kshfRecords.classed("hidden", (record) => !record._view.isInScatterPlot);
    }
    /** -- */
    refreshScatterTicks() {
        // Compute bounds in SVG coordinates after transform is applied.
        var minX_real = -this.scatterTransform.x / this.scatterTransform.z;
        var maxX_real = minX_real + this.realWidth / this.scatterTransform.z;
        var minY_real = -this.scatterTransform.y / this.scatterTransform.z;
        var maxY_real = minY_real + this.realHeight / this.scatterTransform.z;
        this.scatterAxisScale_X = this.scatterScaleX
            .copy()
            .range([0, this.realWidth])
            .domain([
            this.scatterScaleX.invert(minX_real),
            this.scatterScaleX.invert(maxX_real),
        ]);
        this.scatterAxisScale_Y = this.scatterScaleY
            .copy()
            .range([0, this.realHeight])
            .domain([
            this.scatterScaleY.invert(minY_real),
            this.scatterScaleY.invert(maxY_real),
        ]);
        if (this.scatterAxisScale_X.base)
            this.scatterAxisScale_X.base(10);
        if (this.scatterAxisScale_Y.base)
            this.scatterAxisScale_Y.base(10);
        var tickSpacing = {
            X: 60,
            Y: 40,
        };
        if (this.scatterXAttrib.unitName) {
            tickSpacing.X += 2 + this.scatterXAttrib.unitName.length * 8;
        }
        // TODO: add translateZ to reduce redraw (but causes flickering on chrome)
        var addTicks = (axis, axisScale, chartSize, attrib) => {
            var numTicks = Math.min(15, Math.floor(chartSize / tickSpacing[axis])); // no more than 15 ticks.
            var ticks = axisScale
                .ticks(numTicks)
                .filter((t) => attrib.hasFloat || t % 1 === 0);
            var visiblePos = 0;
            this.DOM["recordAxis_" + axis]
                .select(".tickGroup")
                .selectAll(".hmTicks")
                .data(ticks, (t) => t)
                .join((enter) => enter
                .append("div")
                .attr("class", "hmTicks")
                .call((newDOM) => {
                newDOM
                    .transition()
                    .delay(100)
                    .on("start", function () {
                    this.style.opacity = 1;
                });
                newDOM.append("div").attr("class", "tickText");
                newDOM.append("div").attr("class", "tickLine");
            }), (update) => update, (exit) => exit.remove())
                .classed("lineAtZero", (tick) => (tick === 0 ? true : false))
                .style("transform", (tick) => `translate${axis}(${axisScale(tick)}px) translateZ(0)`)
                .classed("hideLabel", (tick) => {
                var pos = axisScale(tick);
                if (pos >= visiblePos) {
                    visiblePos = pos + tickSpacing[axis] / 2;
                    return false;
                }
                return true;
            })
                // unit name may change, don't just rely on inserting tick text on new ticks.
                .selectAll(".tickText")
                .html((tick) => attrib.printAbbr(tick));
            // sort ticks from large to small
        };
        addTicks("X", this.scatterAxisScale_X, this.realWidth, this.scatterXAttrib);
        addTicks("Y", this.scatterAxisScale_Y, this.realHeight, this.scatterYAttrib);
        this.refreshQueryBox_Filter();
    }
    /** -- */
    updateAfterFilter(how) {
        this.updateRecordVisibility();
        this.refreshLabelOverlaps();
        if (how) {
            this.refreshRecordVis();
        }
        this.refreshRecordColors();
    }
    /** -- */
    extendRecordDOM(newRecords) {
        newRecords.classed("noTransition", true);
        this.extendRecordDOM_Point(newRecords);
        newRecords
            .append("foreignObject")
            .attr("width", "120")
            .attr("height", "1")
            .append("xhtml:div")
            .attr("xmlns", "http://www.w3.org/1999/xhtml")
            .attr("class", "recordText");
    }
    /** -- */
    displayQueryBox(cT, show) {
        if (!this.initialized)
            return;
        this.DOM.recordDisplayWrapper
            .select(".spatialQueryBox_" + cT)
            .style("display", show ? "block" : null);
    }
    /** -- */
    refreshRecordBounds() {
        if (!this.initialized)
            return;
        // needed to make labels visible so that bounds can be computed correctly
        this.DOM.kshfRecords.classed("hideTextLabel", false);
        this.DOM.kshfRecords.selectAll(".recordText").each((record, i, nodes) => {
            if (!record.DOM.record) {
                delete record.textBounds;
                return;
            }
            var DOM = nodes[i];
            var recordTextBounds = DOM.getBoundingClientRect();
            DOM.parentNode.setAttribute("width", recordTextBounds.width * 1.07);
            DOM.parentNode.setAttribute("height", recordTextBounds.height);
            var _ = recordTextBounds; // record.DOM.record.getBoundingClientRect();
            record.textBounds = {
                width: _.width,
                height: _.height,
                left: _.left,
                right: _.right,
                top: _.top,
                bottom: _.bottom,
            };
        });
    }
    refreshQueryBox_Filter(bounds = null) {
        if (this.rd.collapsed)
            return;
        var _left, _right, _top, _bottom, temp;
        var isVisible = false;
        if (bounds === null) {
            isVisible =
                this.scatterXAttrib.isFiltered() || this.scatterYAttrib.isFiltered();
            if (!this.scatterXAttrib.isFiltered()) {
                _left = this.scatterXAttrib.rangeOrg[0];
                if (_left === 0)
                    _left = -1000;
                _left = _left > 0 ? -_left * 100 : _left * 100;
                _right = this.scatterXAttrib.rangeOrg[1];
                if (_right === 0)
                    _right = 1000;
                _right = _right > 0 ? _right * 100 : -_right * 100;
            }
            else {
                _left = this.scatterXAttrib.summaryFilter.active[0];
                _right = this.scatterXAttrib.summaryFilter.active[1];
                if (this.scatterXAttrib.stepTicks) {
                    _left -= 0.5;
                    _right -= 0.5;
                }
            }
            if (!this.scatterYAttrib.isFiltered()) {
                _top = this.scatterYAttrib.rangeOrg[1];
                if (_top === 0)
                    _top = 1000;
                _top = _top > 0 ? _top * 100 : -_top * 100;
                _bottom = this.scatterYAttrib.rangeOrg[0];
                if (_bottom === 0)
                    _bottom = -1000;
                _bottom = _bottom > 0 ? -_bottom * 100 : _bottom * 100;
            }
            else {
                _top = this.scatterYAttrib.summaryFilter.active[1];
                _bottom = this.scatterYAttrib.summaryFilter.active[0];
                if (this.scatterYAttrib.stepTicks) {
                    _top -= 0.5;
                    _bottom -= 0.5;
                }
            }
        }
        else {
            // use provided bounds
            if (bounds.left > bounds.right) {
                temp = bounds.left;
                bounds.left = bounds.right;
                bounds.right = temp;
            }
            if (bounds.top < bounds.bottom) {
                temp = bounds.top;
                bounds.top = bounds.bottom;
                bounds.bottom = temp;
            }
            _left = bounds.left;
            _right = bounds.right;
            _top = bounds.top;
            _bottom = bounds.bottom;
        }
        // convert from domain to screen coordinates
        _left = this.scatterScaleX(_left);
        if (isNaN(_left))
            _left = -1000; // log scale fix
        _right = this.scatterScaleX(_right);
        _top = this.scatterScaleY(_top);
        _bottom = this.scatterScaleY(_bottom);
        if (isNaN(_bottom))
            _bottom = 1000; // log scale fix
        // give more room
        _left -= 3;
        _right += 3;
        _top -= 3;
        _bottom += 3;
        this.DOM.recordDisplayWrapper
            .select(".recordGroup_Scatter .spatialQueryBox_Filter")
            .classed("active", bounds ? true : isVisible)
            .style("left", _left + "px")
            .style("top", _top + "px")
            .style("width", Math.abs(_right - _left) + "px")
            .style("height", Math.abs(_bottom - _top) + "px");
    }
    /** -- */
    onRecordMouseOver(record) {
        record.moveDOMtoTop();
        ["X", "Y"].forEach((axis, i) => {
            var attrib = this["scatter" + axis + "Attrib"];
            var acc = attrib.attribID;
            var pos = this["scatterAxisScale_" + axis](record._valueCache[acc]);
            var dom = this.DOM["recordAxis_" + axis];
            dom
                .select(".onRecordLine")
                .style("transform", "translate(" + pos * (i ? 0 : 1) + "px," + pos * (i ? 1 : 0) + "px)")
                .style("opacity", 1);
            dom
                .select(".onRecordLine > .tickText")
                .html(attrib.getFormattedValue(record._valueCache[acc], false));
        });
        if (this.scatter_showTrails.is(false))
            return;
        if (this.scatterYAttrib.hasTimeSeriesParent() &&
            this.scatterXAttrib.hasTimeSeriesParent()) {
            var _ts_X = this.scatterXAttrib.timeseriesParent.getRecordValue(record)._keyIndex;
            var _ts_Y = this.scatterYAttrib.timeseriesParent.getRecordValue(record)._keyIndex;
            // merge the two
            var _ts = [];
            for (let _time_src in _ts_X) {
                if (_ts_Y[_time_src]) {
                    _ts.push({
                        x: _ts_X[_time_src]._value,
                        y: _ts_Y[_time_src]._value,
                    });
                }
            }
            var lineGenerator = d3$8
                .line()
                .curve(d3$8.curveNatural || d3$8.curveCatmullRomOpen)
                .x((d) => this.scatterScaleX(d.x))
                .y((d) => this.scatterScaleY(d.y));
            this.DOM.recordTrail.style("opacity", 1);
            this.DOM.recordTrail_Path
                .style("stroke-width", 2 / this.scatterTransform.z + "px")
                .attr("d", lineGenerator(_ts));
            this.DOM.recordTrail
                .selectAll("circle")
                .data(_ts)
                .join("circle")
                .attr("r", 3)
                .style("transform", (d) => {
                var x = this.scatterScaleX(d.x);
                var y = this.scatterScaleY(d.y);
                return `translate(${x}px,${y}px) scale(${1 / this.scatterTransform.z})`;
            });
        }
    }
    /** -- */
    onRecordMouseLeave() {
        var _a;
        this.DOM.root.selectAll(".onRecordLine").style("opacity", null);
        // hide the trail
        (_a = this.DOM.recordTrail) === null || _a === void 0 ? void 0 : _a.style("opacity", 0);
    }
}

const d3$7 = {
    area,
    curveMonotoneX: monotoneX,
    easePoly: polyInOut,
};
class Block_Timestamp extends Block_Interval {
    constructor(attrib) {
        super(attrib);
    }
    /** -- */
    dragRange(initPos, curPos, initMin, initMax) {
        // no-op - not supported
    }
    /** - */
    refreshViz_Active() {
        if (!this.isVisible() || !this.DOM.aggrGlyphs)
            return;
        super.refreshViz_Active();
        this.updateViz_Areas("Active", !this.attrib.stackedCompare && this.browser.activeComparisonsCount > 0);
    }
    /** - */
    refreshViz_Compare(cT, curGroup, totalGroups, prevCts = []) {
        if (!this.isVisible() || !this.DOM.aggrGlyphs)
            return;
        super.refreshViz_Compare(cT, curGroup, totalGroups, prevCts);
        if (this.attrib.stackedCompare &&
            this.browser.addedCompare &&
            curGroup === totalGroups - 1) {
            // smoother animation, sets it as a chart-line at offset first - instead of area chart
            this.DOM["measure_Area_" + cT].attr("d", this.getVizArea(cT, true));
        }
        this.updateViz_Areas(cT, !this.attrib.stackedCompare);
    }
    /** -- */
    insertVizDOM() {
        // insert these elements only once
        if (!this.DOM.timeSVG) {
            this.DOM.timeSVG = this.DOM.histogram
                .append("svg")
                .attr("class", "timeSVG")
                .attr("xmlns", "http://www.w3.org/2000/svg")
                .style("margin-left", Base.width_HistBarGap / 2 + "px");
            this.DOM.timeSVG
                .append("defs")
                .selectAll("marker")
                .data(Base.Active_Compare_List.map((x) => "kshfLineChartTip_" + x))
                .enter()
                .append("marker")
                .attr("id", (d) => d)
                .attr("patternUnits", "userSpaceOnUse")
                .attr("viewBox", "0 0 20 20")
                .attr("refX", 10)
                .attr("refY", 10)
                .attr("markerUnits", "strokeWidth")
                .attr("markerWidth", 9)
                .attr("markerHeight", 9)
                .attr("orient", "auto")
                .append("circle")
                .attr("r", 4)
                .attr("cx", 10)
                .attr("cy", 10);
            ["Total", "Active"]
                .concat(Array.from(Base.Compare_List).reverse())
                .forEach((cT) => {
                this.DOM["measure_Area_" + cT] = this.DOM.timeSVG
                    .append("path")
                    .attr("class", "measure_Area_" + cT + " measure_" + cT)
                    .attr("marker-mid", "url(#kshfLineChartTip_" + cT + ")")
                    .attr("marker-end", "url(#kshfLineChartTip_" + cT + ")")
                    .attr("marker-start", "url(#kshfLineChartTip_" + cT + ")");
            });
        }
        Base.Total_Active_Compare_List.forEach((cT) => {
            this.DOM["measure_Area_" + cT].datum(this._aggrs).attr("d", d3$7
                .area()
                .curve(d3$7.curveMonotoneX)
                .x(this.attrib.timeAxis_XFunc)
                .y0(this.height_hist - this.measureLineZero + 2)
                .y1(this.height_hist - this.measureLineZero + 2));
        });
        super.insertVizDOM();
    }
    /** -- */
    getVizArea(sT, asLine) {
        if (sT === "Other")
            return;
        var _area = d3$7
            .area()
            .curve(d3$7.curveMonotoneX)
            .x(this.attrib.timeAxis_XFunc)
            .y(
        // sets y0 and y1
        (aggr) => this.height_hist - aggr.sumOffsetScale(sT));
        if (!asLine) {
            _area.y1((aggr) => this.height_hist - aggr.offset(sT));
        }
        /*
        // Removed, bc having all points defined help with smoother transitions between breakdown modes
        if (this.isFiltered()) {
          _area.defined(aggr => {
            if(this.summaryFilter.active.min && this.summaryFilter.active.min > aggr.maxV) return false;
            if(this.summaryFilter.active.max && this.summaryFilter.active.max < aggr.minV) return false;
            return true;
          });
        }
        */
        return _area;
    }
    /** - */
    updateViz_Areas(sT, asLine) {
        if (sT === "Other")
            return;
        return this.DOM["measure_Area_" + sT]
            .classed("asLine", asLine)
            .transition()
            .duration(this.browser.noAnim ? 0 : 800)
            .ease(d3$7.easePoly.exponent(3))
            .attr("d", this.getVizArea(sT, asLine));
    }
    /** -- */
    showValuePicker(DOM, d) {
        if (typeof Pikaday === "undefined")
            return;
        var skipSelect = false;
        var pikaday = DOM.pikaday;
        // All dates are based on UTC.
        // Since dates are created with zone offset by default, need to offset them back sometimes
        var offsetUTC = DateTime.now().offset;
        var refreshPikadayDate = () => {
            var aggr = this.attrib.summaryFilter.active;
            var _date = DateTime.fromJSDate(d === "min" ? aggr.minV : aggr.maxV, { zone: 'UTC' })
                .plus({ minutes: -offsetUTC })
                .toJSDate();
            skipSelect = true;
            pikaday.setDate(_date);
        };
        if (!pikaday) {
            var me = this;
            DOM.pikaday = pikaday = new window.Pikaday({
                field: DOM,
                firstDay: 1,
                minDate: this.attrib.rangeOrg[0],
                maxDate: this.attrib.rangeOrg[1],
                onSelect: function () {
                    if (skipSelect) {
                        skipSelect = false;
                        return;
                    }
                    var selectedDate = this.getDate();
                    selectedDate = DateTime.fromJSDate(selectedDate, { zone: 'UTC' })
                        // need to convert value to UTC
                        .plus({ minutes: offsetUTC })
                        .toJSDate();
                    if ((d === "min" && selectedDate < me.attrib.summaryFilter.active.minV) ||
                        (d === "max" && selectedDate > me.attrib.summaryFilter.active.maxV)) {
                        me.zoomed.set(false);
                    }
                    var minV = me.attrib.summaryFilter.active.minV;
                    var maxV = me.attrib.summaryFilter.active.minV;
                    if (d === "min")
                        minV = selectedDate;
                    if (d === "max")
                        maxV = selectedDate;
                    me.attrib.setRangeFilter_Custom(minV, maxV);
                    refreshPikadayDate();
                },
            });
        }
        refreshPikadayDate();
        pikaday.show();
    }
    getScaleNicing() {
        return this.width_histogram / (this.inDashboard ? this.optimumBinWidth.get() : 10) * 1;
    }
    hasStaticHeight() {
        return this.showHistogram.is(false);
    }
    zoomableStatus() {
        if (this.attrib.stepTicks) {
            if (this.attrib.timeTyped.finestRes() ===
                this.attrib.timeTyped.activeRes.type) {
                return this.zoomed.get() ? "minus" : "";
            }
        }
        return "plus";
    }
}

const d3$6 = { utcFormat };
class Aggregate_Interval_Date extends Aggregate_Interval {
    get label() {
        if (this.minV == null || this.maxV == null)
            return "-";
        // if time selection covers a full year/ month, print as a single year/month
        var m_max = DateTime.fromJSDate(this.maxV, { zone: "UTC" });
        var m_min = DateTime.fromJSDate(this.minV, { zone: "UTC" });
        var interval = Interval.fromDateTimes(m_min, m_max);
        var daysInBetween = interval.toDuration("days").toObject().days;
        if (Math.abs(daysInBetween - 365) < 2 &&
            m_max.month === 1 &&
            m_max.day === 1) {
            return d3$6.utcFormat("%Y")(this.minV);
        }
        if (Math.abs(daysInBetween - 30) < 3 &&
            m_min.day === 1 &&
            m_max.day === 1) {
            return d3$6.utcFormat("%b %Y")(this.minV);
        }
        var minStr = this.attrib.getFormattedValue(this.minV, false);
        var maxStr = this.attrib.getFormattedValue(this.maxV, false);
        return `${this.isMinLarger() ? minStr : ""} ... ${this.isMaxSmaller() ? maxStr : ""}`;
    }
}

const d3$5 = {
    scaleUtc: utcTime,
    utcFormat,
    utcSecond: second,
    utcMinute,
    utcHour,
    utcDay,
    utcWeek: utcSunday,
    utcMonth,
    utcYear,
};
// All dates are based on UTC.
class Attrib_Timestamp extends Attrib_Interval {
    /** -- */
    initTimeTyped() {
        // Check time resolutions
        this.timeTyped.year = false;
        this.timeTyped.month = false;
        this.timeTyped.day = false;
        this.timeTyped.hour = false;
        this.timeTyped.minute = false;
        this.timeTyped.second = false;
        var tempYear = null;
        this.records.forEach((record) => {
            var v = this.getRecordValue(record);
            if (!v)
                return;
            if (v.getUTCMonth() !== 0)
                this.timeTyped.month = true;
            if (v.getUTCHours() !== 0)
                this.timeTyped.hour = true;
            if (v.getUTCMinutes() !== 0)
                this.timeTyped.minute = true;
            if (v.getUTCDate() !== 1)
                this.timeTyped.day = true;
            if (!this.timeTyped.year) {
                if (tempYear === null) {
                    tempYear = v.getUTCFullYear();
                }
                else {
                    if (tempYear !== v.getUTCFullYear())
                        this.timeTyped.year = true;
                }
            }
        });
    }
    constructor(browser, name, template) {
        super(browser, name, template, "timestamp", "kshfSummary_Timestamp", "far fa-calendar-day");
        this._block = new Block_Timestamp(this);
        this.timeAxis_XFunc = (aggr) => (this.valueScale(aggr.minV) + this.valueScale(aggr.maxV)) / 2;
        this.configs.showHistogram.cfgTitle = "Line Chart"; // customize from "Histogram"
        this.timeTyped = {
            // Finest level of resolution
            finestRes: function () {
                if (this.second)
                    return "Second";
                if (this.minute)
                    return "Minute";
                if (this.hour)
                    return "Hour";
                if (this.day)
                    return "Day";
                if (this.month)
                    return "Month";
                if (this.year)
                    return "Year";
            },
        };
    }
    createAggregate(minV, maxV) {
        return new Aggregate_Interval_Date(this, minV, maxV);
    }
    /** -- */
    supportsRecordEncoding(coding) {
        if (this.isEmpty())
            return false;
        if (coding === "sort")
            return true;
        if (coding === "text")
            return true;
        if (coding === "textBrief")
            return true;
        return false;
    }
    /** -- */
    getFormattedValue(v) {
        return v instanceof Date ? this.intervalTickPrint(v) : v;
    }
    getValuePosX(v) {
        var offset = 0;
        if (this.stepTicks) {
            offset += this.block.aggrWidth / 2;
        }
        return this.valueScale(v) + offset;
    }
    /** -- */
    getValueScaleObj() {
        return d3$5.scaleUtc();
    }
    refreshScaleType() {
        return;
    }
    /** -- */
    fillValueCache() {
        this.records.forEach((record) => {
            var v = this.template.func.call(record.data, record);
            if (v === undefined)
                v = null;
            if (!(v instanceof Date))
                v = null;
            record.setValue(this, v);
            if (v == null) {
                this.noValueAggr.addRecord(record);
            }
        });
        this.initTimeTyped();
    }
    /** -- */
    pofffff() {
        this.updateScaleAndBins();
    }
    refreshValueScale() {
        super.refreshValueScale();
        let maxScale = d3$5["utc" + this.timeTyped.finestRes()];
        if (this.intervalTicks.some((tick) => maxScale(tick) < tick)) {
            let nicing = maxScale;
            this.valueScale = this.getValueScaleObj()
                .domain(this.rangeActive)
                .range([0, this.block.width_histogram])
                .nice(maxScale);
            this.intervalTicks = this.valueScale.ticks(nicing);
        }
    }
    updateTickPrintFunc() {
        const formatSecond = d3$5.utcFormat(":%S"), formatMinute = d3$5.utcFormat("%I:%M"), formatHour = d3$5.utcFormat("%I %p"), formatDay = d3$5.utcFormat("%a %d"), formatWeek = d3$5.utcFormat("%b %d"), formatMonth = d3$5.utcFormat("%b"), formatYear = d3$5.utcFormat("%Y");
        this.intervalTickPrint = (date) => {
            return (d3$5.utcMinute(date) < date
                ? formatSecond
                : d3$5.utcHour(date) < date
                    ? formatMinute
                    : d3$5.utcDay(date) < date
                        ? formatHour
                        : d3$5.utcMonth(date) < date
                            ? d3$5.utcWeek(date) < date
                                ? formatDay
                                : formatWeek
                            : d3$5.utcYear(date) < date
                                ? formatMonth
                                : formatYear)(date);
        };
    }
}

const d3$4 = { select, pointer, scaleTime: time, scaleLinear: linear, extent, arc };
class RecordView_List extends RecordView {
    /** -- */
    prepareAttribs() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.sortAttrib) {
                yield this.rd.setAttrib("sort", this.rd.config.sortBy || 0);
            }
            return Promise.resolve(this.sortAttrib !== null);
        });
    }
    constructor(rd, config) {
        super(rd);
        // temporary / internal
        this._recordGroupScroll = null;
        this.animatedList = false; // TEMP
        this.list_showRank = new Config({
            cfgClass: "list_showRank",
            cfgTitle: "Ranking",
            iconXML: "⩔",
            default: false,
            parent: this,
            helparticle: "5e88d84d04286364bc97d40f",
            tooltip: `The ranking column`,
            itemOptions: [
                { name: "Hide", value: false },
                { name: "Show", value: true },
            ],
            onSet: () => {
                if (!this.initialized)
                    return;
                this.refreshShowRank();
            },
        });
        this.list_sortVizRange = new Config({
            cfgClass: "list_sortVizRange",
            cfgTitle: "Sorting Vis Axis",
            iconClass: "fa fa-long-arrow-right",
            default: "dynamic",
            parent: this,
            //helparticle: "5e88d84d04286364bc97d40f",
            tooltip: `The viz scale used for sorting column`,
            itemOptions: [
                { name: "Static", value: "static" },
                { name: "Dynamic", value: "dynamic" },
            ],
            onSet: () => {
                if (!this.initialized)
                    return;
                this.refreshSortVizScale();
            },
        });
        this.list_ViewType = new Config({
            cfgClass: "list_ViewType",
            cfgTitle: "List Type",
            iconClass: "fa fa-list",
            default: "List",
            parent: this,
            helparticle: "5f107e492c7d3a10cbaacc43",
            itemOptions: [
                { name: "List <i class='fa fa-bars'></i>", value: "List" },
                { name: "Grid <i class='fa fa-th'></i>", value: "Grid" },
            ],
            onSet: (v) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                this.DOM.root.attr("data-list_ViewType", v);
                if (!this.initialized)
                    return;
                this.refreshWidthControls();
                if (v === "List") {
                    yield ((_a = this.list_sortVizWidth) === null || _a === void 0 ? void 0 : _a.reset());
                    yield ((_b = this.list_sparklineVizWidth) === null || _b === void 0 ? void 0 : _b.reset());
                }
                else {
                    this.refreshSparklineViz();
                }
            }),
        });
        this.list_sortInverse = new Config({
            cfgClass: "list_sortInverse",
            cfgTitle: "Sorting Order",
            iconClass: "fa fa-sort-amount-asc",
            default: false,
            parent: this,
            helparticle: "5e87f08e2c7d3a7e9aea6081",
            itemOptions: [
                { name: "Large to small", value: false },
                { name: "Small to large", value: true },
            ],
            onSet: () => {
                var _a;
                if (!this.initialized)
                    return;
                this.reverseOrder();
                (_a = this.DOM.root) === null || _a === void 0 ? void 0 : _a.select(".recordReverseSortButton").classed("sortInverse", this.list_sortInverse.is(true));
            },
        });
        this.list_sortColWidth = new Config({
            cfgClass: "list_sortColWidth",
            cfgTitle: "Sorting Value Width",
            iconClass: "fa fa-arrows-h",
            default: 60,
            parent: this,
            helparticle: "5f107eb904286306f806ec35",
            itemOptions: [
                { name: "<i class='fa fa-minus'></i>", value: -99, _type: "minus" },
                { _type: "_range_", minValue: 40, maxValue: 120 },
                { name: "<i class='fa fa-plus'></i>", value: -199, _type: "plus" },
            ],
            preSet: (v, obj) => __awaiter(this, void 0, void 0, function* () {
                if (v === -99) {
                    v = obj._value - 5;
                }
                else if (v === -199) {
                    v = obj._value + 5;
                }
                return Math.max(40, Math.min(120, v));
            }),
            onSet: (v) => {
                this.browser.DOM.root
                    .node()
                    .style.setProperty("--list_sortColWidth", v + "px");
                this.refreshSortColumnWidth();
            },
        });
        this.list_sortVizWidth = new Config({
            cfgClass: "list_sortVizWidth",
            cfgTitle: "Sorting Bar Width",
            iconClass: "fa fa-arrows-h",
            default: 80,
            parent: this,
            helparticle: "5e87f23c04286364bc97d0e3",
            itemOptions: [
                { name: "<i class='fa fa-minus'></i>", value: -99, _type: "minus" },
                { name: "Off", value: 0 },
                { _type: "_range_", minValue: 40, maxValue: 400 },
                { name: "<i class='fa fa-plus'></i>", value: -199, _type: "plus" },
            ],
            forcedValue: (obj) => {
                if (this.sortAttrib instanceof Attrib_Timestamp)
                    return 0;
                if (this.list_ViewType.is("Grid") && obj._value !== 0)
                    return this.list_gridRecordWidth.get() - 10;
            },
            preSet: (v, obj) => __awaiter(this, void 0, void 0, function* () {
                if (v === -99) {
                    v = obj._value - 5;
                }
                else if (v === -199) {
                    v = obj._value + 5;
                }
                if (v < 40)
                    return 0;
                return Math.min(400, v);
            }),
            onSet: (v) => {
                if (!this.initialized)
                    return;
                this.browser.DOM.root
                    .node()
                    .style.setProperty("--list_sortVizWidth", v + "px");
                this.browser.DOM.root.classed("noAnim", true);
                this.refreshSortVizWidth();
                setTimeout(() => this.browser.DOM.root.classed("noAnim", false), 1000);
            },
        });
        this.list_sparklineVizWidth = new Config({
            cfgClass: "list_sparklineVizWidth",
            cfgTitle: "Sparkline Width",
            iconClass: "far fa-chart-line",
            default: 120,
            parent: this,
            helparticle: "5e87f16904286364bc97d0e2",
            itemOptions: [
                { name: "<i class='fa fa-minus'></i>", value: -99, _type: "minus" },
                { name: "Off", value: 0 },
                { _type: "_range_", minValue: 50, maxValue: 300 },
                { name: "<i class='fa fa-plus'></i>", value: -199, _type: "plus" },
            ],
            forcedValue: (obj) => {
                var _a;
                if (!((_a = this.sortAttrib) === null || _a === void 0 ? void 0 : _a.hasTimeSeriesParent()))
                    return 0;
                if (this.list_ViewType.is("Grid") && obj._value !== 0)
                    return this.list_gridRecordWidth.get() - 10;
            },
            preSet: (v, obj) => __awaiter(this, void 0, void 0, function* () {
                if (v === -99) {
                    v = obj._value - 5;
                }
                else if (v === -199) {
                    v = obj._value + 5;
                }
                if (v < 50)
                    return 0;
                return Math.min(300, v);
            }),
            onSet: (v) => {
                if (!this.initialized)
                    return;
                this.browser.DOM.root
                    .node()
                    .style.setProperty("--list_sparklineVizWidth", v + "px");
                this.refreshSparklineVizWidth();
            },
        });
        this.list_gridRecordWidth = new Config({
            cfgClass: "list_gridRecordWidth",
            cfgTitle: "Grid Record Width",
            iconClass: "fa fa-arrows-h",
            default: 200,
            parent: this,
            helparticle: "5f10800c04286306f806ee67",
            itemOptions: [
                { name: "<i class='fa fa-minus'></i>", value: -99, _type: "minus" },
                { _type: "_range_", minValue: 100, maxValue: 400 },
                { name: "<i class='fa fa-plus'></i>", value: -199, _type: "plus" },
            ],
            preSet: (v, obj) => __awaiter(this, void 0, void 0, function* () {
                if (v === -99) {
                    v = obj._value - 5;
                }
                else if (v === -199) {
                    v = obj._value + 5;
                }
                return Math.max(100, Math.min(500, v));
            }),
            onSet: (v) => {
                if (!this.initialized)
                    return;
                this.browser.DOM.root
                    .node()
                    .style.setProperty("--list_gridRecordWidth", v + "px");
                this.refreshSparklineViz();
            },
        });
        [
            "list_ViewType",
            "list_sortInverse",
            "list_showRank",
            "list_sortColWidth",
            "list_sortVizWidth",
            "list_sortVizRange",
            "list_sparklineVizWidth",
            "list_gridRecordWidth",
        ].forEach((t) => {
            this[t].set(config[t]);
            // copy config object to record display as well.
            this.rd.configs[t] = this[t];
            this.rd.recordConfigPanel.insertConfigUI(this[t]);
        });
        // Used in list view
        this.maxVisibleItems_Default =
            config.maxVisibleItems_Default || Base.maxVisibleItems_Default;
        this.maxVisibleRecords = this.maxVisibleItems_Default; // This is the dynamic property
    }
    /** -- */
    initView() {
        this.rd.refreshAttribOptions("sort");
        this.DOM.root.attr("data-list_ViewType", this.list_ViewType.get());
        this.refreshSortColumnWidth();
        this.refreshSortVizWidth();
        this.refreshSparklineVizWidth();
        this.DOM.kshfRecords = this.DOM.recordGroup_List.selectAll(".kshfRecord");
        this.updateRecordSortScale();
        this.refreshRecordVis();
    }
    initView_DOM() {
        return __awaiter(this, void 0, void 0, function* () {
            var browserRootStyle = this.browser.DOM.root.node().style;
            browserRootStyle.setProperty("--list_sortColWidth", this.list_sortColWidth.get() + "px");
            browserRootStyle.setProperty("--list_sortVizWidth", this.list_sortVizWidth.get() + "px");
            browserRootStyle.setProperty("--list_sparklineVizWidth", this.list_sparklineVizWidth.get() + "px");
            browserRootStyle.setProperty("--list_gridRecordWidth", this.list_gridRecordWidth.get() + "px");
            if (this.DOM.recordGroup_List) {
                this.DOM.recordGroup = this.DOM.recordGroup_List.select(".recordGroup");
                this.DOM.kshfRecords = this.DOM.recordGroup.selectAll(".kshfRecord");
                this.DOM.tableHeaderGroup
                    .node()
                    .insertBefore(this.DOM.sortControlGroup.node(), this.DOM.tableConfigGap.node());
                return;
            }
            this.DOM.recordGroup_List = this.rd.DOM.recordDisplayWrapper
                .append("div")
                .attr("class", "recordGroup_List");
            this.DOM.tableHeaderGroup = this.DOM.recordGroup_List
                .append("div")
                .attr("class", "tableHeaderGroup");
            this.DOM.tableHeaderGroup
                .append("div")
                .attr("class", "showRecordRank")
                .append("span")
                .html("Rank");
            this.rd.DOM.sortControlGroup = this.DOM.tableHeaderGroup
                .append("span")
                .attr("class", "sortControlGroup attribControlGroup");
            this.rd.initDOM_AttribSelect("sort");
            this.rd.DOM.sortControlGroup
                .append("span")
                .attr("class", "recordReverseSortButton sortButton")
                .classed("sortInverse", this.list_sortInverse.is(true))
                .tooltip(i18n.ReverseOrder)
                .on("click", () => __awaiter(this, void 0, void 0, function* () { return yield this.list_sortInverse.set(!this.list_sortInverse.get()); }))
                .append("span")
                .attr("class", "fa");
            this.DOM.tableConfigGap = this.DOM.tableHeaderGroup
                .append("span")
                .attr("class", "gap");
            var addMoreVisibleItems = () => {
                this.maxVisibleRecords += this.maxVisibleItems_Default;
                this.rd.refreshRecordDOM();
            };
            this.DOM.recordGroup = this.DOM.recordGroup_List
                .append("div")
                .attr("class", "recordGroup")
                .on("scroll", () => {
                if (this.maxVisibleRecords <= this.browser.allRecordsAggr.recCnt("Active")) {
                    var DOM = this.DOM.recordGroup.node();
                    if (!this._recordGroupScroll) {
                        var s = window.getComputedStyle(DOM);
                        if (s.overflowY === "hidden" && s.overflowX === "scroll")
                            this._recordGroupScroll = "left-right";
                        else if (s.overflowX === "hidden" && s.overflowY === "scroll")
                            this._recordGroupScroll = "top-down";
                    }
                    if (this._recordGroupScroll === "left-right") {
                        if (DOM.scrollWidth - DOM.scrollLeft - DOM.offsetWidth < 500)
                            addMoreVisibleItems();
                    }
                    if (this._recordGroupScroll === "top-down") {
                        if (DOM.scrollHeight - DOM.scrollTop - DOM.offsetHeight < 10)
                            addMoreVisibleItems();
                    }
                }
            });
            var adjustWidth = (event, configObj) => {
                if (event.which !== 1)
                    return; // only respond to left-click
                var mouseDown_width = configObj.val - d3$4.pointer(event, document.body)[0];
                this.browser.activateWidthDrag(event.currentTarget, event, (event2) => {
                    configObj.val = mouseDown_width + d3$4.pointer(event2, document.body)[0];
                });
            };
            this.DOM.adjustSortColumnWidth = this.DOM.recordGroup_List
                .append("div")
                .attr("class", "adjustSortColumnWidth dragWidthHandle")
                .on("mousedown", (event) => adjustWidth(event, this.list_sortColWidth));
            this.DOM.adjustSortVizWidth = this.DOM.recordGroup_List
                .append("div")
                .attr("class", "adjustSortVizWidth dragWidthHandle")
                .on("mousedown", (event) => adjustWidth(event, this.list_sortVizWidth));
            this.DOM.adjustSparklineVizWidth = this.DOM.recordGroup_List
                .append("div")
                .attr("class", "adjustSparklineVizWidth dragWidthHandle")
                .on("mousedown", (event) => adjustWidth(event, this.list_sparklineVizWidth));
            this.refreshSortVizWidth();
            this.refreshWidthControls();
        });
    }
    /** -- */
    extendRecordDOM(newRecords) {
        if (this.animatedList) {
            newRecords.style("transform", `translateY(${this.maxVisibleRecords * this.animatedRecordHeight}px)`);
        }
        // RANKINGS
        var _ = newRecords
            .append("span")
            .attr("class", "recordRank")
            .tooltip("-")
            .on("mouseenter", (event, record) => {
            event.currentTarget.setAttribute("title", Util.ordinal_suffix_of(record.recordRank + 1));
        })
            .append("span");
        this.refreshRecordRanks(_);
        this.DOM.recordRanks = this.DOM.recordGroup.selectAll(".recordRank > span");
        // RECORD CLICK CALLBACK - Used by multiple DOM nodes
        var onRecordClick = (_event, record) => {
            this.browser.recordDetailsPopup.updateRecordDetailPanel(record);
            if (this.sortAttrib instanceof Attrib_Numeric &&
                this.sortAttrib.timeKey) {
                this.browser.recordDetailsPopup.updateFocusedTimeKey(this.sortAttrib.timeKey);
            }
        };
        // SORTING VALUE LABELS AND BARS
        newRecords.append("div").attr("class", "recordSparklineVizHost");
        newRecords
            .append("div")
            .attr("class", "recordSortValue")
            .on("click", onRecordClick);
        newRecords
            .append("div")
            .attr("class", "recordSortVizHost")
            .on("click", onRecordClick)
            .append("div")
            .attr("class", "recordSortViz");
        this.DOM.recordSortValue =
            this.DOM.recordGroup.selectAll(".recordSortValue");
        this.DOM.recordSortVizHost =
            this.DOM.recordGroup.selectAll(".recordSortVizHost");
        this.DOM.recordSortViz = this.DOM.recordGroup.selectAll(".recordSortViz");
        this.DOM.recordSparklineVizHost = this.DOM.recordGroup.selectAll(".recordSparklineVizHost");
        this.refreshSortViz(newRecords);
        this.refreshSparklineViz();
        this.refreshSortingLabels(newRecords);
        // Insert the content
        newRecords
            .append("div")
            .attr("class", "content")
            .html((record) => this.textAttrib.renderRecordValue(record))
            .on("click", onRecordClick);
        newRecords
            .append("svg")
            .attr("class", "compareBoxes")
            .attr("xmlns", "http://www.w3.org/2000/svg")
            .attr("xmlns:xlink", "http://www.w3.org/1999/xlink")
            .attr("viewBox", "-100 -100 200 200")
            .call((compareBoxes) => {
            Base.Compare_List.forEach((cT) => {
                compareBoxes.append("path").attr("class", "glyph_" + cT);
            });
        });
        // Fixes ordering problem when new records are made visible on the list
        // TO-DO: Try to avoid this.
        this.DOM.recordGroup
            .selectAll(".kshfRecord")
            .data(this.getRecordsForDOM(), (record) => record.id)
            .order();
    }
    finishSetAttrib(t) {
        return __awaiter(this, void 0, void 0, function* () {
            if (t === "sort") {
                this.sortRecords();
                this.refreshSortVizWidth();
                if (this.DOM.recordGroup_List) {
                    this.rd.refreshRecordDOM();
                    this.refreshRecordDOMOrder();
                    this.refreshRecordRanks();
                    this.refreshSortingLabels();
                    this.refreshSparklineViz();
                    if (this.rd.config.recordRefresh) {
                        this.DOM.kshfRecords.each((r) => {
                            this.rd.config.recordRefresh.call(r.data, r, this);
                        });
                    }
                }
            }
            if (t === "text") {
                this.DOM.kshfRecords
                    .selectAll(".content")
                    .html((record) => this.textAttrib.renderRecordValue(record));
            }
        });
    }
    // ********************************************************************
    // Record sorting
    // ********************************************************************
    /** -- */
    reverseOrder() {
        this.browser.records.reverse();
        var arr = this.browser.records;
        var maxLoop = arr.length;
        for (var i = 0; i < maxLoop; i++) {
            var v = this.sortAttrib.getRecordValue(arr[0]);
            if (v === null || v === undefined) {
                arr.push(arr.shift());
            }
            else {
                break;
            }
        }
        this.refreshRecordVis();
        this.refreshRecordDOMOrder();
    }
    /**
     * Sort all records given the active sort option
     * Records are only sorted on init & when active sorting option changes.
     * They are not resorted on filtering.
     */
    sortRecords() {
        var attrib = this.sortAttrib;
        if (!attrib)
            return;
        var sortFunc = this.getSortFunc(attrib.template.func);
        var inverse = this.list_sortInverse.is(true);
        this.browser.records.sort((record_A, record_B) => {
            var v_a = attrib.getRecordValue(record_A);
            var v_b = attrib.getRecordValue(record_B);
            if (v_a == null && v_b != null)
                return 1;
            if (v_b == null && v_a != null)
                return -1;
            if (v_b == null && v_a == null)
                return 0;
            // Don't move filtered-out records to end of the list, keep them in sorted order
            // This way, you don't need to re-order after filtering, which is a nice property to have.
            var dif = sortFunc(v_a, v_b);
            return inverse ? -dif : dif;
        });
        this.updateRecordRanks();
    }
    /** Returns the sort value type for given sort Value function */
    getSortFunc(sortValueFunc) {
        var sortValueFunction;
        // find appropriate sortvalue type
        for (var k = 0, same = 0; true; k++) {
            if (same === 3 || k === this.browser.records.length)
                break;
            var item = this.browser.records[k];
            var f = sortValueFunc.call(item.data, item);
            if (f == null || f === "")
                continue;
            var sortValueType_tmp;
            switch (typeof f) {
                case "string":
                    sortValueType_tmp = Util.sortFunc_List_String;
                    break;
                case "number":
                    sortValueType_tmp = Util.sortFunc_List_Number;
                    break;
                case "object":
                    sortValueType_tmp = (f instanceof Date)
                        ? Util.sortFunc_List_Date
                        : Util.sortFunc_List_Number;
                    break;
                default:
                    sortValueType_tmp = Util.sortFunc_List_Number;
                    break;
            }
            if (sortValueType_tmp === sortValueFunction) {
                same++;
            }
            else {
                sortValueFunction = sortValueType_tmp;
                same = 0;
            }
        }
        return sortValueFunction;
    }
    /** -- */
    updateRecordRanks() {
        var wantedRank = 0;
        var unwantedRank = -1;
        var lastValue = null;
        var lastRank = null;
        // records are sorted, and iterated from top to bottom
        this.browser.records.forEach((record) => {
            var v = this.sortAttrib.getRecordValue(record);
            if (v instanceof Date)
                v = v.getTime();
            // Records with the same value have the same "rank".
            // Once there value changes, ranking resumes from "total" ranks, counting each same-rank record separately.
            record.recordRank = record.isIncluded
                ? v === lastValue
                    ? lastRank
                    : wantedRank
                : unwantedRank;
            record.recordRank_Unique = record.isIncluded ? wantedRank : unwantedRank;
            if (record.isIncluded && v !== lastValue) {
                lastValue = v;
                lastRank = record.recordRank;
            }
            if (record.isIncluded) {
                wantedRank++;
            }
            else {
                unwantedRank--;
            }
        });
        this.maxVisibleRecords = this.maxVisibleItems_Default;
    }
    /** -- */
    refreshShowRank() {
        this.DOM.root.classed("showRank", this.list_showRank.is(true));
        this.refreshRecordRanks();
        this.refreshWidthControls();
    }
    /** -- */
    refreshRecordRanks(d3_selection = null) {
        if (this.list_showRank.is(false))
            return;
        if (d3_selection === null)
            d3_selection = this.DOM.recordRanks;
        d3_selection.text((record) => record.recordRank < 0 ? "" : record.recordRank + 1);
    }
    /** -- */
    updateRecordVisibility() {
        this.DOM.kshfRecords.classed("rankBeyondListRange", (record) => record.recordRank < 0 || record.recordRank >= this.maxVisibleRecords);
    }
    /** -- */
    getRecordsForDOM() {
        return this.browser.records.filter((record) => !record.filteredOut && record.recordRank < this.maxVisibleRecords);
    }
    /** -- */
    refreshWidthControls() {
        var _a, _b, _c, _d;
        if (!this.rd.codeBy.sort)
            return;
        var w_Rank = this.list_showRank.is(true) ? Base.recordRankWidth : 0;
        var w_sortCol = this.list_sortColWidth.get();
        var w_sortViz = this.list_sortVizWidth.get();
        var w_sparkLine = this.list_sparklineVizWidth.get()
            ? this.list_sparklineVizWidth.get() + 8
            : 0;
        (_a = this.DOM.adjustSparklineVizWidth) === null || _a === void 0 ? void 0 : _a.style("transform", `translateX(${w_Rank + w_sparkLine}px`);
        (_b = this.DOM.adjustSortColumnWidth) === null || _b === void 0 ? void 0 : _b.style("transform", `translateX(${w_Rank + w_sparkLine + w_sortCol}px)`);
        (_c = this.DOM.adjustSortVizWidth) === null || _c === void 0 ? void 0 : _c.style("transform", `translateX(${w_Rank + w_sparkLine + w_sortCol + w_sortViz}px)`);
        var w = Math.max(150, Math.min(500, w_sparkLine + w_sortCol + w_sortViz + 2)); // 2 pixel: margin
        if (this.list_ViewType.is("Grid")) {
            w = 200;
        }
        (_d = this.DOM.sortControlGroup) === null || _d === void 0 ? void 0 : _d.select(".choices").style("width", w + "px");
    }
    /** -- */
    refreshSortVizScale() {
        var attrib = this.sortAttrib;
        if (!(attrib instanceof Attrib_Numeric)) {
            return; // invalid if not sorting using numeric attribute
        }
        this.listSortVizScale = d3$4
            .scaleLinear()
            .range([0, this.list_sortVizWidth.get()]);
        if (attrib.isPercentageUnit()) {
            // always 0-100 if percentage unit
            this.listSortVizScale.domain([0, 100]);
            //
        }
        else if (this.list_sortVizRange.is("dynamic")) {
            // dynamic - based on filtered data
            let [minV, maxV] = d3$4.extent(this.browser.records, (record) => {
                return record.filteredOut
                    ? null
                    : this.sortAttrib.getRecordValue(record);
            });
            this.listSortVizScale.domain([Math.min(0, minV), Math.max(0, maxV)]);
            //
        }
        else if (this.list_sortVizRange.is("static")) {
            // static - based on original domain
            this.listSortVizScale.domain(this.sortAttrib.rangeOrg);
        }
        this.refreshSortViz();
    }
    /** -- */
    refreshSelect_Compare(cT = null, status = false) {
        if (!this.isComparable())
            return;
        // Shows evenly spaces pies next to records, filling in colors of all comparisons
        var arcGen = d3$4.arc()
            .innerRadius(10)
            .outerRadius(100)
            .padAngle(0.15);
        var records = this.DOM.kshfRecords.filter((record) => {
            if (!record.isIncluded)
                return false;
            if (!record.DOM.record)
                return false;
            if (cT && record.isSelected(cT) !== status)
                return false;
            return true;
        });
        if (cT) {
            records = records.filter((record) => record.isSelected(cT) !== status);
        }
        records.each((record) => {
            let numPies = record.activeComparisons.length || 1;
            let arcLen = (2 * Math.PI) / numPies;
            let d = d3$4.select(record.DOM.record);
            record.activeComparisons.forEach((cT, i) => {
                d.select(".glyph_" + cT).attr("d", arcGen({
                    startAngle: arcLen * i,
                    endAngle: arcLen * (i + 1),
                }) // has other settings specified above
                );
            });
        });
    }
    /** -- */
    refreshSortColumnWidth() {
        this.refreshWidthControls();
    }
    /** -- */
    refreshSortVizWidth() {
        this.refreshSortVizScale();
        this.DOM.root.classed("showSortBars", this.list_sortVizWidth.get() > 0);
        this.refreshWidthControls();
    }
    /** -- */
    refreshSparklineVizWidth() {
        if (!this.DOM.recordSparklineVizHost)
            return;
        this.DOM.recordSparklineVizHost.style("display", this.list_sparklineVizWidth.get() === 0 ? "none" : null);
        this.refreshSparklineViz();
        this.refreshWidthControls();
    }
    /** -- */
    refreshRecordVis() {
        this.updateRecordRanks();
        this.rd.refreshRecordDOM();
        this.animateList();
        this.refreshRecordRanks();
        this.refreshSortViz();
        this.refreshSparklineViz();
    }
    /** -- */
    refreshSortViz(d3_selection = null) {
        var dom = d3_selection
            ? d3_selection.select(".recordSortViz")
            : this.DOM.recordSortViz;
        if (!dom || dom.nodes().length === 0)
            return;
        if (!(this.sortAttrib instanceof Attrib_Numeric)) {
            dom.style("width", "0px").style("left", null);
            return;
        }
        var zeroPos = this.listSortVizScale(0);
        dom.style("transform", (record) => {
            var v = this.sortAttrib.getRecordValue(record);
            return `translate(${v >= 0 ? zeroPos : this.listSortVizScale(v)}px, 0px) scale(${v == null ? 0 : Math.abs(this.listSortVizScale(v) - zeroPos)},1)`;
        });
    }
    refreshSparklineViz() {
        var attrib = this.sortAttrib;
        if (!attrib)
            return;
        if (!(attrib instanceof Attrib_Numeric))
            return;
        if (!attrib.hasTimeSeriesParent())
            return;
        if (!this.DOM.recordSparklineVizHost)
            return;
        this.DOM.recordSparklineVizHost.style("display", this.list_sparklineVizWidth.get() === 0 ? "none" : null);
        if (this.list_sparklineVizWidth.get() === 0)
            return;
        var ts = attrib.timeseriesParent;
        var timeScale = d3$4
            .scaleTime()
            .domain(ts.timeSeriesScale_Time.domain())
            .range([0, this.list_sparklineVizWidth.get()]);
        var valueScale = d3$4
            .scaleLinear()
            .domain(ts.timeSeriesScale_Value.domain())
            .rangeRound([27, 3]);
        var activeTime = attrib.timeKey._time;
        var dotPosition = (record, i, nodes) => {
            var v = attrib.getRecordValue(record);
            if (v == null)
                return "translate(-1000,0)"; // not visible
            var x = timeScale(activeTime);
            var lineData = ts.getRecordValue(record);
            valueScale.domain(lineData.extent_Value_raw);
            var y = valueScale(v);
            nodes[i].classList[y > 13 ? "add" : "remove"]("upper");
            return `translate(${x},${y})`;
        };
        this.DOM.recordSparklineVizHost.selectAll("*").remove();
        var _ = this.DOM.recordSparklineVizHost
            .append("svg")
            .attr("xmlns", "http://www.w3.org/2000/svg")
            .on("mouseleave", (event) => {
            d3$4.select(event.currentTarget.children[1]).attr("transform", dotPosition);
        })
            .on("mousemove", (event) => {
            var _time = timeScale.invert(d3$4.pointer(event, event.currentTarget)[0]);
            var currentDif = 9999999999999; // large number
            var nearestTimeKey = ts.timeKeys[0];
            ts.timeKeys.some((_key) => {
                // _keys are sorted from early to late
                var timeDif = Math.abs(+_key._time - +_time);
                if (timeDif > currentDif)
                    return true; // difference increases, we had just found the right key
                currentDif = timeDif;
                nearestTimeKey = _key;
                return false;
            });
            d3$4.select(event.currentTarget.children[1]).attr("transform", (record, i, nodes) => {
                var x = timeScale(nearestTimeKey._time);
                var _ = ts.getRecordValue(record);
                valueScale.domain(_.extent_Value_raw);
                var tk = _._timeseries_.find((x) => x._time_src === nearestTimeKey._time_src);
                let v = tk ? tk._value : null;
                var y = valueScale(v);
                if (y == null)
                    return "translate(-100,-100)"; // No value / no dot / out of screen
                var DOM = nodes[i];
                if (y > 13)
                    DOM.classList.add("upper");
                else
                    DOM.classList.remove("upper");
                return `translate(${x},${y})`;
            });
            d3$4.select(event.currentTarget.children[1].children[1]).text(nearestTimeKey._time_src);
        });
        _.append("path")
            .attr("class", "timeline")
            .attr("d", (record) => {
            var lineData = ts.getRecordValue(record);
            if (!lineData || !lineData.extent_Value_raw)
                return;
            valueScale.domain(lineData.extent_Value_raw);
            return Util.getLineGenerator(timeScale, valueScale)(lineData._timeseries_);
        });
        var __ = _.append("g")
            .attr("transform", dotPosition)
            .on("click", (event) => __awaiter(this, void 0, void 0, function* () {
            var _time = timeScale.invert(d3$4.pointer(event, event.currentTarget.parentNode)[0]);
            var currentDif = 9999999999999; // large number
            var nearestTimeKey = ts.timeKeys[0];
            ts.timeKeys.some((_key) => {
                // _keys are sorted from early to late
                var timeDif = Math.abs(+_key._time - (+_time));
                if (timeDif > currentDif)
                    return true; // difference increases, we had just found the right key
                currentDif = timeDif;
                nearestTimeKey = _key;
                return false;
            });
            yield this.rd.currentTimeKey.set(nearestTimeKey);
        }));
        __.append("circle").attr("class", "activeDot").attr("r", 3);
        __.append("text")
            .attr("class", "timekeyText")
            .attr("y", 15)
            .text(attrib.timeKey._time_src);
    }
    /** -- */
    animateList() {
        if (!this.animatedList)
            return;
        this.DOM.recordGroup_List.classed("animatedList", true);
        this.DOM.kshfRecords.style("transform", (record) => `translateY(${record.recordRank_Unique * this.animatedRecordHeight}px)`);
    }
    /** -- */
    refreshRecordDOMOrder() {
        if (!this.animatedList) {
            this.DOM.kshfRecords = this.DOM.recordGroup
                .selectAll(".kshfRecord")
                .data(this.browser.records, (record) => record.id)
                .order();
        }
        Util.scrollToPos_do(this.DOM.recordGroup, 0);
        this.animateList();
    }
    /** -- */
    refreshSortingLabels(d3_selection = null) {
        if (!this.sortAttrib)
            return;
        var sortLabel = this.sortAttrib.sortLabel;
        var dom = d3_selection
            ? d3_selection.selectAll(".recordSortValue")
            : this.DOM.recordSortValue;
        if (!dom)
            return;
        dom.html((record) => {
            var v = sortLabel.call(this, record);
            return v === "" || v === null || v === "NaN" ? "N/A" : v;
        });
    }
    /** -- */
    updateAfterFilter() {
        this.DOM.recordGroup.node().scrollTop = 0;
        if (this.list_sortVizRange.is("dynamic")) {
            this.refreshSortVizScale();
        }
        this.refreshRecordVis();
    }
    /** -- */
    updateRecordSortScale() {
        var _a;
        this.DOM.root.attr("sortAttribType", this.sortAttrib instanceof Attrib_Numeric ? "numeric" : "time");
        this.DOM.root.classed("sortAttribOnTimeseries", (this.sortAttrib instanceof Attrib_Numeric &&
            ((_a = this.sortAttrib.timeseriesParent) === null || _a === void 0 ? void 0 : _a.timeKeys.length) > 1) ||
            null);
    }
    refreshAttribUnitName(attrib) {
        if (attrib === this.sortAttrib ||
            (this.sortAttrib instanceof Attrib_Numeric &&
                attrib === this.sortAttrib.timeseriesParent)) {
            this.refreshSortingLabels();
        }
    }
    // ********************************************************************
    // No-op's
    // ********************************************************************
    refreshViewSize(_delayMS) { }
}

const d3$3 = {
    select,
    scaleLinear: linear,
    scaleSqrt: sqrt,
    scaleThreshold: threshold,
    scaleTime: time,
    max,
    extent,
    quantile,
    easePolyInOut: polyInOut,
    format,
    hsl,
    arc,
};
/** -- */
class RecordDisplay {
    setView(_type) {
        return __awaiter(this, void 0, void 0, function* () {
            if (_type === "none") {
                this.View = null;
                return;
            }
            // Create the view object if it does not exist.
            if (!this.Views[_type]) {
                var recordDisplayOptions = this.browser.options.recordDisplay || {};
                if (_type === "list") {
                    this.Views[_type] = new RecordView_List(this, recordDisplayOptions);
                }
                else if (_type === "map") {
                    this.Views[_type] = new RecordView_Map(this, recordDisplayOptions);
                }
                else if (_type === "scatter") {
                    this.Views[_type] = new RecordView_Scatter(this, recordDisplayOptions);
                }
                else if (_type === "timeseries") {
                    this.Views[_type] = new RecordView_Timeseries(this, recordDisplayOptions);
                }
            }
            this.View = this.Views[_type];
            if (!this.codeBy.text) {
                var potentials = this.browser.attribs.filter((attrib) => attrib instanceof Attrib_Categorical);
                if (potentials.length === 0) {
                    throw new Error("Data must have at least one categorical attribute.");
                }
                // find the categorical attribute with most number of categories (i.e. most unique)
                var mostUnique = potentials[0];
                potentials.forEach((catAttr) => {
                    if (mostUnique._aggrs.length < catAttr._aggrs.length) {
                        mostUnique = catAttr;
                    }
                });
                this.codeBy.text = mostUnique;
            }
            this.recordConfigPanel.hide();
            yield this.View.initView_DOM();
            yield this.View.prepareAttribs();
            this.refreshViewAsOptions();
            this.View.initView();
            this.View.initialized = true;
            this.View.updateRecordVisibility();
            this.refreshWidth();
            this.View.refreshViewSize(10);
        });
    }
    /** -- */
    constructor(browser, config) {
        // ********************************************************************
        // record vis mapping attributes
        // ********************************************************************
        this.codeBy = {
            text: null,
            textBrief: null,
            sort: null,
            scatterX: null,
            scatterY: null,
            size: null,
            color: null,
            timeSeries: null,
            geo: null,
        };
        // ********************************************************************
        // Color control (shared)
        // ********************************************************************
        this.invertedColorTheme = false;
        this.recordColorStepTicks = false;
        this.recordColorScale = null;
        this.recordColorScaleTicks = null;
        this.mapColorScalePos = null;
        // ********************************************************************
        // Time keys / current key (used for synchronizing time keys)
        // ********************************************************************
        this.timeKeys = [];
        this.timeKeySlider_PauseUpdate = true;
        // ********************************************************************
        // ...
        // ********************************************************************
        // general text filter (on text attribute)
        this.textFilter = null;
        // record filter: to filter out individual records
        this.recordFilter = null;
        this.collapsed = false;
        this.DOM = {};
        this.Views = {};
        this.configs = {};
        this.visMouseMode = "pan";
        this.kshfRecords_Type = "none";
        this.attribDropdowns = {};
        this.timeseriesAnimInterval = 0;
        this.skipRefreshRecordVis = false;
        this.sparklineCounter = 0;
        this.browser = browser;
        this.recordFilter = new Filter_Record(this.browser);
        this.config = Object.assign({}, config);
        if (this.config.mapUsePins !== false) {
            this.config.mapUsePins = true;
        }
        this.recordPointSize = new Config({
            cfgClass: "recordPointSize",
            cfgTitle: "Point Size",
            iconClass: "fa fa-dot",
            UI: { disabled: true },
            default: Base.defaultRecordPointSize,
            parent: this,
            helparticle: "5e8907cf2c7d3a7e9aea6499",
            preSet: (v) => __awaiter(this, void 0, void 0, function* () { return Math.max(0.5, Math.min(v, Base.maxRecordPointSize)); }),
            onSet: () => __awaiter(this, void 0, void 0, function* () {
                if (!this.recordPointSize)
                    return;
                this.updateRecordSizeScale();
            }),
        });
        this.currentTimeKey = new Config({
            cfgClass: "currentTimeKey",
            cfgTitle: "Focused Time Key",
            iconClass: "fa fa-arrows-v",
            default: null,
            parent: this,
            UI: { disabled: true },
            helparticle: "5b37053a2c7d3a0fa9a3a30c",
            onRefreshDOM: () => {
                if (!this.DOM.root)
                    return;
                this.DOM.root.classed("hasTimeKey", this.hasTimeKey);
                if (!this.currentTimeKey.get())
                    return;
                if (!this.DOM.timeAnimation)
                    return;
                if (!this.hasTimeKey)
                    return;
                this.DOM.timeAnimation
                    .select(".rangeTick-min")
                    .text(this.timeKeys[0]._time_src);
                this.DOM.timeAnimation
                    .select(".rangeTick-max")
                    .text(this.timeKeys[this.timeKeys.length - 1]._time_src);
                this.DOM.timeAnimation
                    .select(".rangeTick-cur")
                    .text(this.currentTimeKey.get()._time_src)
                    .style("left", (100 * this.currentTimeKey.get()._index) /
                    (this.timeKeys.length - 1) +
                    "%");
                this.timeKeySlider_PauseUpdate = true;
                this.timeKeySlider.updateOptions({
                    range: {
                        min: 0,
                        max: Math.max(1, this.timeKeys.length - 1),
                    },
                });
                this.timeKeySlider.setHandle(0, this.currentTimeKey.get()._index, false);
                this.timeKeySlider_PauseUpdate = false;
                this.DOM.timeAnimation
                    .select(".timeKeySelect")
                    .selectAll("option")
                    .data(this.timeKeys, (d) => d._time)
                    .join((enter) => enter.append("option").text((d) => d._time_src), (update) => update, (exit) => exit.remove())
                    .attr("selected", (timeKey) => timeKey._time_src === this.currentTimeKey.get()._time_src
                    ? true
                    : null);
            },
            preSet: (v, obj) => __awaiter(this, void 0, void 0, function* () {
                if (v === "previous" && obj._value) {
                    v = this.timeKeys[obj._value._index - 1];
                }
                if (v === "next" && obj._value) {
                    v = this.timeKeys[obj._value._index + 1];
                }
                if (!v || !v._time_src)
                    return;
                // _index may have been updated. Better to refresh
                v = this.timeKeys.find((_) => _._time_src === v._time_src);
                if (!v)
                    return;
                return v;
            }),
            onSet: (v) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                if (!v)
                    return;
                // sync timekey across all vis attributes
                this.skipRefreshRecordVis = true;
                ["sort", "scatterX", "scatterY", "color", "size"].forEach((_type) => {
                    var _a;
                    var targetAttrib = this.codeBy[_type];
                    if (targetAttrib instanceof Attrib_Numeric &&
                        ((_a = targetAttrib.timeKey) === null || _a === void 0 ? void 0 : _a._time_src) !== v._time_src) {
                        // record visualizations are updated through these setting updates
                        this.setAttrib(_type, targetAttrib.timeseriesParent.getTimepointSummary({
                            _time_src: v._time_src,
                        }));
                    }
                });
                this.skipRefreshRecordVis = false;
                this.refreshRecordVis(); // refresh visualization ONCE after all attributes are updated.
                // update measure attrib to use the same time key
                if ((_a = this.measureSummary) === null || _a === void 0 ? void 0 : _a.hasTimeSeriesParent()) {
                    var newMeasureSummary = this.measureSummary.timeseriesParent.getTimepointSummary(v);
                    if (newMeasureSummary)
                        yield this.browser.measureSummary.set(newMeasureSummary);
                }
                // timeKeyStep timeKeyNext
                this.DOM.timeAnimation
                    .select(".timeKeyPrev")
                    .classed("active", v._time_src !== this.timeKeys[0]._time_src);
                this.DOM.timeAnimation
                    .select(".timeKeyNext")
                    .classed("active", v._time_src !== this.timeKeys[this.timeKeys.length - 1]._time_src);
            }),
        });
        ["currentTimeKey", "recordPointSize"].forEach((t) => {
            this.configs[t] = this[t];
            this[t].val = config[t];
        });
        if (config.timeSeriesAnnotations) {
            var _converted = [];
            Object.keys(config.timeSeriesAnnotations).forEach((_k) => {
                var _v = config.timeSeriesAnnotations[_k];
                var _t = DateTime.fromFormat(_v, DateTime.DATE_SHORT, { zone: "UTC" });
                if (_t.isValid) {
                    _converted.push({ _time: _t.toJSDate(), _time_src: _k, _text: _v });
                }
            });
            this.config.timeSeriesAnnotations = _converted;
        }
        config.timeseriesWidth = config.timeseriesWidth || 400;
    }
    /** Shortcut to access browser record chart type */
    get viewRecAs() {
        return this.browser.recordChartType.get();
    }
    initialize() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            var config = this.config;
            // **********************************************************************************
            // **********************************************************************************
            // **********************************************************************************
            this.DOM.root = this.browser.DOM.root
                .select(".recordDisplay")
                .attr("visMouseMode", this.visMouseMode);
            this.DOM.root
                .append("div")
                .attr("class", "dropZone")
                .on("mouseenter", function () {
                this.classList.add("onReadyToDrop");
            })
                .on("mouseleave", function () {
                this.classList.remove("onReadyToDrop");
            })
                .on("mouseup", () => __awaiter(this, void 0, void 0, function* () {
                if (this.viewRecAs !== "none") {
                    return;
                }
                var attrib = this.browser.movedAttrib;
                if (!attrib)
                    return;
                if (attrib instanceof Attrib_Categorical) {
                    yield this.setAttrib("text", attrib);
                    if (this.viewRecAs === "none") {
                        yield this.browser.recordChartType.set("list");
                    }
                }
                else if (attrib instanceof Attrib_Timeseries) {
                    yield this.setAttrib("timeSeries", attrib);
                    yield this.browser.recordChartType.set("timeseries");
                    //
                }
                else if (attrib instanceof Attrib_RecordGeo) {
                    yield this.setAttrib("geo", attrib);
                    yield this.browser.recordChartType.set("map");
                    //
                }
                else if (attrib instanceof Attrib_Interval) {
                    yield this.setAttrib("sort", attrib);
                    if (this.viewRecAs === "none") {
                        yield this.browser.recordChartType.set("list");
                    }
                }
                this.browser.updateLayout();
            }))
                .call((x) => {
                x.append("div").attr("class", "dropIcon fa fa-list-ul");
                x.append("span")
                    .attr("class", "dropZoneText")
                    .text(i18n["Add Record Panel"]);
            });
            this.initDOM_RecordDisplayHeader();
            // **************************************************
            // TIME ANIMATION
            this.DOM.timeAnimation = this.DOM.root
                .append("div")
                .attr("class", "timeAnimation");
            this.DOM.recordDisplayWrapper = this.DOM.root
                .append("div")
                .attr("class", "recordDisplayWrapper");
            this.initDOM_CustomControls();
            this.recordConfigPanel = new ConfigPanel(this.DOM.root, "Record Chart Configuration", "recordDisplayConfig", Object.values(this.configs), this.browser, this.DOM.recordDisplayConfigButton);
            // always set record text attribute
            yield this.setAttrib("text", config.textBy);
            if (!this.codeBy.text) {
                yield this.setAttrib("text", this.browser.idSummaryName);
            }
            yield this.setAttrib("textBrief", config.textBriefBy);
            // *************************************************************************
            // Initialize config options
            for (var v in [
                "sort",
                "scatterX",
                "scatterY",
                "color",
                "size",
                "link",
                "timeSeries",
            ]) {
                var _attrib = config[v + "By"];
                if (_attrib)
                    yield this.setAttrib(v, _attrib);
            }
            this.textFilter = new Filter_Text(this.browser);
            if (config.colorTheme) {
                this.setRecordColorTheme(config.colorTheme);
            }
            if (config.recordPointSize) {
                yield this.recordPointSize.set(config.recordPointSize);
            }
            if (config.colorInvert) {
                this.invertColorTheme(true);
            }
            if (config.filter) {
                this.recordFilter.importFilter(config.filter);
            }
            else {
                this.recordFilter.clearFilter();
            }
            (_a = config.viewAs) !== null && _a !== void 0 ? _a : (config.viewAs = "none");
            if (config.viewAs !== this.viewRecAs) {
                yield this.browser.recordChartType.set(config.viewAs);
            }
            if (config.collapsed) {
                this.collapseRecordViewSummary(true);
            }
            else {
                this.collapseRecordViewSummary(false);
            }
        });
    }
    /** -- */
    refreshConfigs() {
        Object.values(this.configs).forEach((cfg) => cfg.refresh());
    }
    setHeight(v) {
        var oldHeight = this.curHeight;
        this.curHeight = v;
        if (this.viewRecAs === "none")
            return;
        if (this.curHeight !== oldHeight)
            this.View.refreshViewSize(0);
    }
    setWidth(v) {
        var oldWidth = this.curWidth;
        this.curWidth = v;
        if (this.viewRecAs === "none")
            return;
        if (this.curWidth !== oldWidth) {
            this.refreshWidth();
            this.View.refreshViewSize(0);
        }
    }
    refreshWidth() {
        var _a;
        (_a = this.DOM.root) === null || _a === void 0 ? void 0 : _a.classed("narrow", this.curWidth < 500).classed("wide", this.curWidth > 700).style("width", this.curWidth + "px");
    }
    /** -- */
    getNumOfColorScaleBins() {
        return this.recordColorScale.range().length - 2;
    }
    /** -- */
    get textAttrib_Brief() {
        return this.codeBy.textBrief || this.codeBy.text;
    }
    /** -- */
    get height_Header() {
        if (!this.DOM.recordDisplayHeader)
            return 0;
        return this.DOM.recordDisplayHeader.node().offsetHeight;
    }
    /** -- */
    refreshCompareLegend() {
        if (!this.DOM.colorCompareGroup)
            return;
        this.DOM.colorCompareGroup.classed("active", !!this.browser.comparedAttrib);
        if (!this.browser.comparedAttrib ||
            !this.browser.comparedAttrib.attribName) {
            return;
        }
        var str = "<div class='comparedSummaryName'>" +
            this.browser.comparedAttrib.attribNameHTML +
            "</div>";
        str += "<div class='compareBlocks'>";
        this.browser.activeComparisons.forEach((cT) => {
            str += `<div class='compareBlock'><span class='colorBox bg_${cT}'></span> 
        <span class='theText'>${this.browser.selectedAggrs[cT].label}</span></div>`;
        });
        // "Other group"
        if (this.browser.records.filter(
        // TODO: depending on view type certain records may be excluded
        // Example: Map: records with no geo. Timeseries : records with no timeseries, etc.
        (x) => !x.isSelected() && x.isIncluded).length) {
            str +=
                "<div class='compareBlock'><span class='colorBox bg_Active'></span> " +
                    `<span class='theText'>(${this.browser.otherNameInCompare})</span></div>`;
        }
        str += "</div>";
        this.DOM.colorCompareGroup.html(str).classed("active", true);
    }
    getColorValue(v) {
        if (this.codeBy.color instanceof Attrib_Numeric) {
            return this.codeBy.color.getFormattedValue(v);
        }
        else {
            return v;
        }
    }
    /** -- */
    refreshColorLegend() {
        var _a;
        if (!this.DOM.mapColorScaleGroup)
            return;
        this.DOM.root
            .select(".editColorTheme.fa-adjust")
            .classed("rotatedY", this.invertedColorTheme);
        this.DOM.root.classed("usesColorAttrib", this.codeBy.color != null);
        if (!this.recordColorScale)
            return;
        if (!this.codeBy.color)
            return;
        var colorBins = this.recordColorScale.range();
        // remove first and last color elements
        colorBins = colorBins.slice(1, colorBins.length - 1);
        var logScale = false;
        if (this.codeBy.color === "_measure_") {
            if ((_a = this.measureSummary) === null || _a === void 0 ? void 0 : _a.isValueScale_Log) {
                logScale = true;
            }
        }
        else {
            if (this.codeBy.color.isValueScale_Log) {
                logScale = true;
            }
        }
        this.mapColorScalePos = Util.getD3Scale(logScale);
        var totalDomain = this.recordColorScale.domain();
        this.mapColorScalePos
            .domain([totalDomain[0], totalDomain[totalDomain.length - 1]])
            .range([0, 100]);
        this.DOM.mapColorScaleBins.selectAll(".mapColorThemeBin").remove();
        this.DOM.mapColorScaleBins
            .selectAll(".mapColorThemeBin")
            .data(colorBins)
            .enter()
            .append("div")
            .attr("class", "mapColorThemeBin")
            .tooltip((_) => {
            var d = this.recordColorScale.invertExtent(_);
            return this.recordColorStepTicks
                ? d[0]
                : this.getColorValue(d[0]) + " &mdash; " + this.getColorValue(d[1]);
        }, {
            placement: "bottom",
        })
            .style("background-color", (d) => d)
            .style("transform", (d, i) => {
            var d = this.recordColorScale.invertExtent(d);
            var left = this.mapColorScalePos(d[0]);
            var right = this.mapColorScalePos(d[1]);
            return `translateX(${left}%) scaleX(${Math.abs(right - left) / 100})`;
        });
        this.refreshColorLegendTicks();
    }
    /** -- */
    refreshColorLegendTicks() {
        if (!this.codeBy.color)
            return;
        if (!this.recordColorScaleTicks)
            return;
        var legendWidth = this.DOM.mapColorScaleLabels.node().offsetWidth;
        var lastTickPos = -200;
        var tickWidthGap = 30;
        let c = null;
        if (this.codeBy.color === "_measure_") {
            var attrib = !this.browser.measureFunc_Count && this.measureSummary;
            if (attrib) {
                c = attrib;
                tickWidthGap += attrib.unitName.length * 6;
            }
        }
        else {
            c = this.codeBy.color;
            tickWidthGap += this.codeBy.color.unitName.length * 6;
        }
        var _print = (v) => (c ? c.printAbbr(v) : v);
        var ticks = this.recordColorScaleTicks.slice();
        var offset = 0;
        if (this.recordColorStepTicks) {
            ticks.pop();
            offset = 50 / ticks.length;
        }
        this.DOM.mapColorScaleLabels.selectAll(".mapColorScaleLabel").remove();
        this.DOM.mapColorScaleLabels
            .selectAll(".mapColorScaleLabel")
            .data(ticks)
            .enter()
            .append("div")
            .attr("class", "mapColorScaleLabel")
            .style("left", (i) => offset + this.mapColorScalePos(i) + "%")
            .classed("hidden", (i) => {
            var curTickPos = (legendWidth * this.mapColorScalePos(i)) / 100;
            var visible = curTickPos - lastTickPos > tickWidthGap;
            if (visible)
                lastTickPos = curTickPos;
            return !visible;
        })
            .call((tick) => {
            tick
                .append("div")
                .attr("class", "tickLabel")
                .html((i) => "" + _print(i));
        });
    }
    /** -- */
    invertColorTheme(v = null) {
        this.invertedColorTheme = v == null ? !this.invertedColorTheme : v;
        this.updateRecordColorScale();
    }
    /** -- */
    setRecordColorTheme(v) {
        this.browser.activeColorTheme = v;
        this.updateRecordColorScale();
    }
    /** -- */
    initDOM_RecordDisplayHeader() {
        this.DOM.recordDisplayHeader = this.DOM.root
            .append("div")
            .attr("class", "recordDisplayHeader");
        // Remove record display button
        this.DOM.removeRecordPanelButton = this.DOM.recordDisplayHeader
            .append("div")
            .attr("class", "removeRecordPanelButton far fa-times-circle")
            .tooltip(i18n.RemoveRecordPanel, { placement: "bottom" })
            .on("click", () => __awaiter(this, void 0, void 0, function* () { return yield this.browser.recordChartType.set("none"); }));
        // Expand record display button
        this.DOM.recordDisplayHeader
            .append("div")
            .attr("class", "buttonRecordViewExpand far fa-expand-alt")
            .tooltip(i18n.OpenSummary, { placement: "bottom" })
            .on("click", () => this.collapseRecordViewSummary(false));
        // Collapse record display button
        this.DOM.recordDisplayHeader
            .append("div")
            .attr("class", "buttonRecordViewCollapse far fa-compress-alt")
            .tooltip(i18n.CollapseSummary, { placement: "bottom" })
            .on("click", () => this.collapseRecordViewSummary(true));
        this.initDOM_GlobalTextSearch();
        // Record Name
        this.DOM.recordDisplayHeader
            .append("div")
            .attr("class", "recordName recordDisplayName")
            .html(this.browser.recordName);
        this.DOM.recordDisplayConfigButton = this.DOM.recordDisplayHeader
            .append("span")
            .attr("class", "recordDisplayConfigButton fal fa-cog")
            .tooltip(i18n.Configure)
            .on("click", (event) => {
            this.recordConfigPanel.showAtPos(event.target.offsetLeft + 25, event.target.offsetTop + 25);
        });
        // Change record display view
        var x = this.DOM.recordDisplayHeader
            .append("span")
            .attr("class", "recordDisplay_ViewGroup");
        x.selectAll("span.fa")
            .data([
            {
                v: "list",
                t: i18n.ListButton,
                i: "<span class='far fa-list-ul'></span>",
            },
            {
                v: "map",
                t: i18n.MapButton,
                i: "<span class='fal fa-globe'></span>",
            },
            {
                v: "node",
                t: i18n.NodeButton,
                i: "<span class='far fa-share-alt'></span>",
            },
            {
                v: "timeseries",
                t: i18n.TimeSeriesButton,
                i: "<span class='far fa-chart-line'></span>",
            },
            {
                v: "scatter",
                t: i18n.ScatterButton,
                i: "<span class='far fa-chart-scatter'></span>",
            },
        ])
            .enter()
            .append("span")
            .attr("class", (d) => "recordDisplay_ViewAs_" + d.v + " disabled")
            .tooltip((_) => i18n.RecordViewTypeTooltip(_.t), { placement: "bottom" })
            .on("click", (_event, d) => __awaiter(this, void 0, void 0, function* () { return yield this.browser.recordChartType.set(d.v); }))
            .html((d) => d.i + "<span class='ViewTitle'>" + d.t + "</span>");
    }
    /** -- */
    initDOM_GlobalTextSearch() {
        this.DOM.recordTextSearch = this.DOM.recordDisplayHeader
            .append("span")
            .attr("class", "recordTextSearch textSearchBox");
        this.DOM.recordTextSearch.append("span").attr("class", "far fa-search");
        this.DOM.recordTextSearch
            .append("span")
            .attr("class", "fa fa-times-circle")
            .tooltip(i18n.RemoveFilter)
            .on("click", () => this.textFilter.clearFilter());
        this.DOM.recordTextSearch
            .append("input")
            .attr("type", "text")
            .attr("class", "textSearchInput")
            .tooltip(i18n.TextSearchForRecords)
            .on("keydown", (event) => event.stopPropagation())
            .on("keypress", (event) => event.stopPropagation())
            .on("keyup", (event) => {
            var dom = event.currentTarget;
            if (event.key === "Enter") {
                dom.tippy.hide();
                if (dom.timer)
                    clearTimeout(dom.timer);
                dom.timer = null;
                this.textFilter.queryString = dom.value;
                if (this.textFilter.queryString === "") {
                    this.textFilter.clearFilter();
                    return;
                }
                this.browser.clearSelect_Compare();
                this.textFilter.setFiltered();
                return;
            }
            event.stopPropagation();
        });
    }
    getMaxSizeScaleRange() {
        if (this.codeBy.size === "_measure_" && this.isPointMap()) {
            return Math.max(10, Math.min(this.recordPointSize.get(), this.codeBy.geo.pointClusterRadius / 2));
        }
        else if (this.codeBy.size instanceof Attrib_Interval) {
            return this.recordPointSize.get();
        }
        throw Error("Unexpected status");
    }
    getMaxSizeDomainRange() {
        if (this.codeBy.size === "_measure_" && this.isPointMap()) {
            return (d3$3.max(this.codeBy.geo._aggrs, (_) => _.measure("Active")) || 1 // || 1: there may be no clusters
            );
        }
        else if (this.codeBy.size instanceof Attrib_Interval) {
            return this.codeBy.size.valueScale.domain()[1];
        }
        throw Error("Unexpected status");
    }
    /** -- */
    updateRecordSizeScale() {
        var _a;
        var constPointSize = Math.max(this.recordPointSize.get(), 4); // const size must be 4 or larger
        this.drawArc = d3$3
            .arc()
            .outerRadius(constPointSize) // fixed radius arc by default
            .innerRadius(0)
            .startAngle(0)
            .endAngle(2 * Math.PI);
        var getArc = (v) => this.drawArc.outerRadius(this.recordRadiusScale(v));
        if (this.codeBy.size === null) {
            // Constant size, constant shape - both are functions returning constant values
            this.recordRadiusScale = () => constPointSize;
            this.recordDrawArc = () => this.drawArc;
            //
        }
        else {
            this.recordRadiusScale = d3$3
                .scaleSqrt()
                .clamp(false)
                .range([0, this.getMaxSizeScaleRange() * 2])
                .domain([0, this.getMaxSizeDomainRange()]);
            if (this.codeBy.size === "_measure_" && this.isPointMap()) {
                // point map using measure as a size attribute
                this.recordDrawArc = (record) => getArc(record.measure_Self);
                //
            }
            else if (this.codeBy.size instanceof Attrib_Interval) {
                // point map usig regular numeric size attribute
                var m = this.codeBy.size;
                this.recordDrawArc = (record) => {
                    var v = m.template.func.call(record.data, record);
                    // in cases where point would be invisible/negligable, set very small so that it has a path
                    if (isNaN(v) || v == null || (m.isValueScale_Log && v <= 0))
                        v = 0.0001;
                    return getArc(v);
                };
            }
        }
        this.refreshSizeLegend();
        (_a = this.View) === null || _a === void 0 ? void 0 : _a.refreshRecordSizes();
    }
    /** -- */
    initDOM_CustomControls() {
        if (this.DOM.visViewControl)
            return;
        var me = this;
        var X;
        // Scale legend
        X = this.DOM.recordDisplayWrapper
            .append("span")
            .attr("class", "mapGlyphColorSetting");
        this.DOM.mapGlyphColorSetting = X;
        // Record point size
        var sizeGroup = this.DOM.mapGlyphColorSetting
            .append("div")
            .attr("class", "attribGroup sizeGroup")
            .classed("active", this.codeBy.size != null);
        // Gap
        this.DOM.mapGlyphColorSetting.append("div").attr("class", "attribGap");
        // Record color (attrib)
        this.DOM.colorCompareGroup = this.DOM.mapGlyphColorSetting
            .append("div")
            .attr("class", "colorCompareGroup attribGroup");
        // Record color (compare)
        var colorGroup = this.DOM.mapGlyphColorSetting
            .append("div")
            .attr("class", "attribGroup colorGroup")
            .classed("active", this.codeBy.color != null);
        // ****************************************************************
        // ** SIZE ********************************************************
        this.DOM.sizeControlGroup = sizeGroup
            .append("div")
            .attr("class", "sizeControlGroup attribControlGroup");
        sizeGroup
            .append("div")
            .attr("class", "dotSizes")
            .call((dom) => {
            dom
                .append("i")
                .attr("class", "dotSize dotSize-expand-alt far fa-plus")
                .tooltip(i18n.Larger, { placement: "top" })
                .on("click", () => __awaiter(this, void 0, void 0, function* () {
                yield this.recordPointSize.set(this.recordPointSize.get() * Math.sqrt(2));
            }));
            dom
                .append("i")
                .attr("class", "dotSize dotSize-compress-alt far fa-minus")
                .tooltip(i18n.Smaller, { placement: "top" })
                .on("click", () => __awaiter(this, void 0, void 0, function* () {
                yield this.recordPointSize.set(this.recordPointSize.get() / Math.sqrt(2));
            }));
        });
        this.DOM.sizeLegendGroup = sizeGroup
            .append("div")
            .attr("class", "attribLegendGroup sizeLegendGroup");
        this.DOM.sizeControlGroup
            .append("span")
            .attr("class", "header")
            .text(i18n.Size + " ");
        this.initDOM_AttribSelect("size");
        // ****************************************************************
        // ** COLOR *******************************************************
        // Control
        this.DOM.colorControlGroup = colorGroup
            .append("div")
            .attr("class", "colorControlGroup attribControlGroup");
        this.DOM.colorControlGroup
            .append("span")
            .attr("class", "header")
            .text(i18n.Color + " ");
        this.initDOM_AttribSelect("color");
        this.DOM.mapColorScaleGroup = colorGroup
            .append("div")
            .attr("class", "attribLegendGroup mapColorScaleGroup");
        // Invert color theme
        colorGroup
            .append("div")
            .attr("class", "editColorTheme fa fa-paint-brush")
            .tooltip(i18n.ChangeColorTheme, { placement: "left" })
            .on("click", (event) => {
            var addLegend = function (dom) {
                var _theme = me.browser.activeColorTheme;
                var _temp = me.browser.colorTheme[_theme];
                me.browser.colorTheme[_theme] = this.value;
                let colors = me.browser.colorTheme.getDiscrete(9);
                me.browser.colorTheme[_theme] = _temp;
                if (me.invertedColorTheme)
                    colors = colors.reverse();
                d3$3.select(dom)
                    .append("div")
                    .attr("class", "colorLegend")
                    .selectAll(".colorLegendBox")
                    .data(colors)
                    .enter()
                    .append("span")
                    .attr("class", "colorLegendBox")
                    .style("background-color", (_) => _);
            };
            Modal.popupMenu(event, {
                name: "Color Theme",
                items: [
                    {
                        id: "colorThemeInverse",
                        name: "Invert",
                        iconClass: "far fa-adjust",
                        active: this.invertedColorTheme,
                        do: () => this.invertColorTheme(),
                    },
                    {
                        id: "colorScaleScale",
                        name: "BinScale",
                        iconClass: "far fa-arrows-h",
                        when: () => this.codeBy.color &&
                            this.codeBy.color instanceof Attrib_Numeric &&
                            this.codeBy.color.supportsLogScale(),
                        do: (_, opt) => __awaiter(this, void 0, void 0, function* () {
                            var attrib = this.codeBy.color; // checked by when
                            if (!attrib)
                                return;
                            if (attrib.timeseriesParent) {
                                yield attrib.timeseriesParent.valueScaleType.set(opt);
                            }
                            else {
                                yield attrib.valueScaleType.set(opt);
                            }
                        }),
                        options: [
                            {
                                name: "Linear",
                                value: "linear",
                                active: this.codeBy.color instanceof Attrib_Numeric &&
                                    this.codeBy.color.isValueScale_Linear,
                            },
                            {
                                name: "Log",
                                value: "log",
                                active: this.codeBy.color instanceof Attrib_Numeric &&
                                    !this.codeBy.color.isValueScale_Linear,
                            },
                        ],
                    },
                    {
                        id: "colorThemeSwitch",
                        name: "Switch (Seq. ↔ Div.)",
                        iconClass: "far fa-exchange",
                        do: () => this.setRecordColorTheme(this.browser.activeColorTheme === "sequential"
                            ? "diverging"
                            : "sequential"),
                    },
                    {
                        id: "colorThemeSequential",
                        name: "Sequential",
                        iconClass: "far fa-long-arrow-right",
                        do: (_, opt) => {
                            this.browser.colorTheme.sequential = opt;
                            this.setRecordColorTheme("sequential");
                        },
                        // todo: highlight the active one
                        options: [
                            { name: "Greys", value: "Greys", onName: addLegend },
                            { name: "Blues", value: "Blues", onName: addLegend },
                            { name: "Green-Blue", value: "GnBu", onName: addLegend },
                            {
                                name: "Yellow-Green-Blue",
                                value: "YlGnBu",
                                onName: addLegend,
                            },
                            { name: "Greens", value: "Greens", onName: addLegend },
                            { name: "Yellow-Green", value: "YlGn", onName: addLegend },
                            { name: "Blue-Green", value: "BuGn", onName: addLegend },
                            {
                                name: "Purple-Blue-Green",
                                value: "PuBuGn",
                                onName: addLegend,
                            },
                            { name: "Purple-Blue", value: "PuBu", onName: addLegend },
                            { name: "Purples", value: "Purples", onName: addLegend },
                            { name: "Blue-Purple", value: "BuPu", onName: addLegend },
                            { name: "Purple-Red", value: "PuRd", onName: addLegend },
                            { name: "Oranges", value: "Oranges", onName: addLegend },
                            { name: "Orange-Red", value: "OrRd", onName: addLegend },
                            {
                                name: "Yellow-Orange-Red",
                                value: "YlOrRd",
                                onName: addLegend,
                            },
                            {
                                name: "Yellow-Orange-Brown",
                                value: "YlOrBr",
                                onName: addLegend,
                            },
                            { name: "Inferno", value: "Inferno", onName: addLegend },
                            { name: "Magma", value: "Magma", onName: addLegend },
                            { name: "Plasma", value: "Plasma", onName: addLegend },
                            { name: "Cividis", value: "Cividis", onName: addLegend },
                            { name: "Viridis", value: "Viridis", onName: addLegend },
                            { name: "Warm", value: "Warm", onName: addLegend },
                            { name: "Cool", value: "Cool", onName: addLegend }, // no discrete version
                        ],
                    },
                    {
                        id: "colorThemeDiverging",
                        name: "Diverging",
                        iconClass: "far fa-arrows-h",
                        do: (_, opt) => {
                            this.browser.colorTheme.diverging = opt;
                            this.setRecordColorTheme("diverging");
                        },
                        options: [
                            { name: "Spectral", value: "Spectral", onName: addLegend },
                            { name: "Brown-Green", value: "BrBG", onName: addLegend },
                            { name: "Purple-Green", value: "PRGn", onName: addLegend },
                            {
                                name: "Pink-Yellow-Green",
                                value: "PiYG",
                                onName: addLegend,
                            },
                            { name: "Purple-Orange", value: "PuOr", onName: addLegend },
                            { name: "Red-Blue", value: "RdBu", onName: addLegend },
                            { name: "Red-Gray", value: "RdGy", onName: addLegend },
                            {
                                name: "Red-Yellow-Blue",
                                value: "RdYlBu",
                                onName: addLegend,
                            },
                            {
                                name: "Red-Yellow-Green",
                                value: "RdYlGn",
                                onName: addLegend,
                            },
                        ],
                    },
                ],
            }, null, { placement: "top" });
        });
        // Scale
        this.DOM.mapColorHighlightedValue = this.DOM.mapColorScaleGroup
            .append("div")
            .attr("class", "mapColorHighlightedValue fa fa-caret-down");
        this.DOM.mapColorScaleBins = this.DOM.mapColorScaleGroup
            .append("div")
            .attr("class", "mapColorScaleBins");
        this.DOM.mapColorScaleLabels = this.DOM.mapColorScaleGroup
            .append("div")
            .attr("class", "mapColorScaleLabels");
        // play/pause buttons
        var x = this.DOM.timeAnimation
            .append("span")
            .attr("class", "detailPlay attribDetailPlay");
        x.append("i")
            .attr("class", "fa fa-play-circle")
            .tooltip(i18n.AutoPlay)
            .on("click", (event) => this.startTimeseriesAnimation(event.shiftKey ? 5 : 1))
            .on("mouseover", () => {
            if (this.View instanceof RecordView_Timeseries) {
                this.View.timeseriesWiden();
            }
        })
            .on("mouseout", () => {
            if (this.View instanceof RecordView_Timeseries) {
                this.View.timeseriesWidenOff();
            }
        });
        x.append("i")
            .attr("class", "fa fa-pause-circle")
            .tooltip(i18n.StopAutoPlay)
            .on("click", () => this.stopTimeseriesAnimation());
        this.DOM.timeAnimation
            .append("div")
            .attr("class", "timeKeyStep timeKeyPrev")
            .tooltip(i18n.Previous)
            .on("click", () => this.currentTimeKey.set(this.timeKeys[this.currentTimeKey.get()._index - 1]))
            .append("span")
            .attr("class", "fa fa-caret-left");
        this.DOM.timeAnimation
            .append("select")
            .attr("class", "timeKeySelect")
            .on("change", (event) => __awaiter(this, void 0, void 0, function* () { return yield this.currentTimeKey.set(event.currentTarget.selectedOptions[0].__data__); }));
        this.DOM.timeAnimation
            .append("div")
            .attr("class", "timeKeyStep timeKeyNext")
            .tooltip(i18n.Next)
            .on("click", () => __awaiter(this, void 0, void 0, function* () { return yield this.currentTimeKey.set(this.timeKeys[this.currentTimeKey.get()._index + 1]); }))
            .append("span")
            .attr("class", "fa fa-caret-right");
        this.DOM.timeAnimation
            .append("div")
            .attr("class", "timeKeyRange")
            .call((timeKeyRange) => {
            var _a, _b;
            timeKeyRange.append("span").attr("class", "rangeTick-min").text("min");
            // SINGLE-KEY SLIDER (MAP, SCATTERPLOT, LIST)
            var attribDetailRange = timeKeyRange
                .append("div")
                .attr("class", "attribDetailRange");
            noUiSlider.create(attribDetailRange.node(), {
                connect: true,
                step: 1,
                behaviour: "tap-drag",
                range: {
                    min: 0,
                    max: this.hasTimeKey ? this.timeKeys.length - 1 : 100,
                },
                start: (_b = (_a = this.currentTimeKey.get()) === null || _a === void 0 ? void 0 : _a._index) !== null && _b !== void 0 ? _b : 0,
            });
            attribDetailRange.append("span").attr("class", "rangeTick-cur");
            this.timeKeySlider = attribDetailRange.node().noUiSlider;
            var _update_1 = (v) => __awaiter(this, void 0, void 0, function* () {
                if (this.timeKeySlider_PauseUpdate)
                    return;
                var _node = this.DOM.timeAnimation
                    .selectAll(".timeKeySelect > option")
                    .nodes()[Math.round(1 * v)];
                if (_node) {
                    this.timeKeySlider_PauseUpdate = true;
                    yield this.currentTimeKey.set(_node.__data__);
                    this.timeKeySlider_PauseUpdate = false;
                }
            });
            this.timeKeySlider.on("set", _update_1);
            // DOUBLE-KEY SLIDER (TIMESERIES)
            this.DOM.timeseriesRange = timeKeyRange
                .append("div")
                .attr("class", "timeseriesRange");
            timeKeyRange.append("span").attr("class", "rangeTick-max");
        });
        this.DOM.timeAnimationClearRange = this.DOM.timeAnimation
            .append("span")
            .attr("class", "clearRange fa fa-times")
            .tooltip(i18n.Reset);
        // handled added in TimeSeries view
        this.currentTimeKey.refresh();
        // View control...
        this.DOM.visViewControl = this.DOM.recordDisplayWrapper
            .append("span")
            .attr("class", "visViewControl");
        // **************************************************
        // ZOOM IN / OUT / RESET
        this.DOM.visViewControl
            .append("span")
            .attr("class", "ChartControlGroup ViewControlGroup")
            .call((_) => {
            _.append("span")
                .attr("class", "ChartControlGroupTitle")
                .html(i18n.Zoom);
            _.append("span")
                .attr("class", "visViewControlButton far fa-plus")
                .tooltip(i18n.ZoomIn)
                .on("click", () => this.View.zoomIn());
            _.append("span")
                .attr("class", "visViewControlButton far fa-minus")
                .tooltip(i18n.ZoomOut)
                .on("click", () => this.View.zoomOut());
            _.append("span")
                .attr("class", "visViewControlButton far fa-expand-arrows-alt")
                .tooltip(i18n.ZoomToFit)
                .on("click", () => this.View.zoomToFit());
        });
        // Maps only
        this.DOM.visViewControl
            .append("div")
            .attr("class", "visViewControlButton mapView-UnmatchedData")
            .tooltip(i18n.MissingLocations)
            .text("∅")
            .on("click", () => {
            Modal.alert("The following records do not appear on the map.<br><br>" +
                this.codeBy.geo.noValueAggr.records.map((_) => _._id).join(", ") +
                (this.codeBy.geo.geoType !== "Point"
                    ? "<br><br>" +
                        "<span style='font-size: 0.9em; color: gray; font-weight: 300'>" +
                        "Please see the list of standard region names " +
                        "<a style='color: gray; text-decoration: underline;' href='https://docs.google.com/spreadsheets/d/1DKNXwsJy6_Mdy3ofwbBIZeBGrxSItYOJXNZgLyu0IM4' target='_blank'>here</a>.<br>" +
                        "If the place names above are misspelled, please update your data source.<span>"
                    : ""));
        });
    }
    /** -- */
    refreshTimeKeys() {
        this.timeKeys = [];
        ["sort", "scatterX", "scatterY", "color", "size"].forEach((_type) => {
            var targetAttrib = this.codeBy[_type];
            if (targetAttrib instanceof Attrib_Numeric &&
                targetAttrib.hasTimeSeriesParent()) {
                // make a copy of timeKeys of the timeseries summary
                var timeKeyOptions = Array.from(targetAttrib.timeseriesParent.timeKeys);
                // finds the shared subset of keys across all timeseries variables
                if (this.timeKeys.length === 0) {
                    this.timeKeys = timeKeyOptions;
                }
                else {
                    this.timeKeys = this.timeKeys.filter((k) => timeKeyOptions.find((_) => _._time_src === k._time_src));
                }
            }
        });
        // From 0 (oldest) to last (newest)
        this.timeKeys = this.timeKeys.sort((a, b) => a._time.getTime() - b._time.getTime());
        // re-assign index numbers
        this.timeKeys.forEach((key, i) => {
            key._index = i;
            delete key._histogram; // not needed - does not apply
        });
        this.currentTimeKey.refresh();
    }
    /** -- */
    get hasTimeKey() {
        return this.timeKeys.length > 1; // must be at least two - single time-key has no control
    }
    filterStatusUpdated(attrib) {
        var _a;
        if (attrib instanceof Attrib_Numeric) {
            if (this.viewRecAs === "scatter" &&
                (this.codeBy.scatterX === attrib || this.codeBy.scatterY === attrib)) {
                (_a = this.View) === null || _a === void 0 ? void 0 : _a.refreshQueryBox_Filter(null);
            }
            if (attrib.timeseriesParent === this.codeBy.timeSeries &&
                this.View instanceof RecordView_Timeseries) {
                this.View.refreshFilterRanges();
            }
        }
    }
    /** -- */
    collapseRecordViewSummary(collapsed) {
        this.collapsed = collapsed;
        this.DOM.root.classed("collapsed", this.collapsed);
        if (this.browser.finalized)
            this.browser.updateLayout_Height();
    }
    /** -- */
    refreshViz_Compare_All() {
        this.DOM.root
            .selectAll("[class*='spatialQueryBox_Compare']")
            .classed("active", (d) => this.browser.vizActive(d) && this.browser.selectedAggrs[d].bounds);
    }
    /** -- */
    refreshViewAsOptions() {
        var activeCount = 0;
        ["list", "map", "timeseries", "scatter"].forEach((viewType) => {
            var t = this.browser.recordChartType.itemOptions.find((_) => _.value === viewType);
            var disabled = !t.activeWhen || !t.activeWhen();
            activeCount += !disabled ? 1 : 0;
            this.DOM.recordDisplayHeader
                .select(".recordDisplay_ViewAs_" + viewType)
                .classed("disabled", disabled)
                .classed("active", viewType.toLowerCase() == this.viewRecAs);
        });
        this.DOM.recordDisplayHeader
            .select(".recordDisplay_ViewGroup")
            .classed("disabled", activeCount <= 1);
    }
    /** -- */
    refreshAttribOptions(_type) {
        if (!this.attribDropdowns[_type])
            return;
        this.attribDropdowns[_type].refresh();
    }
    /** -- */
    initDOM_AttribSelect(_type) {
        this.attribDropdowns[_type] = new AttribDropdown(_type, this);
        this.refreshAttribOptions(_type);
    }
    /** -- */
    getAttribOptions_UI(_type) {
        var opts = this.browser.attribs.filter((attrib) => attrib.supportsRecordEncoding(_type) && !attrib.hasTimeSeriesParent());
        // scatterX / scatterY options cannot include the same active attribute
        if (["scatterX", "scatterY"].includes(_type)) {
            var other = _type === "scatterX" ? this.codeBy.scatterY : this.codeBy.scatterX;
            if (other) {
                if (other.hasTimeSeriesParent())
                    other = other.parent;
                opts = opts.filter((s) => s.attribID != other.attribID);
            }
        }
        // generate new attribute if there's no sortable attribute
        if (_type === "sort" && opts.length === 0) {
            var newAttrib;
            if (this.browser.idSummaryName === "id") {
                newAttrib = this.browser.createAttrib("Sort by id", function () {
                    return 1 * this.id;
                });
            }
            else {
                newAttrib = this.browser.createAttrib("Sort (random)", function () {
                    return Math.random();
                });
            }
            newAttrib._metricFuncs = [];
            newAttrib.initializeAggregates();
            // calls the function again, but this time we have a numeric summary
            return this.getAttribOptions_UI("sort");
        }
        opts.sort((s1, s2) => Util.sortFunc_List_String(s1.attribName, s2.attribName));
        if (["color", "size"].includes(_type)) {
            opts.unshift(null); // The first option is no color/size attribute.
        }
        return opts;
    }
    /** -- */
    startTimeseriesAnimation(stepSize = 1) {
        var _a;
        if (this.timeseriesAnimInterval) {
            this.stopTimeseriesAnimation();
        }
        if ((_a = this.View) === null || _a === void 0 ? void 0 : _a.stepTimeAnimation(stepSize)) {
            this.DOM.root.classed("animatingTime", true);
        }
    }
    /** -- */
    stopTimeseriesAnimation() {
        var _a;
        this.DOM.root.classed("animatingTime", false);
        (_a = this.View) === null || _a === void 0 ? void 0 : _a.stopTimeAnimation();
        this.View.refreshLabelOverlaps();
        if (!this.timeseriesAnimInterval)
            return;
        window.clearInterval(this.timeseriesAnimInterval);
        this.timeseriesAnimInterval = 0;
    }
    isPointMap() {
        var _a;
        return this.viewRecAs === "map" && ((_a = this.codeBy.geo) === null || _a === void 0 ? void 0 : _a.geoType) === "Point";
    }
    /** -- */
    hasAggregates() {
        return (this.isPointMap() &&
            this.DOM.clusterGlyphs &&
            this.codeBy.geo.pointClusterRadius > 0 &&
            this.codeBy.geo._aggrs.length > 0);
    }
    /** -- */
    setAttrib(_type, _attrib, stopAnimation = false) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            let attrib = null;
            // if integer, index by integer among potential options
            if (typeof _attrib === "number") {
                attrib = this.getAttribOptions_UI(_type)[_attrib];
                //
            }
            else if (typeof _attrib === "function") {
                attrib = this.browser.createAttrib("_Records", _attrib, "categorical"); // create from function
                //
            }
            else if (typeof _attrib === "string") {
                if (_attrib !== "_measure_") {
                    attrib = this.browser.createAttrib(_attrib); // create from string
                }
                //
            }
            else if (_attrib) {
                attrib = _attrib;
            }
            if (["sort", "scatterX", "scatterY", "size", "color"].includes(_type)) {
                var timeSrc;
                if (attrib instanceof Attrib_Numeric && attrib.timeseriesParent) {
                    timeSrc = attrib.timeKey._time_src;
                    attrib = attrib.timeseriesParent;
                }
                if (attrib instanceof Attrib_Timeseries) {
                    timeSrc = ((_a = this.currentTimeKey.get()) === null || _a === void 0 ? void 0 : _a._time_src) || timeSrc;
                    attrib = attrib.getTimepointSummary(attrib.timeKeys.find((x) => x._time_src === timeSrc) || // current time-key
                        attrib.timeKeys[attrib.timeKeys.length - 1] // most recent time-key
                    );
                }
            }
            // if (attrib instanceof Attrib) {
            //   if (!attrib.supportsRecordEncoding(_type)) return;
            // }
            var prevTimeSeriesParent = null;
            if (_type === "text") {
                if (!(attrib instanceof Attrib_Categorical))
                    return;
                this.codeBy.text = attrib;
            }
            else if (_type === "textBrief") {
                if (!(attrib instanceof Attrib_Categorical))
                    return;
                this.codeBy.textBrief = attrib;
            }
            else if (_type === "sort") {
                if (!(attrib instanceof Attrib_Interval))
                    return;
                if (this.codeBy.sort instanceof Attrib_Numeric)
                    prevTimeSeriesParent = this.codeBy.sort.timeseriesParent;
                this.codeBy.sort = attrib;
            }
            else if (_type === "scatterX") {
                if (!(attrib instanceof Attrib_Numeric))
                    return;
                if (this.codeBy.scatterX)
                    prevTimeSeriesParent = this.codeBy.scatterX.timeseriesParent;
                this.codeBy.scatterX = attrib;
            }
            else if (_type === "scatterY") {
                if (!(attrib instanceof Attrib_Numeric))
                    return;
                if (this.codeBy.scatterY) {
                    prevTimeSeriesParent = this.codeBy.scatterY.timeseriesParent;
                }
                this.codeBy.scatterY = attrib;
            }
            else if (_type === "size") {
                prevTimeSeriesParent = this.codeBy.size instanceof Attrib_Numeric
                    ? this.codeBy.size.timeseriesParent
                    : null;
                if (_attrib === "_measure_") {
                    this.codeBy.size = _attrib;
                }
                else if (attrib instanceof Attrib_Numeric) {
                    this.codeBy.size = attrib;
                }
                else if (_attrib === null) {
                    this.codeBy.size = null;
                }
                else {
                    return;
                }
            }
            else if (_type === "color") {
                prevTimeSeriesParent = this.codeBy.color instanceof Attrib_Numeric
                    ? this.codeBy.color.timeseriesParent
                    : null;
                if (_attrib === "_measure_") {
                    this.codeBy.color = _attrib;
                }
                else if (attrib instanceof Attrib_Numeric) {
                    this.codeBy.color = attrib;
                }
                else if (_attrib === null) {
                    this.codeBy.color = null;
                }
                else {
                    return;
                }
            }
            else if (_type === "timeSeries") {
                if (!(attrib instanceof Attrib_Timeseries))
                    return;
                this.codeBy.timeSeries = attrib;
            }
            else if (_type === "geo") {
                if (!(attrib instanceof Attrib_RecordGeo))
                    return;
                this.codeBy.geo = attrib;
                yield this.codeBy.geo.loadGeo();
            }
            else {
                return;
            }
            if (stopAnimation) {
                this.stopTimeseriesAnimation(); // hard-stop any existing animation
            }
            var timeKeysChange = false;
            if (_type !== "timeSeries") {
                if (attrib instanceof Attrib_Numeric &&
                    attrib.timeseriesParent &&
                    prevTimeSeriesParent !== attrib.timeseriesParent) {
                    timeKeysChange = true;
                }
            }
            if (timeKeysChange) {
                this.refreshTimeKeys();
                if (attrib instanceof Attrib_Numeric)
                    yield this.currentTimeKey.set(attrib.timeKey);
            }
            if (!this.DOM.root)
                return;
            if (attrib instanceof Attrib) {
                attrib.initializeAggregates();
            }
            if (_type === "text") {
                this.DOM.recordTextSearch
                    .attr("active", true)
                    .select("input")
                    .attr("placeholder", (_b = this.textAttrib_Brief) === null || _b === void 0 ? void 0 : _b.attribName);
                // Call the onDOM function for all the records that have been inserted to the page
                if (this.config.onDOM) {
                    this.DOM.kshfRecords.each((record) => {
                        this.config.onDOM.call(record.data, record);
                    });
                }
            }
            else if (_type === "textBrief") {
                this.DOM.recordTextSearch
                    .attr("active", true)
                    .select("input")
                    .attr("placeholder", this.textAttrib_Brief.attribName);
            }
            else if (_type === "color") {
                this.updateRecordColorScale();
            }
            else if (_type === "size") {
                if (this.codeBy.size instanceof Attrib_Numeric) {
                    if (this.viewRecAs === "scatter" ||
                        (this.viewRecAs === "map" && ((_c = this.codeBy.geo) === null || _c === void 0 ? void 0 : _c.geoType) === "Point")) {
                        var s_f = this.codeBy.size.template.func;
                        var s_log = this.codeBy.size.isValueScale_Log;
                        var sortVal = (r) => {
                            var v = s_f.call(r.data, r);
                            return isNaN(v) || v == null || (s_log && v <= 0) ? -1 : v;
                        };
                        // need to apply delay to sorting (z-order) because we want the elements to animate to first
                        if (this.sortRecordDomTimer)
                            clearTimeout(this.sortRecordDomTimer);
                        this.sortRecordDomTimer = window.setTimeout(() => {
                            this.DOM.kshfRecords = this.DOM.recordGroup
                                .selectAll(".kshfRecord")
                                .sort((r_a, r_b) => sortVal(r_b) - sortVal(r_a));
                            this.View.refreshLabelOverlaps();
                        }, 1000);
                    }
                }
                this.updateRecordSizeScale();
                this.refreshSizeLegend();
            }
            yield ((_d = this.View) === null || _d === void 0 ? void 0 : _d.finishSetAttrib(_type));
            this.refreshAttribOptions(_type);
        });
    }
    // ********************************************************************
    // MAPPING
    // ********************************************************************
    /** -- */
    getMaxPointSize() {
        if (!(this.codeBy.size instanceof Attrib_Numeric)) {
            return 1; // only 1 point max
        }
        return this.codeBy.size.timeseriesParent // use timeseries parents domain...
            ? d3$3.max(this.codeBy.size.timeseriesParent.timeSeriesScale_Value.domain())
            : this.codeBy.size.rangeActive[1];
    }
    /** -- */
    sanitizeTicks(ticks, attrib, numTicks) {
        if (ticks.domain) {
            var _scale = ticks.copy().nice(numTicks);
            ticks = _scale.ticks(numTicks);
            // d3 error ? make sure the ticks cover the full attrib Range
            var domain = _scale.domain();
            if (ticks[0] > domain[0])
                ticks.unshift(domain[0]);
            if (ticks[ticks.length - 1] < domain[1])
                ticks.push([domain[1]]);
        }
        // when ticks must be integer values, round them
        if (attrib === "_measure_" || !attrib.hasFloat) {
            ticks = ticks.map((v) => Math.round(v));
        }
        // avoid repeated tick values
        return ticks.filter((_, i) => i == 0 || _ !== ticks[i - 1]);
    }
    /** -- */
    refreshSizeLegend() {
        if (this.DOM.root == null)
            return;
        this.DOM.root.classed("usesSizeAttrib", hasSizeLegend);
        var hasSizeLegend = this.codeBy.size != null &&
            (this.viewRecAs === "scatter" ||
                (this.viewRecAs === "map" && this.codeBy.geo.geoType === "Point"));
        if (!hasSizeLegend)
            return;
        if (!this.DOM.sizeLegendGroup)
            return;
        var maxValue;
        if (this.viewRecAs === "map") {
            maxValue = this.recordRadiusScale.domain()[1];
            if (isNaN(maxValue)) {
                this.DOM.root.classed("usesSizeAttrib", false);
                return;
            }
        }
        else {
            maxValue = this.getMaxPointSize();
        }
        var markRatios = [0.2, 0.4, 0.6, 0.8, 1];
        if (this.recordPointSize.get() > 25) {
            markRatios = [0.1, 0.4, 0.7, 1];
        }
        var ticks = this.sanitizeTicks(markRatios.map((v) => maxValue * v * v), this.codeBy.size, 10);
        ticks = ticks.filter((_) => _ !== 0);
        var printLabel;
        if (this.codeBy.size instanceof Attrib_Numeric) {
            let y = this.codeBy.size;
            printLabel = (v) => y.getFormattedValue(v);
        }
        else {
            printLabel = d3$3.format("~s");
        }
        maxValue = ticks[ticks.length - 1];
        ticks = ticks.map((_) => ({ size: 2 * this.recordRadiusScale(_), val: _ })); // size
        this.DOM.sizeLegendGroup.selectAll("div").remove();
        this.DOM.sizeLegendGroup
            .selectAll("div")
            .data(ticks)
            .join((enter) => enter
            .append("div")
            .attr("class", "sizeGlyph")
            .call((sizeGlyphs) => sizeGlyphs
            .append("span")
            .attr("class", "glyphWrapper")
            .append("span")
            .attr("class", "theGlyph")
            .style("width", (d) => d.size + "px")
            .style("height", (d) => d.size + "px"))
            .call((sizeGlyphs) => sizeGlyphs
            .append("span")
            .attr("class", "glyphLabel")
            .html((_) => printLabel(_.val))));
    }
    /** -- */
    linkedTimeKey() {
        if (this.codeBy.scatterY == null)
            return false;
        if (this.codeBy.scatterX == null)
            return false;
        var yTs = this.codeBy.scatterY.timeseriesParent;
        var xTs = this.codeBy.scatterX.timeseriesParent;
        if (!xTs || !yTs)
            return false;
        return (yTs.attribName !== xTs.attribName &&
            yTs.timeKeys.length === xTs.timeKeys.length &&
            this.codeBy.scatterY.timeKey !== this.codeBy.scatterX.timeKey);
    }
    /** -- */
    flipSelected(f, cT) {
        if (!cT)
            cT = this.browser.Compare_Highlight;
        this.DOM.kshfRecords.each((record) => record.flipSelected(f, cT));
    }
    /** -- */
    refreshRecordVis() {
        if (!this.DOM.recordGroup)
            return;
        if (this.skipRefreshRecordVis)
            return;
        if (this.kshfRecords_Type !== this.viewRecAs)
            return;
        if (!this.View)
            return;
        this.View.refreshRecordVis();
    }
    /** -- */
    isSummaryUsedInRecordChart(summary) {
        return {
            list: ["sort"],
            map: ["color", "size"],
            scatter: ["scatterX", "scatterY", "color", "size"],
            timeseries: ["timeSeries"],
            none: [],
        }[this.viewRecAs].some((t) => {
            var _ = this[t + "Attrib"];
            return _ && (summary === _ || summary === _.parentSummary);
        });
    }
    /** -- */
    refreshAttribScaleType(attrib) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.codeBy.color instanceof Attrib) {
                if (this.codeBy.color === attrib ||
                    this.codeBy.color.timeseriesParent === attrib) {
                    this.updateRecordColorScale();
                }
            }
            yield ((_a = this.View) === null || _a === void 0 ? void 0 : _a.refreshAttribScaleType(attrib));
        });
    }
    /** Instead of overall maximum, we can also get a quantile value */
    getMaxMeasureValue(quantile = null) {
        // maximum of records that are not in a special cluster - using measure_Self values
        var _list = this.browser.records.reduce((accum, record) => {
            if (record.isIncluded && !record._view.inCluster && record.measure_Self)
                accum.push(record.measure_Self);
            return accum;
        }, []);
        // add maximum active of all the clisters
        if (this.codeBy.geo) {
            _list = this.codeBy.geo._aggrs.reduce((accum, aggr) => {
                accum.push(aggr.measure("Active"));
                return accum;
            }, _list);
        }
        _list.sort((a, b) => b - a);
        if (quantile)
            return d3$3.quantile(_list, quantile);
        return _list[0];
    }
    get measureSummary() {
        return this.browser.measureSummary.get();
    }
    updateRecordColorScale() {
        if (!this.codeBy.color) {
            this.recordColorScale = null;
            this.recordColorScaleTicks = null;
            this.recordColorStepTicks = null;
            this.refreshColorLegend();
            return;
        }
        var c, domain;
        if (this.codeBy.color === "_measure_") {
            domain = [1, this.getMaxMeasureValue()];
            c = this.measureSummary;
        }
        else {
            domain = this.codeBy.color.valueScale.domain();
            c = this.codeBy.color;
        }
        const _colorLegendScale = Util.getD3Scale(c === null || c === void 0 ? void 0 : c.isValueScale_Log).domain(domain);
        var numTicks = 10;
        while (true) {
            this.recordColorScaleTicks = this.sanitizeTicks(_colorLegendScale, c !== null && c !== void 0 ? c : "_measure_", numTicks);
            if (this.recordColorScaleTicks.length <= 10)
                break;
            numTicks--;
        }
        this.recordColorStepTicks = false;
        if ((!c || !c.hasFloat) &&
            Util.isStepTicks(this.recordColorScaleTicks) &&
            this.recordColorScaleTicks.length < 10) {
            this.recordColorStepTicks = true;
            this.recordColorScaleTicks.push(this.recordColorScaleTicks[this.recordColorScaleTicks.length - 1] + 1);
        }
        // How many number of bins are we going to support?
        // Options are from 3 to 9!
        var numBins = Math.max(Math.min(this.recordColorScaleTicks.length - 1, 9), 1);
        // from quantized scale to discrete colors
        var colors = this.browser.colorTheme.getDiscrete(numBins);
        if (this.invertedColorTheme)
            colors.reverse();
        // replicates first and last colors to match the ticks
        // needed because we are using threshold scale, which also considers below/above the scale limits
        // using slightl different colors so invertExtent would function well
        colors = [d3$3.hsl(colors[0]).brighter(0.1).formatHex()]
            .concat(colors)
            .concat(d3$3
            .hsl([colors[colors.length - 1]])
            .darker(0.1)
            .formatHex());
        this.recordColorScale = d3$3
            .scaleThreshold()
            .domain(this.recordColorScaleTicks)
            .range(colors);
        this.refreshColorLegend();
    }
    /** -- */
    onRecordMouseOver(record) {
        record.highlightRecord();
        this.setDimmed(true);
        this.View.onRecordMouseOver(record);
        // manage color mapping here. can apply to map / scatterplot
        if (this.codeBy.color &&
            (this.viewRecAs === "map" || this.viewRecAs === "scatter")) {
            var v;
            if (this.codeBy.color === "_measure_") {
                v = record.measure_Self;
            }
            else {
                v = this.codeBy.color.getRecordValue(record);
            }
            // Set opacity, and position
            var offset = 0;
            if (this.recordColorStepTicks) {
                offset = 50 / (this.recordColorScaleTicks.length - 1);
            }
            this.DOM.mapColorHighlightedValue
                .style("opacity", v === null ? null : 1)
                .style("left", offset + this.mapColorScalePos(v) + "%");
        }
    }
    /** -- */
    onRecordMouseLeave(record) {
        this.setDimmed(false);
        if (!record)
            return;
        record.unhighlightRecord();
        this.View.onRecordMouseLeave(record);
        if (this.codeBy.color &&
            (this.viewRecAs === "map" || this.viewRecAs === "scatter")) {
            this.DOM.mapColorHighlightedValue.style("opacity", null);
        }
    }
    /** -- */
    refreshTextAttrib() { }
    getRecordTitle(record) {
        var recordName = `<span class='mapItemName'>${this.textAttrib_Brief.renderRecordValue(record)}</span>`;
        var catColorText = "";
        if (this.browser.comparedAttrib) {
            let a = this.browser.comparedAttrib;
            let compare_Color = "Active";
            Base.Compare_List.forEach((cX) => {
                if (record.isSelected(cX))
                    compare_Color = cX;
            });
            catColorText = `<div class='recordColorInfo'>
        <span class='mapTooltipLabel'>${a.attribName}</span>
        <div class='mapTooltipValue'><span class='colorBox bg_${compare_Color}'></span>${a.getRecordValue(record)}</div>
        </div>`;
        }
        if (!this.codeBy.color)
            return recordName + catColorText;
        var a = this.codeBy.color;
        if (a === "_measure_" || !a.hasTimeSeriesParent()) {
            var _value, _label;
            if (a === "_measure_") {
                _label = i18n.measureText(this.browser);
                _value = record.measure_Self;
            }
            else {
                _label = a.attribName;
                _value = a.getFormattedValue(a.template.func.call(record.data, record));
            }
            // Just a single value / not timeseries
            return (recordName +
                catColorText +
                "<div class='recordColorInfo'>" +
                `<span class='mapTooltipLabel'>${_label}</span>: ` +
                `<span class='mapTooltipValue'>${_value}</span>` +
                "</div>");
        }
        var a2 = a;
        var activeVal = a.template.func.call(record.data, record);
        // Timeseries popup
        var ts = a.timeseriesParent;
        var timeseriesData = ts.getRecordValue(record);
        var chart_width = 150;
        var chart_height = 40;
        // converts the object into simple array
        var tsd = timeseriesData._timeseries_;
        if (tsd.length === 0) {
            // Just a single value / not timeseries
            return (recordName +
                catColorText +
                "<div class='recordColorInfo'> - " +
                `<span class='timeseriesName blockName'>${ts.attribNameHTML}</span>` +
                "</div>");
        }
        // filter out the invalid values from beginning and end
        while (tsd[0]._value === undefined) {
            tsd = tsd.slice(1);
        }
        while (tsd[tsd.length - 1]._value === undefined) {
            tsd = tsd.slice(0, tsd.length - 1);
        }
        // **********************************
        // Time scale ***********************
        var timeScale = d3$3
            .scaleTime()
            .domain(d3$3.extent(tsd, (x) => x._time))
            .range([0, chart_width]);
        // **********************************
        // Value scale **********************
        // compute the min-max of the tooltip using the real record values
        var [value_min, value_max] = d3$3.extent(tsd, (_) => _._value);
        var steadyValue;
        if (value_min === value_max) {
            steadyValue = value_min;
            value_min -= 0.0001;
            value_max += 0.0001;
        }
        if (ts.hasFlippedDomain()) {
            [value_max, value_min] = [value_min, value_max];
        }
        var valueScale = d3$3
            .scaleLinear()
            .domain([value_min, value_max])
            .rangeRound([chart_height, 0]);
        // get activeTime
        var tsDots = "";
        var activeTime = null;
        if (activeVal != null) {
            activeTime = ts.timeKeys.filter((tk) => tk._time_src === a2.timeKey._time_src)[0];
            tsDots =
                `<g transform='translate(${timeScale(activeTime._time)} ${valueScale(activeVal)})'><circle class='activeValueDot' r='4' fill='${this.recordColorScale(activeVal)}'/><text class='activeValueText' y='-5'>${a.printAbbr(activeVal, true)}</text>` + "</g>";
        }
        var colorOut = this.browser.colorTheme.getContinuous();
        var mapp = this.mapColorScalePos
            .copy()
            .range(this.invertedColorTheme ? [1, 0] : [0, 1]);
        this.sparklineCounter++;
        // add the time extent
        [tsd[0], tsd[tsd.length - 1]].forEach((t) => {
            tsDots += `<g transform='translate(${timeScale(t._time)} ${chart_height})'><text class='limitText activeValueTime' y='16'>${t._time_src}</text></g>`;
        });
        // add the value extent
        if (!steadyValue) {
            var onLeft = activeTime && activeTime._index > ts.timeKeys.length / 2;
            [value_max, value_min].forEach((v) => {
                tsDots +=
                    "<g transform='translate(" +
                        (onLeft ? 0 : chart_width) +
                        " " +
                        valueScale(v) +
                        ")'>" +
                        "<text class='limitText activeRangeText' x='" +
                        (onLeft ? "-" : "") +
                        "3' y='5' " +
                        "style='text-anchor: " +
                        (onLeft ? "end" : "start") +
                        ";'>" +
                        ts.printAbbr(v, true) +
                        "</text>" +
                        "</g>";
            });
        }
        var _stroke = steadyValue ? colorOut(mapp(value_max)) : "";
        return (recordName +
            catColorText +
            `<div class='sparklineWrapper'>
        <svg class='tooltipSparkline' xmlns='http://www.w3.org/2000/svg'>
          <defs>
            <clipPath id='SparklineClipPath${this.sparklineCounter}'>
              <rect x='-20' y='-25' height='100' class='sparkLineClipPath'></rect>
            </clipPath>
          </defs>
          <g>
            <path class='timeline' d='${Util.getLineGenerator(timeScale, valueScale)(tsd)}' stroke='${_stroke}' />
            ${tsDots}
          </g>
        </svg>
      </div>
      <span class='timeseriesName blockName'>${ts.attribNameHTML}</span>`);
    }
    /** -- */
    refreshRecordDOM() {
        var _a, _b, _c;
        var isCanvasView = ["map", "node", "scatter", "timeseries"].includes(this.viewRecAs);
        this.DOM.recordGroup
            .selectAll(".kshfRecord")
            .data(this.View.getRecordsForDOM(), (record) => record.id)
            .join((enter) => {
            // argh. removing this causes some weird animation problem..
            if (enter.nodes().length === 0)
                return enter;
            return (enter
                .append({
                map: "g",
                node: "g",
                scatter: "g",
                timeseries: "g",
                list: "div",
            }[this.viewRecAs])
                // kshfRecord_XYZ can be used to apply custom CSS
                .attr("class", (record) => "kshfRecord kshfRecord_#" +
                // record.id may not be string with dynamic data loading
                ("" + record.id).replace(/\s/g, "_"))
                .tooltip((record) => this.getRecordTitle(record), {
                theme: "dark kshf-tooltip kshf-record",
                placement: "right",
                animation: "fade",
                followCursor: this.viewRecAs === "map",
                offset: [0, this.viewRecAs === "map" ? 10 : 0],
                onShown: (instance) => {
                    d3$3.select(instance.popper)
                        .select(".sparkLineClipPath")
                        .attr("width", 2)
                        .transition()
                        .duration(1000)
                        .delay(0)
                        .ease(d3$3.easePolyInOut)
                        .attr("width", 200);
                },
            })
                .on("mouseenter", (event, record) => {
                if (this.viewRecAs === "timeseries")
                    return;
                var DOM = event.currentTarget;
                if (DOM.highlightTimeout)
                    clearTimeout(DOM.highlightTimeout);
                DOM.highlightTimeout = window.setTimeout(() => {
                    clearTimeout(DOM.highlightTimeout);
                    this.onRecordMouseOver(record);
                }, this.browser.movingMouseDelay);
            })
                .on("mouseleave", (event, record) => {
                if (this.viewRecAs === "timeseries")
                    return;
                var DOM = event.currentTarget;
                if (DOM.highlightTimeout)
                    window.clearTimeout(DOM.highlightTimeout);
                this.onRecordMouseLeave(record);
            })
                .on("mousedown", (event) => {
                if (!isCanvasView)
                    return;
                event.currentTarget._mousemove = false;
                event.stopPropagation();
                event.preventDefault();
            })
                .on("mousemove", (event) => {
                if (!isCanvasView)
                    return;
                event.currentTarget._mousemove = true;
            })
                .on("click", (event, record) => {
                if (!isCanvasView)
                    return;
                var DOM = event.currentTarget;
                if (DOM._mousemove)
                    return; // Do not show the detail view if the mouse was used to drag the canvas
                this.browser.recordDetailsPopup.updateRecordDetailPanel(record);
                if (this.viewRecAs === "map" &&
                    this.codeBy.color instanceof Attrib_Numeric) {
                    this.browser.recordDetailsPopup.updateFocusedTimeKey(this.codeBy.color.timeKey);
                }
                if (DOM.highlightTimeout)
                    window.clearTimeout(DOM.highlightTimeout);
                if (DOM.tippy.state.visible)
                    DOM.tippy.hide();
                this.onRecordMouseLeave(record);
            })
                .call((newRecords) => {
                this.View.extendRecordDOM(newRecords);
            }));
        }, (_update) => null, (exit) => exit.each((record) => record.assignDOM(null)).remove());
        this.DOM.kshfRecords = this.DOM.recordGroup
            .selectAll(".kshfRecord")
            .each((record, i, nodes) => {
            var DOM = nodes[i];
            record.assignDOM(DOM);
            if (this.viewRecAs === "list" || this.viewRecAs === "timeseries") {
                DOM.tippy.disable();
            }
            else {
                DOM.tippy.enable();
            }
        });
        if (isCanvasView) {
            this.DOM.kshfRecords_Path = this.DOM.recordGroup.selectAll(".kshfRecord > path.glyph_Main");
        }
        if (this.View instanceof RecordView_Map) {
            this.View.setMaxBounds();
            // continue executing below... no break
        }
        else if (this.View instanceof RecordView_Scatter) {
            this.View.finishSetAttrib("size"); // TODO: Check / can be removed.
            (_a = this.View) === null || _a === void 0 ? void 0 : _a.refreshRecordColors();
            //
        }
        (_b = this.View) === null || _b === void 0 ? void 0 : _b.refreshSelect_Compare();
        (_c = this.View) === null || _c === void 0 ? void 0 : _c.updateRecordVisibility();
        this.refreshTextAttrib();
        this.kshfRecords_Type = this.viewRecAs;
    }
    /** -- */
    refreshAfterHighlight(v) {
        this.setDimmed(v);
        this.View.refreshLabelOverlaps();
    }
    /** -- */
    setDimmed(v) {
        var _a;
        (_a = this.DOM.root) === null || _a === void 0 ? void 0 : _a.classed("dimmed", v);
    }
    /** -- */
    updateAfterFilter(how) {
        if (this.viewRecAs === "none")
            return;
        this.refreshCompareLegend();
        this.View.updateAfterFilter(how);
    }
    /** -- */
    getRecordGeoAttributes() {
        return this.browser.attribs.filter((attrib) => attrib instanceof Attrib_RecordGeo);
    }
    /** -- */
    exportConfig() {
        var config = {
            viewAs: this.viewRecAs,
            collapsed: this.collapsed,
            colorInvert: this.invertColorTheme,
            filter: this.recordFilter.isFiltered
                ? this.recordFilter.exportFilter()
                : undefined,
        };
        var attribName;
        [
            "sort",
            "scatterX",
            "scatterY",
            "color",
            "size",
            "link",
            "timeSeries",
            "geo",
            "text",
            "textBrief",
        ].forEach((v) => {
            var attrib = this[v + "Attrib"];
            if (!attrib)
                return;
            if (attrib === "_measure_") {
                attribName = "_measure_";
            }
            else if (attrib instanceof Attrib) {
                attribName = attrib.template.str || attrib.attribName;
                if (attrib.hasTimeSeriesParent())
                    attribName = attrib.template.str;
            }
            else {
                return;
            }
            config[v + "By"] = attribName;
        });
        Object.values(this.configs).forEach((_cfg) => _cfg.exportConfigTo(config));
        return config;
    }
    /** -- */
    // TO-DO: Improve, A LOT.
    importConfig(config) {
        return __awaiter(this, void 0, void 0, function* () {
            if (config == null)
                return;
            yield this.browser.recordChartType.set(config.viewAs);
            if (config.colorTheme) {
                this.setRecordColorTheme(config.colorTheme);
            }
            if (config.colorInvert) {
                this.invertColorTheme(true);
            }
            if (config.recordPointSize) {
                yield this.recordPointSize.set(config.recordPointSize);
            }
            if (config.collapsed) {
                this.collapseRecordViewSummary(true);
            }
            else {
                this.collapseRecordViewSummary(false);
            }
        });
    }
}

class MapData {
    // main external access to geometric feature (polygon, etc.) given an indexed key
    getFeature(key) {
        return this.features[key];
    }
    /** -- */
    constructor(name, fileName, processCfg) {
        // cache for loaded state
        this._geoLoaded = false;
        this.features = {};
        this.name = name;
        this.fileName = fileName + "?ma";
        processCfg = processCfg || {};
        this.featureCb = processCfg.featureCb;
        this.alternatives = processCfg.alternatives || {};
        this.defaultIndexedProps = ["id", "ISO3166-2", "ISO3166-1"];
        if (processCfg.indexedProps) {
            if (!Array.isArray(processCfg.indexedProps)) {
                processCfg.indexedProps = [processCfg.indexedProps];
            }
            this.defaultIndexedProps = this.defaultIndexedProps.concat(processCfg.indexedProps);
        }
        this._processAlternatives(); // calling this to register the names for boost-detection
    }
    /** -- */
    get geoLoaded() {
        return this._geoLoaded;
    }
    /** -- */
    _processAlternatives() {
        for (var _from in this.alternatives) {
            var _target = this.alternatives[_from];
            if (_from === "expand") {
                for (var name in this.features) {
                    _target.forEach((expander) => {
                        var _newKey = name.replace(expander.from, expander.to || "");
                        if (_newKey === name || this.features[_newKey]) {
                            return; // same, or key exists
                        }
                        this.features[_newKey] = this.features[name];
                        if (expander.replace) {
                            delete this.features[name];
                        }
                    });
                }
            }
            else if (Array.isArray(_target)) {
                _target
                    .filter((_to) => typeof _to === "string")
                    .forEach((_to) => {
                    this.features[_to] =
                        this.features[_to] || this.features[_from] || null;
                });
            }
        }
    }
    /** -- */
    loadGeo() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._geoLoaded)
                return true;
            return (fetch(this.fileName, { credentials: "same-origin" })
                .then((response) => response.json())
                // if topojson format, load library and parse to geojson
                .then((data) => __awaiter(this, void 0, void 0, function* () {
                if (!data.objects)
                    return data;
                yield import('./vendor_mapping.js').then(function (n) { return n.t; });
                return window.topojson.feature(data, data.objects.regions);
            }))
                .then((geojsonData) => {
                geojsonData.features.forEach((feature) => {
                    // move features from .properties.alltags to the .properties so they can be indexed
                    if (feature.properties.alltags) {
                        for (var k in feature.properties.alltags)
                            feature.properties[k] = feature.properties.alltags[k];
                        delete feature.properties.alltags;
                    }
                    if (this.featureCb)
                        feature = this.featureCb(feature);
                    feature.properties.id = feature.properties.id || feature.id;
                    // detect all properties that include "name", but not "fix" + indexed properties
                    this.defaultIndexedProps
                        .concat(Object.keys(feature.properties).filter((x) => x.toUpperCase().includes("NAME") &&
                        !x.toUpperCase().includes("FIX")))
                        .forEach((indexProp) => {
                        var _index = feature.properties[indexProp];
                        if (!_index)
                            return;
                        _index = "" + _index;
                        this.features[_index.toUpperCase()] = feature;
                        // index version with "-" replaced with " "
                        if (_index.includes("-")) {
                            this.features[_index.replace(/-/g, " ").toUpperCase()] = feature;
                        }
                    });
                });
                this._geoLoaded = true;
                this._processAlternatives();
            }));
        });
    }
}

var mapStandardsMenuOpts = {
    id: "cat_addMap",
    name: "Add map",
    iconClass: "far fa-globe",
    when: (attrib) => attrib instanceof Attrib_Categorical && !attrib.catGeo,
    do: (attrib, action, path) => __awaiter(void 0, void 0, void 0, function* () {
        path = path.slice(path[1] === "World" ? 1 : 2);
        var mapIndex = "Map_" +
            path.map((_) => _.replace(/ /g, "").replace(/-/g, "")).join("_") +
            "_" +
            action.level;
        yield attrib.setCatGeo_(mapIndex + "[UPPERCASE(*)]");
    }),
    options: [
        {
            name: "World",
            options: [
                {
                    name: "Country",
                    value: {
                        level: "Adm2",
                        indexedProps: [
                            "ISO3166-1:alpha2",
                            "ISO3166-1:alpha3",
                            "ISO3166-1:numeric",
                        ],
                        alternatives: {
                            "BOSNIA AND HERZEGOVINA": ["BOSNIA-HERZEGOVINA"],
                            BRUNEI: ["BRUNEI DARUSSALAM"],
                            BOLIVIA: [
                                "BOLIVARIAN REPUBLIC OF VENEZUELA",
                                "BOLIVIA, PLURINATIONAL STATE OF",
                            ],
                            BAHAMAS: ["BAHAMAS, THE", "THE BAHAMAS"],
                            "DEMOCRATIC REPUBLIC OF THE CONGO": [
                                "CONGO, DEM. REP.",
                                "CONGO, THE DEMOCRATIC REPUBLIC OF THE",
                                "CONGO, DEMOCRATIC REPUBLIC",
                            ],
                            CONGO: ["CONGO, REP.", "CONGO, REPUBLIC OF"],
                            "CÔTE D'IVOIRE": ["COTE D'IVOIRE", "IVORY COAST"],
                            CHINA: ["CHINA, PEOPLE'S REPUBLIC OF"],
                            "CABO VERDE": ["CAPE VERGE"],
                            EGYPT: ["EGYPT, ARAB REP."],
                            "SAHRAWI ARAB DEMOCRATIC REPUBLIC": [
                                "WESTERN SAHARA",
                                "Saharawi",
                                "Sahrawi Republic",
                            ],
                            MICRONESIA: [
                                "MICRONESIA, FEDERATED STATES OF",
                                "MICRONESIA, FED. STS.",
                            ],
                            "UNITED KINGDOM OF GREAT BRITAIN AND NORTHERN IRELAND": [
                                "UNITED KINGDOM",
                                "BRITAIN",
                            ],
                            GAMBIA: ["GAMBIA, THE", "THE GAMBIA"],
                            IRAN: ["IRAN, ISLAMIC REPUBLIC OF", "IRAN, ISLAMIC REP."],
                            KOSOVO: ["XKX", "XXK"],
                            KYRGYZSTAN: ["KYRGYZ REPUBLIC"],
                            "SAINT KITTS AND NEVIS": ["ST. KITTS AND NEVIS"],
                            "NORTH KOREA": [
                                "KOREA, DEMOCRATIC PEOPLE'S REPUBLIC OF",
                                "KOREA, NORTH",
                            ],
                            "SOUTH KOREA": [
                                "KOREA, REPUBLIC OF",
                                "KOREA, REP.",
                                "KOREA, SOUTH",
                            ],
                            "LAO PEOPLE'S DEMOCRATIC REPUBLIC": ["LAOS", "LAO PDR"],
                            "SAINT LUCIA": ["ST. LUCIA"],
                            MOLDOVA: ["MOLDOVA, REPUBLIC OF"],
                            MACEDONIA: [
                                "MACEDONIA, THE FORMER YUGOSLAV REPUBLIC OF",
                                "NORTH MACEDONIA",
                                "REPUBLIC OF MACEDONIA",
                                "MACEDONIA, FYR",
                            ],
                            MYANMAR: ["BURMA"],
                            "PALESTINIAN TERRITORIES": [
                                "PALESTINE",
                                "PALESTINE, STATE OF",
                                "WEST BANK AND GAZA",
                            ],
                            REUNION: ["RÉUNION"],
                            "RUSSIAN FEDERATION": ["RUSSIA"],
                            SLOVAKIA: ["SLOVAK REPUBLIC"],
                            "SOUTH SUDAN": ["REPUBLIC OF SOUTH SUDAN"],
                            "SÃO TOMÉ AND PRÍNCIPE": ["SAO TOME AND PRINCIPE"],
                            "SYRIAN ARAB REPUBLIC": ["SYRIA"],
                            ESWATINI: ["SWAZILAND"],
                            TAIWAN: ["TAIWAN, PROVINCE OF CHINA", "TAIWAN (POC)"],
                            TANZANIA: ["TANZANIA, UNITED REPUBLIC OF"],
                            "UNITED STATES OF AMERICA": ["USA", "UNITED STATES"],
                            VATIKAN: ["HOLY SEE (VATIKAN)", "HOLY SEE"],
                            "SAINT VINCENT AND THE GRENADINES": [
                                "ST. VINCENT AND GRENADINES",
                                "ST. VINCENT AND THE GRENADINES",
                            ],
                            VIETNAM: ["VIET NAM"],
                            YEMEN: ["YEMEN, REP.", "REPUBLIC OF YEMEN", "YEMEN, REPUBLIC OF"],
                            VENEZUELA: ["BOLIVARIAN REPUBLIC OF VENEZUELA", "VENEZUELA, RB"],
                        },
                        featureCb: (feature) => {
                            var wrap, adj = 9;
                            switch (feature.properties["ISO3166-1"]) {
                                case "RU":
                                case "NZ":
                                case "FJ":
                                    wrap = (x) => x < 0;
                                    adj = 360;
                                    break;
                                case "US":
                                    wrap = (x) => x > 0;
                                    adj = -360;
                                    break;
                            }
                            if (wrap) {
                                feature.geometry.coordinates.forEach((a, i1) => {
                                    a.forEach((b, i2) => {
                                        b.forEach((c, i3) => {
                                            if (wrap(c[0]))
                                                feature.geometry.coordinates[i1][i2][i3][0] = c[0] +=
                                                    adj;
                                        });
                                    });
                                });
                            }
                            return feature;
                        },
                    },
                },
            ],
        },
        {
            name: "Central America and the Caribbean",
            options: [
                {
                    name: "Belize",
                    options: [{ name: "District", value: { level: "Adm4" } }],
                },
                {
                    name: "Costa Rica",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "Canton", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Cuba",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "Municipality", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Dominican Republic",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "Municipality", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "El Salvador",
                    options: [{ name: "Department", value: { level: "Adm4" } }],
                },
                {
                    name: "Guatemala",
                    options: [
                        { name: "Department", value: { level: "Adm4" } },
                        { name: "Municipality", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Haiti",
                    options: [
                        { name: "Department", value: { level: "Adm4" } },
                        { name: "Arrondissement", value: { level: "Adm5" } },
                    ],
                },
                {
                    name: "Honduras",
                    options: [{ name: "Department", value: { level: "Adm4" } }],
                },
                {
                    name: "Jamaica",
                    options: [{ name: "Parish", value: { level: "Adm6" } }],
                },
                {
                    name: "Nicaragua",
                    options: [
                        { name: "Department", value: { level: "Adm4" } },
                        { name: "Municipality", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Panama",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Puerto Rico",
                    options: [{ name: "Municipality", value: { level: "Adm6" } }],
                },
            ],
        },
        {
            name: "Central Asia",
            options: [
                {
                    name: "Armenia",
                    options: [{ name: "Province", value: { level: "Adm4" } }],
                },
                {
                    name: "Azerbaijan",
                    options: [{ name: "District", value: { level: "Adm4" } }],
                },
                {
                    name: "Cyprus",
                    options: [{ name: "District", value: { level: "Adm6" } }],
                },
                {
                    name: "Georgia",
                    options: [
                        { name: "Region", value: { level: "Adm4" } },
                        { name: "Municipality / District", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Kazakhstan",
                    options: [
                        { name: "Region", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Kyrgyzstan",
                    options: [{ name: "Region", value: { level: "Adm4" } }],
                },
                {
                    name: "Russia",
                    options: [{ name: "Oblast", value: { level: "Adm4" } }],
                },
                {
                    name: "Tajikistan",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Turkmenistan",
                    options: [{ name: "Region", value: { level: "Adm4" } }],
                },
                {
                    name: "Uzbekistan",
                    options: [{ name: "Region", value: { level: "Adm4" } }],
                },
            ],
        },
        {
            name: "East Asia and Pacific",
            options: [
                {
                    name: "Australia",
                    options: [
                        { name: "State", value: { level: "Adm4" } },
                        { name: "LGA", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Brunei",
                    options: [{ name: "District", value: { level: "Adm4" } }],
                },
                {
                    name: "Cambodia",
                    options: [{ name: "Province", value: { level: "Adm4" } }],
                },
                {
                    name: "China",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "Cities", value: { level: "Adm5" } },
                    ],
                },
                {
                    name: "Indonesia",
                    options: [{ name: "Province", value: { level: "Adm4" } }],
                },
                {
                    name: "Japan",
                    options: [
                        { name: "Prefecture", value: { level: "Adm4" } },
                        { name: "Subprefecture", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Laos",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Malaysia",
                    options: [{ name: "State_Territory", value: { level: "Adm4" } }],
                },
                {
                    name: "Mongolia",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Myanmar",
                    options: [
                        { name: "Region / State", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "New Zealand",
                    options: [
                        { name: "Region", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "North Korea",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "City", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Papua New Guinea",
                    options: [
                        { name: "Region", value: { level: "Adm3" } },
                        { name: "Province", value: { level: "Adm4" } },
                    ],
                },
                {
                    name: "Philippines",
                    options: [
                        { name: "Region", value: { level: "Adm3" } },
                        { name: "Province", value: { level: "Adm4" } },
                    ],
                },
                {
                    name: "Singapore",
                    options: [{ name: "CDC", value: { level: "Adm6" } }],
                },
                {
                    name: "South Korea",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "City", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Thailand",
                    options: [{ name: "Province", value: { level: "Adm4" } }],
                },
                {
                    name: "Vietnam",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "City", value: { level: "Adm6" } },
                    ],
                },
            ],
        },
        {
            name: "Europe",
            options: [
                {
                    name: "Albania",
                    options: [
                        { name: "Counties", value: { level: "Adm6" } },
                        { name: "Municipality", value: { level: "Adm7" } },
                    ],
                },
                {
                    name: "Austria",
                    options: [
                        { name: "State", value: { level: "Adm4" } },
                        { name: "District &amp; S. Cities", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Belarus",
                    options: [
                        { name: "Region", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Belgium",
                    options: [
                        { name: "Regions", value: { level: "Adm4" } },
                        { name: "Province", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Bosnia-Herzegovina",
                    options: [
                        { name: "District", value: { level: "Adm4" } },
                        { name: "Municipality", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Bulgaria",
                    options: [
                        { name: "Province", value: { level: "Adm6" } },
                        { name: "Municipality", value: { level: "Adm8" } },
                    ],
                },
                {
                    name: "Croatia",
                    options: [
                        { name: "County", value: { level: "Adm6" } },
                        { name: "Municipality", value: { level: "Adm7" } },
                    ],
                },
                {
                    name: "Czech Republic",
                    options: [
                        { name: "Regions", value: { level: "Adm6" } },
                        { name: "District", value: { level: "Adm7" } },
                    ],
                },
                {
                    name: "Denmark",
                    options: [{ name: "Regions", value: { level: "Adm4" } }],
                },
                {
                    name: "Estonia",
                    options: [
                        { name: "County", value: { level: "Adm6" } },
                        { name: "Municipality", value: { level: "Adm7" } },
                    ],
                },
                {
                    name: "Finland",
                    options: [
                        { name: "Region", value: { level: "Adm6" } },
                        { name: "Subregion", value: { level: "Adm7" } },
                    ],
                },
                {
                    name: "France",
                    options: [
                        { name: "Region", value: { level: "Adm4" } },
                        { name: "Department", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Germany",
                    options: [
                        { name: "State", value: { level: "Adm4" } },
                        {
                            name: "District",
                            value: {
                                level: "Adm6",
                                indexedProps: "de:regionalschluessel",
                                alternatives: { expand: [{ from: /LANDKREIS /g }] },
                            },
                        },
                    ],
                },
                {
                    name: "Greece",
                    options: [
                        { name: "Region", value: { level: "Adm5" } },
                        { name: "Regional Unit", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Hungary",
                    options: [
                        { name: "County", value: { level: "Adm6" } },
                        { name: "District", value: { level: "Adm7" } },
                    ],
                },
                {
                    name: "Iceland",
                    options: [
                        { name: "Region", value: { level: "Adm5" } },
                        { name: "Municipality", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Ireland",
                    options: [
                        { name: "County", value: { level: "Adm6" } },
                        { name: "District", value: { level: "Adm8" } },
                    ],
                },
                {
                    name: "Italy",
                    options: [
                        { name: "Region", value: { level: "Adm4" } },
                        { name: "Province", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Kosovo",
                    options: [
                        {
                            name: "District",
                            value: {
                                level: "Adm4",
                                alternatives: {
                                    PRISHTINA: ["PRISHTINË", "PRISTINA"],
                                    PEJA: ["PEĆ", "PEJE", "PEJË"],
                                    GJAKOVA: ["GJAKOVË"],
                                    expand: [
                                        { from: / \(\d+\)/g, replace: true },
                                        { from: "District of ", replace: true },
                                        { from: "Region of ", replace: true },
                                    ],
                                },
                            },
                        },
                        {
                            name: "Municipality",
                            value: {
                                level: "Adm6",
                                alternatives: {
                                    DEÇAN: ["DEČANI"],
                                    DRAGASH: ["DRAGAŠ"],
                                    FERIZAJ: ["UROŠEVAC"],
                                    "FUSHË KOSOVË": ["KOSOVO POLJE"],
                                    GJAKOVË: ["GJAKOVA", "ĐAKOVICA"],
                                    GJILAN: ["GNJILANE"],
                                    GLLOGOVC: ["DRENAS", "GLOGOVAC", "GLLOGOC"],
                                    GRACANICË: ["GRAČANICA", "GRAÇANICË", "GRACANICA"],
                                    "HANI I ELEZIT": ["ELEZ HAN"],
                                    ISTOG: ["BURIM", "ISTOK"],
                                    KAÇANIK: ["KAČANIK"],
                                    KAMENICA: ["DARDANË", "KOSOVSKA KAMENICA", "KAMENICË"],
                                    KLINA: ["KLINË"],
                                    KLOKOT: ["KLLOKOT", "KLLOKOTI"],
                                    LEPOSAVIQ: ["LEPOSAVIĆ"],
                                    LIPJAN: ["LIPLJAN"],
                                    MALISHEVË: ["MALIŠEVO"],
                                    MAMUSHË: ["MAMUŠA", "MAMUSH"],
                                    MITROVICA: ["MITROVICË", "KOSOVSKA MITROVICA"],
                                    "MITROVICA E VERIUT": [
                                        "MITROVICA VERIORE",
                                        "NORTH MITROVICA",
                                        "SEVERNA KOSOVSKA MITROVICA",
                                        "SEVERNA MITROVICA",
                                    ],
                                    "NOVO BRDO": ["NOVOBËRDË", "NOVOBERDE"],
                                    OBILIQ: ["KASTRIOT", "OBILIĆ", "OBILIC"],
                                    PARTESH: ["PARTEŠ", "PARTES"],
                                    PEJË: ["PEĆ"],
                                    PODUJEVË: ["BESIANË", "PODUJEVO"],
                                    PRISHTINË: ["PRISHTINA", "PRISHTINE", "PRISTINA", "PRIŠTINA"],
                                    RAHOVEC: ["ORAHOVAC"],
                                    RANILLUG: ["RANILUG", "RANILLUK"],
                                    SHTËRPCE: ["SHTËRPCË", "ŠTRPCE"],
                                    SHTIME: ["ŠTIMLJE"],
                                    SKENDERAJ: ["SKËNDERAJ", "SRBICA"],
                                    "SUHA REKË": ["SUHAREKË", "THERANDË", "SUVA REKA"],
                                    VITI: ["VITINA", "VITIA"],
                                    VUSHTRRI: ["VUČITRN"],
                                    "ZUBIN POTOK": ["ZUBIN POTOKU", "ZUBİN POTOK"],
                                    ZVEÇAN: ["ZVEČAN"],
                                    expand: [
                                        { from: / \(\d+\)/g, replace: true },
                                        { from: "Municipality of ", replace: true },
                                        { from: "Region of ", replace: true },
                                    ],
                                },
                            },
                        },
                    ],
                },
                {
                    name: "Latvia",
                    options: [{ name: "Municipality", value: { level: "Adm6" } }],
                },
                {
                    name: "Lithuania",
                    options: [
                        { name: "County", value: { level: "Adm4" } },
                        { name: "Municipality", value: { level: "Adm5" } },
                    ],
                },
                {
                    name: "Macedonia",
                    options: [
                        { name: "Region", value: { level: "Adm4" } },
                        {
                            name: "Municipality",
                            value: {
                                level: "Adm7",
                                alternatives: { expand: [{ from: /MUNICIPALITY OF /g }] },
                            },
                        },
                    ],
                },
                {
                    name: "Moldova",
                    options: [{ name: "District", value: { level: "Adm4" } }],
                },
                {
                    name: "Montenegro",
                    options: [{ name: "Municipality", value: { level: "Adm4" } }],
                },
                {
                    name: "Netherlands",
                    options: [
                        { name: "State", value: { level: "Adm3" } },
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "Municipality", value: { level: "Adm8" } },
                    ],
                },
                {
                    name: "Norway",
                    options: [
                        { name: "County", value: { level: "Adm4" } },
                        { name: "Municipality", value: { level: "Adm7" } },
                    ],
                },
                {
                    name: "Poland",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "County", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Portugal",
                    options: [
                        { name: "District", value: { level: "Adm6" } },
                        { name: "Municipality", value: { level: "Adm7" } },
                    ],
                },
                {
                    name: "Romania",
                    options: [{ name: "County", value: { level: "Adm4" } }],
                },
                {
                    name: "Serbia",
                    options: [
                        { name: "District", value: { level: "Adm6" } },
                        { name: "Municipality_City", value: { level: "Adm8" } },
                    ],
                },
                {
                    name: "Slovakia",
                    options: [
                        { name: "Region", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm8" } },
                    ],
                },
                {
                    name: "Slovenia",
                    options: [
                        { name: "Region", value: { level: "Adm5" } },
                        { name: "Municipality", value: { level: "Adm8" } },
                    ],
                },
                {
                    name: "Spain",
                    options: [
                        { name: "Autonomous Community", value: { level: "Adm4" } },
                        { name: "Province", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Sweden",
                    options: [
                        { name: "County", value: { level: "Adm4" } },
                        { name: "Municipality", value: { level: "Adm7" } },
                    ],
                },
                {
                    name: "Switzerland",
                    options: [
                        { name: "Canton", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Turkey",
                    options: [
                        { name: "Region", value: { level: "Adm3" } },
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Ukraine",
                    options: [
                        { name: "Region", value: { level: "Adm4" } },
                        { name: "Raion", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "United Kingdom",
                    options: [
                        { name: "Country", value: { level: "Adm4" } },
                        { name: "County / Unitary authorities", value: { level: "Adm6" } },
                    ],
                },
            ],
        },
        {
            name: "Middle East and North Africa",
            options: [
                {
                    name: "Algeria",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm6" } },
                        // { "name": "Municipality", "value": { "level": "Adm8"} }, // Not OSM-based
                    ],
                },
                {
                    name: "Bahrain",
                    options: [{ name: "Governorate", value: { level: "Adm4" } }],
                },
                {
                    name: "Egypt",
                    options: [{ name: "Governorate", value: { level: "Adm4" } }],
                },
                {
                    name: "Iraq",
                    options: [{ name: "Governorate", value: { level: "Adm4" } }],
                },
                {
                    name: "Iran",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "County", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Israel",
                    options: [{ name: "District", value: { level: "Adm4" } }],
                },
                {
                    name: "Jordan",
                    options: [{ name: "Governorate", value: { level: "Adm4" } }],
                },
                {
                    name: "Kuwait",
                    options: [{ name: "Governorate", value: { level: "Adm4" } }],
                },
                {
                    name: "Lebanon",
                    options: [
                        { name: "Governorate", value: { level: "Adm3" } },
                        { name: "District", value: { level: "Adm4" } },
                    ],
                },
                {
                    name: "Libya",
                    options: [{ name: "District", value: { level: "Adm4" } }],
                },
                {
                    name: "Morocco",
                    options: [
                        { name: "Region", value: { level: "Adm4" } },
                        { name: "Profecture / Province", value: { level: "Adm5" } },
                    ],
                },
                {
                    name: "Oman",
                    options: [{ name: "Governorate", value: { level: "Adm4" } }],
                },
                {
                    name: "Palestine",
                    options: [
                        { name: "Territory", value: { level: "Adm3" } },
                        { name: "Governorate", value: { level: "Adm5" } },
                    ],
                },
                {
                    name: "Qatar",
                    options: [{ name: "Municipality", value: { level: "Adm4" } }],
                },
                {
                    name: "Saudi Arabia",
                    options: [{ name: "Region", value: { level: "Adm4" } }],
                },
                {
                    name: "Syria",
                    options: [
                        {
                            name: "Governorate",
                            value: { level: "Adm4", indexedProps: ["PCODE"] },
                        },
                    ],
                },
                {
                    name: "Tunisia",
                    options: [
                        { name: "Governorate", value: { level: "Adm4" } },
                        { name: "Delegation", value: { level: "Adm5" } },
                    ],
                },
                {
                    name: "United Arab Emirates",
                    options: [{ name: "Emirate", value: { level: "Adm4" } }],
                },
                {
                    name: "Yemen",
                    options: [
                        {
                            name: "Governorate",
                            value: {
                                level: "Adm4",
                                alternatives: { expand: [{ from: / GOVERNORATE/g }] },
                            },
                        },
                    ],
                },
            ],
        },
        {
            name: "North Ameria",
            options: [
                {
                    name: "Canada",
                    options: [{ name: "Province", value: { level: "Adm4" } }],
                },
                {
                    name: "Mexico",
                    options: [
                        { name: "State", value: { level: "Adm4" } },
                        { name: "Municipality", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "United States",
                    options: [
                        {
                            name: "States",
                            value: {
                                level: "Adm4",
                                indexedProps: ["ISO3166_2"],
                                alternatives: {
                                    expand: [{ from: "US-", replace: true }],
                                    // fips codes
                                    ALABAMA: [1, "01"],
                                    ALASKA: [2, "02"],
                                    ARIZONA: [4, "04"],
                                    ARKANSAS: [5, "05"],
                                    CALIFORNIA: [6, "06"],
                                    COLORADO: [8, "08"],
                                    CONNECTICUT: [9, "09"],
                                    DELAWARE: [10],
                                    "DISTRICT OF COLUMBIA": [11],
                                    FLORIDA: [12],
                                    GEORGIA: [13],
                                    HAWAII: [15],
                                    IDAHO: [16],
                                    ILLINOIS: [17],
                                    INDIANA: [18],
                                    IOWA: [19],
                                    KANSAS: [20],
                                    KENTUCKY: [21],
                                    LOUISIANA: [22],
                                    MAINE: [23],
                                    MARYLAND: [24],
                                    MASSACHUSETTS: [25],
                                    MICHIGAN: [26],
                                    MINNESOTA: [27],
                                    MISSISSIPPI: [28],
                                    MISSOURI: [29],
                                    MONTANA: [30],
                                    NEBRASKA: [31],
                                    NEVADA: [32],
                                    "NEW HAMPSHIRE": [33],
                                    "NEW JERSEY": [34],
                                    "NEW MEXICO": [35],
                                    "NEW YORK": [36],
                                    "NORTH CAROLINA": [37],
                                    "NORTH DAKOTA": [38],
                                    OHIO: [39],
                                    OKLAHOMA: [40],
                                    OREGON: [41],
                                    PENNSYLVANIA: [42],
                                    "RHODE ISLAND": [44],
                                    "SOUTH CAROLINA": [45],
                                    "SOUTH DAKOTA": [46],
                                    TENNESSEE: [47],
                                    TEXAS: [48],
                                    UTAH: [49],
                                    VERMONT: [50],
                                    VIRGINIA: [51],
                                    WASHINGTON: [53],
                                    "WEST VIRGINIA": [54],
                                    WISCONSIN: [55],
                                    WYOMING: [56],
                                    "AMERICAN SAMOA": [60],
                                    GUAM: [14, 66],
                                    "NORTHERN MARIANA ISLANDS": [69],
                                    "PUERTO RICO": [72],
                                    "VIRGIN ISLANDS": [78],
                                },
                                featureCb: (feature) => {
                                    var wrap = null, adj = 9;
                                    switch (feature.properties.name) {
                                        case 2:
                                        case "AK":
                                        case "Alaska":
                                        case "Northern Mariana Islands":
                                        case "Guam":
                                            wrap = (x) => x > 0;
                                            adj = -360;
                                            break;
                                    }
                                    if (wrap) {
                                        if (feature.geometry.coordinates[0][0][0][0]) {
                                            feature.geometry.coordinates.forEach((a, i1) => {
                                                a.forEach((b, i2) => {
                                                    b.forEach((c, i3) => {
                                                        if (wrap(c[0])) {
                                                            feature.geometry.coordinates[i1][i2][i3][0] =
                                                                c[0] += adj;
                                                        }
                                                    });
                                                });
                                            });
                                        }
                                        else {
                                            feature.geometry.coordinates.forEach((a, i1) => {
                                                a.forEach((b, i2) => {
                                                    if (wrap(b[0])) {
                                                        feature.geometry.coordinates[i1][i2][0] = b[0] +=
                                                            adj;
                                                    }
                                                });
                                            });
                                        }
                                    }
                                    return feature;
                                },
                            },
                        },
                        {
                            name: "Counties",
                            value: {
                                level: "Adm6",
                                indexedProps: ["GEO_ID"],
                                alternatives: {
                                    expand: [{ from: "0500000US", replace: true }],
                                },
                            },
                        },
                        {
                            name: "Congressional Districts",
                            options: [
                                {
                                    name: "115th",
                                    value: {
                                        level: "CD115",
                                        featureCb: (feature) => {
                                            var wrap = null, adj = 9;
                                            switch (feature.properties.id.substr(0, 2)) {
                                                case "AK":
                                                    wrap = (x) => x > 0;
                                                    adj = -360;
                                                    break;
                                            }
                                            if (wrap) {
                                                feature.geometry.coordinates.forEach((a, i1) => {
                                                    a.forEach((b, i2) => {
                                                        b.forEach((c, i3) => {
                                                            if (wrap(c[0]))
                                                                feature.geometry.coordinates[i1][i2][i3][0] =
                                                                    c[0] += adj;
                                                        });
                                                    });
                                                });
                                            }
                                            return feature;
                                        },
                                    },
                                },
                                {
                                    name: "115th-Hexagon",
                                    value: {
                                        level: "CD115HEX",
                                        indexedProps: ["GEO_ID"],
                                        featureCb: (feature) => {
                                            feature.properties.GEO_ID =
                                                feature.properties.STATEAB +
                                                    "-" +
                                                    feature.properties.CDLABEL.padStart(2, "0");
                                            return feature;
                                        },
                                    },
                                },
                            ],
                        },
                        {
                            name: "DC",
                            options: [
                                {
                                    name: "Wards (2012)",
                                    value: { level: "Wards2012", indexedProps: ["WARD"] },
                                },
                                {
                                    name: "ANCs (2013)",
                                    value: { level: "ANC2013", indexedProps: ["ANC_ID"] },
                                },
                                {
                                    name: "Neighborhoods",
                                    value: { level: "Neighborhoods", indexedProps: ["subhood"] },
                                },
                            ],
                        },
                    ],
                },
            ],
        },
        {
            name: "South America",
            options: [
                {
                    name: "Argentina",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "Department", value: { level: "Adm5" } },
                    ],
                },
                {
                    name: "Bolivia",
                    options: [
                        { name: "Department", value: { level: "Adm4" } },
                        { name: "Province", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Brazil",
                    options: [{ name: "State", value: { level: "Adm4" } }],
                },
                {
                    name: "Chile",
                    options: [
                        { name: "Regions", value: { level: "Adm4" } },
                        { name: "Province", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Colombia",
                    options: [
                        { name: "Department", value: { level: "Adm4" } },
                        { name: "Municipality", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Ecuador",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "Cantons", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Guyana",
                    options: [{ name: "Region", value: { level: "Adm4" } }],
                },
                {
                    name: "Paraguay",
                    options: [
                        { name: "Department", value: { level: "Adm4" } },
                        { name: "Municipality", value: { level: "Adm8" } },
                    ],
                },
                {
                    name: "Peru",
                    options: [
                        { name: "Region", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Suriname",
                    options: [{ name: "District", value: { level: "Adm4" } }],
                },
                {
                    name: "Uruguay",
                    options: [{ name: "Department", value: { level: "Adm4" } }],
                },
                {
                    name: "Venezuela",
                    options: [{ name: "State", value: { level: "Adm4" } }],
                },
            ],
        },
        {
            name: "South Asia",
            options: [
                {
                    name: "Afghanistan",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Bangladesh",
                    options: [
                        {
                            name: "Divisions",
                            value: { level: "Adm4", indexedProps: "Division" },
                        },
                        {
                            name: "District",
                            value: {
                                level: "Adm5",
                                indexedProps: "District",
                                alternatives: {
                                    NETRAKONA: ["NETROKONA"],
                                    BRAHAMANBARIA: ["BRAHMANBARIA"],
                                    NAWABGANJ: ["CHAPAI NAWABGANJ"],
                                },
                            },
                        },
                        {
                            name: "Upazilas",
                            value: {
                                level: "Adm6",
                                indexedProps: "Upazila",
                                alternatives: {
                                    NETRAKONA: ["NETROKONA"],
                                    BRAHAMANBARIA: ["BRAHMANBARIA"],
                                    NAWABGANJ: ["CHAPAI NAWABGANJ"],
                                },
                            },
                        },
                    ],
                },
                {
                    name: "Bhutan",
                    options: [
                        { name: "District", value: { level: "Adm4" } },
                        { name: "Gewogs", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "India",
                    options: [
                        { name: "State_Union_Territory", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm5" } },
                    ],
                },
                {
                    name: "Nepal",
                    options: [
                        { name: "Region", value: { level: "Adm4" } },
                        { name: "Zone", value: { level: "Adm5" } },
                        { name: "District", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Pakistan",
                    options: [{ name: "Province", value: { level: "Adm3" } }],
                },
                {
                    name: "Sri Lanka",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm5" } },
                    ],
                },
            ],
        },
        {
            name: "Sub-Saharan Africa",
            options: [
                {
                    name: "Angola",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "Municipality", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Benin",
                    options: [
                        { name: "Department", value: { level: "Adm4" } },
                        { name: "Communes", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Botswana",
                    options: [{ name: "District", value: { level: "Adm4" } }],
                },
                {
                    name: "Burkina Faso",
                    options: [
                        { name: "Regions", value: { level: "Adm4" } },
                        { name: "Province", value: { level: "Adm5" } },
                    ],
                },
                {
                    name: "Burundi",
                    options: [{ name: "Provices", value: { level: "Adm4" } }],
                },
                {
                    name: "Cameroon",
                    options: [
                        { name: "Regions", value: { level: "Adm4" } },
                        { name: "Department", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Central African Republic",
                    options: [{ name: "Prefectures", value: { level: "Adm4" } }],
                },
                {
                    name: "Chad",
                    options: [{ name: "Region", value: { level: "Adm4" } }],
                },
                {
                    name: "Congo",
                    options: [{ name: "Department", value: { level: "Adm4" } }],
                },
                {
                    name: "Djibouti",
                    options: [{ name: "Region", value: { level: "Adm4" } }],
                },
                {
                    name: "DR-Congo",
                    options: [{ name: "Province", value: { level: "Adm4" } }],
                },
                {
                    name: "Eritrea",
                    options: [{ name: "Region", value: { level: "Adm4" } }],
                },
                {
                    name: "Ethiopia",
                    options: [
                        { name: "Region", value: { level: "Adm4" } },
                        { name: "Zone", value: { level: "Adm5" } },
                    ],
                },
                {
                    name: "Gabon",
                    options: [{ name: "Province", value: { level: "Adm4" } }],
                },
                {
                    name: "Ghana",
                    options: [{ name: "Governorate", value: { level: "Adm4" } }],
                },
                {
                    name: "Gambia",
                    options: [
                        { name: "Regions", value: { level: "Adm4" } },
                        { name: "LGAs", value: { level: "Adm5" } },
                    ],
                },
                {
                    name: "Guinea",
                    options: [{ name: "Region", value: { level: "Adm4" } }],
                },
                {
                    name: "Ivory Coast",
                    options: [
                        { name: "District", value: { level: "Adm4" } },
                        { name: "Region", value: { level: "Adm5" } },
                    ],
                },
                {
                    name: "Kenya",
                    options: [{ name: "County", value: { level: "Adm4" } }],
                },
                {
                    name: "Lesotho",
                    options: [{ name: "District", value: { level: "Adm5" } }],
                },
                {
                    name: "Liberia",
                    options: [
                        { name: "County", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Madagascar",
                    options: [{ name: "Region", value: { level: "Adm4" } }],
                },
                {
                    name: "Malawi",
                    options: [
                        { name: "Region", value: { level: "Adm3" } },
                        { name: "District", value: { level: "Adm4" } },
                    ],
                },
                {
                    name: "Mali",
                    options: [
                        { name: "Region", value: { level: "Adm4" } },
                        { name: "Cercle", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Mauritania",
                    options: [{ name: "Region", value: { level: "Adm4" } }],
                },
                {
                    name: "Mozambique",
                    options: [{ name: "Province", value: { level: "Adm4" } }],
                },
                {
                    name: "Namibia",
                    options: [{ name: "Region", value: { level: "Adm4" } }],
                },
                {
                    name: "Niger",
                    options: [
                        { name: "Region", value: { level: "Adm4" } },
                        { name: "Department", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Nigeria",
                    options: [
                        { name: "State", value: { level: "Adm4" } },
                        { name: "LGA", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Rwanda",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Senegal",
                    options: [{ name: "Region", value: { level: "Adm3" } }],
                },
                {
                    name: "Somalia",
                    options: [
                        { name: "Region", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Sierra Leone",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm5" } },
                    ],
                },
                {
                    name: "South Africa",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "Municipality", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "South Sudan",
                    options: [
                        { name: "State", value: { level: "Adm4" } },
                        {
                            name: "County",
                            value: { level: "Adm6", indexedProps: ["ADM2_EN", "ADM2_PCODE"] },
                        },
                    ],
                },
                {
                    name: "Sudan",
                    options: [
                        { name: "State", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Swaziland",
                    options: [
                        { name: "District", value: { level: "Adm4" } },
                        { name: "Inkhundla", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Tanzania",
                    options: [
                        { name: "Region", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm5" } },
                    ],
                },
                {
                    name: "Togo",
                    options: [
                        { name: "Region", value: { level: "Adm4" } },
                        { name: "Prefecture", value: { level: "Adm6" } },
                    ],
                },
                {
                    name: "Uganda",
                    options: [{ name: "District", value: { level: "Adm4" } }],
                },
                {
                    name: "Zambia",
                    options: [{ name: "Province", value: { level: "Adm4" } }],
                },
                {
                    name: "Zimbabwe",
                    options: [
                        { name: "Province", value: { level: "Adm4" } },
                        { name: "District", value: { level: "Adm6" } },
                    ],
                },
            ],
        },
    ],
};
var _mapShapesLoaded = false;
/** -- */
function loadMapStandards() {
    if (_mapShapesLoaded)
        return;
    // recursive call
    function addMapIndex(obj, path) {
        if (obj.value) {
            var level = obj.value.level;
            if (path[0] !== "World" && path[0] !== "Custom")
                path = path.slice(1);
            var mapIndex = `Map_${path.map((_) => _.replace(/ /g, "").replace(/-/g, "")).join("_")}_${level}`;
            Base.maps.set(mapIndex, new MapData(mapIndex, `${Base.geoFileDir}${path.concat(level).join("/")}.${Base.geoFileExt}`, obj.value));
        }
        else if (obj.options) {
            path = path.concat([obj.name]);
            obj.options.forEach((_) => addMapIndex(_, path));
        }
    }
    mapStandardsMenuOpts.options.forEach((region) => addMapIndex(region, []));
    _mapShapesLoaded = true;
}

class BreadCrumb {
    /** -- */
    constructor(browser, selectType) {
        this.DOM = null; // d3-selection
        this.browser = browser;
        this.selectType = selectType;
    }
    /** -- */
    showCrumb(selectType, filter) {
        var _a, _b;
        this.selectType = selectType;
        if (this.timeoutHide)
            window.clearTimeout(this.timeoutHide);
        let attrib = filter instanceof Filter ? filter.attrib : null;
        if (!this.DOM) {
            var parentDOM = this.selectType === "Filter"
                ? this.browser.DOM.breadCrumbs_Filter
                : this.browser.DOM.breadCrumbs_Compare;
            this.DOM = parentDOM
                .append("span")
                .html(`<span class='breadCrumbIcon'><i class='fa fa-filter'></i><i class='far fa-times'></i></span>` +
                `<span class='crumbText'><span class='crumbHeader blockName'></span><span class='crumbDetails'></span></span>`)
                .each((_, i, nodes) => {
                if (this.selectType === "Filter") {
                    let DOM = nodes[i];
                    var l = DOM.parentNode.childNodes.length;
                    if (l > 1) {
                        DOM.parentNode.insertBefore(DOM, DOM.parentNode.childNodes[l - 2]);
                    }
                }
            })
                .on("mouseenter", () => {
                if (this.selectType !== "Filter") {
                    this.browser.refreshAllMeasureLabels(this.selectType);
                }
            })
                .on("mouseleave", () => {
                if (this.selectType === "Filter") {
                    this.browser.refreshAllMeasureLabels("Active");
                }
            })
                .on("click", () => {
                if (this.selectType === "Filter") {
                    filter.clearFilter();
                }
                else {
                    this.browser.clearSelect_Compare(this.selectType, true, true);
                    this.browser.refreshAllMeasureLabels("Active");
                }
            });
            this.DOM.style("opacity", 0).transition().style("opacity", 1);
        }
        this.DOM.attr("class", "breadCrumb crumbMode_" + this.selectType)
            .attr("data-summaryID", (_a = attrib === null || attrib === void 0 ? void 0 : attrib.attribID) !== null && _a !== void 0 ? _a : null)
            .tooltip(() => i18n[this.selectType === "Filter" ? "RemoveFilter" : "Unlock"]);
        if (this.selectType === "Filter") {
            this.browser.DOM.breadCrumbs_Filter.node().appendChild(this.DOM.node());
            var crumbHeader = this.DOM.select(".crumbHeader");
            if (attrib) {
                attrib.addDOMBlockName(crumbHeader);
            }
            else {
                crumbHeader.html(filter.title);
            }
            this.DOM.select(".crumbDetails").html(filter.filterView_Detail());
        }
        else {
            this.DOM.select(".crumbDetails").html(((_b = this.browser.selectedAggrs[this.selectType]) === null || _b === void 0 ? void 0 : _b.label) || "");
        }
        this.browser.checkAndAdjustBreadcrumbs();
    }
    /** -- */
    removeCrumb() {
        if (!this.DOM)
            return;
        if (this.timeoutHide)
            window.clearTimeout(this.timeoutHide);
        this.timeoutHide = window.setTimeout(() => {
            this.timeoutHide = 0;
            this.DOM.style("opacity", 0)
                .transition()
                .delay(300)
                .remove()
                .on("end", () => {
                var _a;
                (_a = this.DOM.node().tippy) === null || _a === void 0 ? void 0 : _a.hide();
                this.browser.checkAndAdjustBreadcrumbs();
                this.DOM = null;
            });
        }, 
        // duration for timeout
        this.selectType !== "Filter" &&
            !this.browser.lockedCompare[this.selectType]
            ? 1000
            : 0);
    }
}

var MenuOpts = {
    /** -- */
    AttribPanel: {
        name: "Options",
        items: [
            {
                id: "CollapseAll",
                name: "Collapse All",
                iconClass: "fa fa-caret-up",
                do: (dashboard) => dashboard.collapseAttribListGroups(true),
            },
            {
                id: "ExpandAll",
                name: "Expand All",
                iconClass: "fa fa-caret-down",
                do: (dashboard) => dashboard.collapseAttribListGroups(false),
            },
            {
                id: "SetAttribPanelWidth",
                name: "Set panel width",
                iconClass: "far fa-arrows-h",
                do: (dashboard) => {
                    var x = Modal.prompt("Enter width in pixels (between 200 and 400)", dashboard.attribPanelWidth);
                    if (x)
                        dashboard.setAttribPanelWidth(x);
                },
            },
        ],
    },
    /** -- */
    Attrib_Grouping: {
        name: "Settings",
        items: [
            {
                id: "createTimeseries",
                name: "Create Timeseries",
                iconClass: "far fa-chart-line",
                when: () => true,
                do: (groupInfo, action) => {
                    if (action === "prompt()") {
                        action = Modal.prompt("Enter time index format");
                        if (!action)
                            return;
                    }
                    // todo: update it to retrieve from parameter, not global space.
                    var dashboard = Base.browser;
                    var chain = groupInfo.parents.slice();
                    chain.push(groupInfo.name);
                    var pathStr = chain.join("->");
                    dashboard.onLoad[pathStr] = `${pathStr}->\${DATETIME(${action})}`;
                    var newConfig = dashboard.exportConfig();
                    // delete all the summaries which are indexed under this timeseries variable
                    newConfig.summaries = newConfig.summaries.filter((cfg) => {
                        var _a;
                        var attrib = dashboard.attribWithName(cfg.name);
                        if (!attrib)
                            return false;
                        if ((_a = attrib.block) === null || _a === void 0 ? void 0 : _a.inDashboard)
                            return true;
                        return pathStr !== attrib.template.pathStr;
                    });
                    dashboard = Base.reloadWithNewConfig(dashboard, newConfig);
                },
                options: [
                    { name: "YYYY", sampleValue: "2019", value: "%Y" },
                    { name: "YYYY-MM", sampleValue: "2019-12", value: "%Y-%m" },
                    {
                        name: "YYYY-MM-DD",
                        sampleValue: "2019-12-30",
                        value: "%Y-%m-%d",
                    },
                    {
                        name: "MM/DD/YYYY",
                        sampleValue: "12/30/2019",
                        value: "%m/%d/%Y",
                    },
                    { name: "MM/DD/YY", sampleValue: "12/30/16", value: "%m/%d/%y" },
                    {
                        name: "YYYY-MM-DD",
                        sampleValue: "2019-12-30",
                        value: "%Y-%m-%d",
                    },
                    { name: "<i>Custom</i>", value: "prompt()" },
                ],
            },
        ],
    },
    /** -- */
    Attribute: {
        name: "Settings",
        items: [
            // *************************
            {
                id: "renameAttrib",
                name: "Rename",
                iconClass: "far fa-pencil",
                helparticle: "5ea92f902c7d3a5ea54a1c35",
                when: (attrib) => !attrib.hasTimeSeriesParent(),
                do: (attrib) => {
                    var x = Modal.prompt("Please enter the new attribute name.", attrib.attribName);
                    if (x)
                        attrib.attribName = x;
                },
            },
            // *************************
            {
                id: "setDescription",
                name: "Set description",
                iconClass: "fa fa-info",
                helparticle: "5ea8b8dc2c7d3a5ea54a18ad",
                when: (attrib) => !attrib.hasTimeSeriesParent(),
                do: (attrib) => {
                    var x = Modal.prompt("Please enter a short description for this attribute.", attrib.description ? attrib.description : "");
                    if (x != null)
                        attrib.description = x;
                },
            },
            // ****************************
            {
                id: "setUnitName",
                name: "Set unit-name",
                iconClass: "far fa-ellipsis-h",
                helparticle: "5e88f31404286364bc97d467",
                when: (attrib) => (attrib.type === "timeseries" || attrib.type === "numeric") &&
                    !attrib.hasTimeSeriesParent(),
                do: (attrib) => {
                    var x = Modal.prompt("Please enter the unit name", attrib.unitName || "");
                    if (x != null)
                        attrib.unitName = x;
                },
            },
            {
                id: "convertDataType",
                name: "Convert data type",
                iconClass: "fa fa-wrench",
                options: [
                    // SPLIT CATEGORIES
                    {
                        id: "cat_splitCat",
                        name: "Multi-Cat. (Split by)",
                        iconClass: "far fa-tags",
                        helparticle: "5e88d4172c7d3a7e9aea63ac",
                        when: (attrib) => attrib instanceof Attrib_Categorical && !attrib.isMultiValued,
                        do: (attrib, action) => {
                            if (action === "prompt()") {
                                action = Modal.prompt("Enter split format");
                                if (!action)
                                    return;
                            }
                            attrib.browser.onLoad.main[attrib.template.str] = `SPLIT(${action})`;
                            window.dashboard = Base.reloadWithNewConfig(attrib.browser, attrib.browser.exportConfig());
                        },
                        options: [
                            {
                                name: "Space",
                                iconXML: "_",
                                value: "\\s+",
                                hint: "Any whitespace",
                            },
                            { name: "Comma", iconXML: ",", value: "\\s*,\\s*" },
                            { name: "Semicolumn", iconXML: ";", value: "\\s*;\\s*" },
                            { name: "Vertical-bar", iconXML: "|", value: "\\s*\\|\\s*" },
                            { name: "Plus", iconXML: "+", value: "\\s*\\+\\s*" },
                            { name: "Star", iconXML: "*", value: "\\s*\\*\\s*" },
                            { name: "Custom", iconXML: "?", value: "prompt()" },
                        ],
                    },
                    {
                        id: "convertToCategorical",
                        name: "Categorical",
                        iconClass: "fa fa-tag",
                        helparticle: "5e890d9104286364bc97d4ff",
                        when: (attrib) => attrib instanceof Attrib_Numeric && !attrib.timeseriesParent,
                        do: (attrib) => {
                            Modal.confirm(`Do you want to convert <i>${attrib.attribName}</i> to categorical data?`, "Convert").then(() => {
                                attrib.browser.onLoad.main[attrib.template.str] = "STR()";
                                var newConfig = attrib.browser.exportConfig();
                                newConfig.summaries
                                    .filter((s) => s.name === attrib.attribName)
                                    .forEach((s) => {
                                    s.type = "categorical";
                                });
                                if (newConfig.metric &&
                                    newConfig.metric.summary === attrib.attribName) {
                                    delete newConfig.metric;
                                }
                                window.dashboard = Base.reloadWithNewConfig(attrib.browser, newConfig);
                            }, () => { });
                        },
                    },
                    {
                        id: "num_convertToTimestamp",
                        name: "Timestamp",
                        iconClass: "far fa-calendar-alt",
                        helparticle: "5e88ec2c04286364bc97d44b",
                        when: (attrib) => attrib instanceof Attrib_Numeric && !attrib.timeseriesParent,
                        do: (attrib, action) => {
                            if (action === "prompt()") {
                                action = Modal.prompt("Enter datetime format, using https://github.com/d3/d3-time-format#locale_format");
                                if (!action)
                                    return;
                            }
                            attrib.browser.onLoad.main[attrib.template.str] = `DATETIME(${action})`;
                            var newConfig = attrib.browser.exportConfig();
                            newConfig.summaries
                                .filter((s) => s.name === attrib.attribName)
                                .forEach((s) => {
                                delete s.type;
                                delete s.showPercentiles;
                                delete s.skipZero;
                            });
                            window.dashboard = Base.reloadWithNewConfig(attrib.browser, newConfig);
                        },
                        options: [
                            {
                                name: "YYYY",
                                sampleValue: "2019",
                                value: "%Y"
                            },
                            {
                                name: "Serial/Sheet date",
                                sampleValue: "42010.2",
                                value: "%sn",
                            },
                            // seconds since UNIX epoch
                            {
                                name: "UNIX epoch-sec",
                                sampleValue: "1499310012",
                                value: "%s",
                            },
                            // milliseconds since UNIX epoch
                            {
                                name: "UNIX epoch-ms",
                                sampleValue: "1499310012000",
                                value: "%Q",
                            },
                            { name: "<i>Custom</i>", sampleValue: "?", value: "prompt()" },
                        ],
                    },
                    {
                        id: "cat_convertToTimestamp",
                        name: "Timestamp",
                        iconClass: "far fa-calendar",
                        helparticle: "5e88ec2304286364bc97d44a",
                        when: (attrib) => attrib instanceof Attrib_Categorical &&
                            !attrib.isMultiValued &&
                            !attrib.catGeo,
                        do: (attrib, action) => {
                            if (action === "prompt()") {
                                action = Modal.prompt("Enter datetime format, using https://github.com/d3/d3-time-format#locale_format");
                                if (!action)
                                    return;
                            }
                            attrib.browser.onLoad.main[attrib.template.str] = `DATETIME(${action})`;
                            var newConfig = attrib.browser.exportConfig();
                            // Existing summary will have a "categorical" type. delete the type...
                            newConfig.summaries
                                .filter((s) => s.name === attrib.attribName)
                                .forEach((c) => {
                                delete c.type;
                                delete c.catLabel;
                                delete c.catSortBy;
                                delete c.catGeo;
                                delete c.barHeight;
                                delete c.showSetMatrix;
                            });
                            window.dashboard = Base.reloadWithNewConfig(attrib.browser, newConfig);
                        },
                        options: [
                            {
                                name: "YYYY",
                                sampleValue: "2019",
                                value: "%Y"
                            },
                            {
                                name: "MM/DD/YYYY",
                                sampleValue: "12/30/2019",
                                value: "%m/%d/%Y",
                            },
                            {
                                name: "DD/MM/YYYY",
                                sampleValue: "30/12/2019",
                                value: "%d/%m/%Y",
                            },
                            {
                                name: "MM/DD/YY",
                                sampleValue: "12/30/16",
                                value: "%m/%d/%y",
                            },
                            {
                                name: "YYYY-MM-DD",
                                sampleValue: "2019-12-30",
                                value: "%Y-%m-%d",
                            },
                            {
                                name: "MM/DD/YYYY hh:mm",
                                sampleValue: "12/30/2019 13:10",
                                value: "%m/%d/%Y %H:%M",
                            },
                            {
                                name: "DD/MM/YYYY hh:mm",
                                sampleValue: "30/12/2019 13:10",
                                value: "%d/%m/%Y %H:%M",
                            },
                            {
                                name: "Date-Time-Z",
                                sampleValue: "2018-07-02T16:24:36Z",
                                value: "%Y-%m-%dT%H:%M:%S%Z",
                            },
                            { name: "<i>Custom</i>", value: "prompt()" },
                        ],
                    },
                ],
            },
            // ****************************
            // ADD MAP TO CATEGORY
            mapStandardsMenuOpts,
            // Extract single time key
            {
                id: "extractTimeKey",
                name: "Extract time key",
                iconClass: "far fa-calendar-day",
                when: (attrib) => attrib instanceof Attrib_Timeseries,
                options: (attrib) => attrib.timeKeys
                    .filter((timeKey) => !attrib.timeKeyAttribs[timeKey._time_src])
                    .map((timeKey) => ({ name: timeKey._time_src, value: timeKey })),
                do: (attrib, action) => {
                    var _ = attrib.getTimepointSummary(action);
                    _.block.addToPanel(attrib.browser.panels.left);
                    attrib.browser.updateLayout();
                },
            },
            // *************************************
            // DERIVE
            {
                id: "deriveMenuOpt",
                name: "Generate",
                iconClass: "fa fa-share",
                when: (attrib) => attrib.template.str,
                options: [
                    {
                        id: "deriveChangeOverTime",
                        name: "Change over time",
                        when: (attrib) => {
                            return (attrib instanceof Attrib_Timeseries &&
                                !attrib.parent &&
                                (!attrib.derivatives["TimeseriesChange-%"] ||
                                    !attrib.derivatives["TimeseriesChange-#"]));
                        },
                        do: (attrib, action) => {
                            attrib.createDerivedAttrib(`Change(${action})`, `${attrib.attribName} - ${action === "%" ? "Percent" : "Absolute"} Change`);
                        },
                        options: (attrib) => {
                            var r = [];
                            if (!attrib.derivatives["TimeseriesChange-%"]) {
                                r.push({ name: "% Percent change", value: "%" });
                            }
                            if (!attrib.derivatives["TimeseriesChange-#"]) {
                                r.push({ name: "# Absolute change", value: "#" });
                            }
                            return r;
                        },
                    },
                    {
                        id: "time_deriveComponent",
                        name: "Time unit",
                        iconClass: "far fa-calendar",
                        when: (attrib) => attrib instanceof Attrib_Timestamp,
                        do: (attrib, action) => attrib.createDerivedAttrib(action),
                        // and time-typed in selected resolution,
                        // and not have the specific derived summary
                        options: [
                            {
                                id: "time_deriveYear",
                                name: "Year",
                                when: (attrib) => attrib.timeTyped.year && !attrib.derivatives.Year,
                                value: "Year()",
                            },
                            {
                                id: "time_deriveMonth",
                                name: "Month",
                                when: (attrib) => attrib.timeTyped.month && !attrib.derivatives.Month,
                                value: "Month()",
                            },
                            {
                                id: "time_deriveDayOfMonth",
                                name: "Day of Month",
                                when: (attrib) => attrib.timeTyped.day && !attrib.derivatives.DayOfMonth,
                                value: "DayOfMonth()",
                            },
                            {
                                id: "time_deriveWeekday",
                                name: "Weekday",
                                when: (attrib) => attrib.timeTyped.day && !attrib.derivatives.WeekDay,
                                value: "WeekDay()",
                            },
                            {
                                id: "time_deriveHour",
                                name: "Hour",
                                when: (attrib) => attrib.timeTyped.hour && !attrib.derivatives.Hour,
                                value: "Hour()",
                            },
                        ],
                    },
                    {
                        id: "cat_deriveDegree",
                        name: "Degree (# of)",
                        iconClass: "far fa-hashtag",
                        when: (attrib) => attrib instanceof Attrib_Categorical && attrib.isMultiValued && !attrib.derivatives.Degree,
                        do: (attrib) => attrib.createDerivedAttrib("Degree()"),
                    },
                ],
            },
            // Positive
            {
                id: "num_keepPositive",
                name: "Keep positive (>0) values",
                iconClass: "fa fa-plus",
                when: (attrib) => attrib instanceof Attrib_Numeric &&
                    attrib.rangeOrg[0] <= 0,
                do: (attrib) => {
                    Modal.confirm(`Do you want to remove zero-values from <i>${attrib.attribName}</i>?`, "Remove").then(() => {
                        attrib.browser.onLoad.main[attrib.template.str] = "POSITIVE()";
                        window.dashboard = Base.reloadWithNewConfig(attrib.browser, attrib.browser.exportConfig());
                    }, () => { });
                },
            },
            // ****************************
            {
                id: "CompareSelectionControl",
                name: "Comparable",
                iconClass: "fa fa-clone",
                do: (attrib, action) => attrib.isComparable.set(action),
                options: [
                    {
                        name: "Enable",
                        value: true,
                        iconClass: "far fa-check",
                        active: (attrib) => attrib.isComparable.is(true),
                    },
                    {
                        name: "Disable",
                        value: false,
                        iconClass: "far fa-times",
                        active: (attrib) => !attrib.isComparable.is(true),
                    },
                ],
            },
            // ****************************
            {
                id: "aggregateFunctions",
                name: "Aggregation",
                iconClass: "fa fa-cubes",
                helparticle: "5e8944dd04286364bc97d5f0",
                when: (attrib) => attrib.canHaveMetricFuncs && !attrib.hasTimeSeriesParent(),
                options: [
                    {
                        name: "Average",
                        do: (attrib, action) => {
                            if (action) {
                                attrib.addSupportedMetricFunc("Avg");
                            }
                            else {
                                attrib.removeSupportedMetricFunc("Avg");
                            }
                        },
                        options: [
                            {
                                name: "Enabled",
                                value: true,
                                iconClass: "far fa-check",
                                active: (attrib) => attrib.supportedMetricFuncs.includes("Avg"),
                            },
                            {
                                name: "Disabled",
                                value: false,
                                iconClass: "far fa-times",
                                active: (attrib) => !attrib.supportedMetricFuncs.includes("Avg"),
                            },
                        ],
                    },
                    {
                        name: "Sum",
                        do: (attrib, action) => {
                            if (action) {
                                attrib.addSupportedMetricFunc("Sum");
                            }
                            else {
                                attrib.removeSupportedMetricFunc("Sum");
                            }
                        },
                        options: [
                            {
                                name: "Enabled",
                                value: true,
                                iconClass: "far fa-check",
                                active: (attrib) => attrib.supportedMetricFuncs.includes("Sum"),
                            },
                            {
                                name: "Disabled",
                                value: false,
                                iconClass: "far fa-times",
                                active: (attrib) => !attrib.supportedMetricFuncs.includes("Sum"),
                            },
                        ],
                    },
                ],
            },
            // Delete map modification
            {
                id: "removeMap",
                name: "Remove map",
                iconClass: "far fa-undo",
                when: (attrib) => attrib instanceof Attrib_Categorical && attrib.catGeo !== null,
                do: (attrib) => attrib.removeCatGeo(),
            },
            // Delete derivative
            {
                id: "removeDerive",
                name: "Remove derivation",
                iconClass: "far fa-undo",
                when: (attrib) => attrib.template.special,
                do: (attrib) => attrib.destroy(),
            },
            // Delete derived information
            {
                id: "removeRecordGeo",
                name: "Remove record geography",
                iconClass: "far fa-undo",
                when: (attrib) => attrib instanceof Attrib_RecordGeo,
                do: (attrib) => {
                    attrib.destroy();
                    window.dashboard = Base.reloadWithNewConfig(attrib.browser, attrib.browser.exportConfig());
                },
            },
            // Delete onLoad modification
            {
                id: "removeModification",
                name: "Remove modification",
                iconClass: "far fa-undo",
                when: (attrib) => !!attrib.browser.onLoad.main[attrib.template.str],
                do: (attrib) => {
                    var name = attrib.template.str;
                    Modal.confirm(`Do you want to delete the modification ${attrib.browser.onLoad.main[name]} ?`, i18n.Delete).then(() => {
                        delete attrib.browser.onLoad.main[name];
                        window.dashboard = Base.reloadWithNewConfig(attrib.browser, attrib.browser.exportConfig());
                    });
                },
            },
            {
                id: "setAsRecordID",
                name: "Set as record ID",
                iconClass: "far fa-fingerprint",
                when: (attrib) => {
                    if (attrib.attribName === attrib.browser.idSummaryName)
                        return false;
                    return (attrib._aggrs &&
                        attrib._aggrs.length === attrib.browser.records.length &&
                        !attrib.template.special);
                },
                do: (attrib) => {
                    if (!attrib.template.str) {
                        Modal.alert("Not supported. [756]");
                        return;
                    }
                    var newConfig = attrib.browser.exportConfig();
                    newConfig.source[0].id = attrib.template.str;
                    newConfig.summaries = newConfig.summaries.filter((s) => s.name !== attrib.browser.idSummaryName);
                    window.dashboard = Base.reloadWithNewConfig(attrib.browser, newConfig);
                },
            },
        ],
    },
};

const d3$2 = {
    select,
    pointer,
    min,
    max,
};
class Panel {
    hasBlocks() {
        return this.attribs.length > 0;
    }
    isEmpty() {
        return this.attribs.length === 0;
    }
    get blocks() {
        return this.attribs.map(attrib => attrib.block);
    }
    get attribs_Categorical() {
        // filter using typeguard
        return this.attribs.filter((attrib) => attrib instanceof Attrib_Categorical);
    }
    /** -- */
    constructor(browser, name, parentDOM) {
        // ********************************************************************
        // Attributes (/ blocks) in the panel
        // ********************************************************************
        this.attribs = [];
        this._width_CatBars = 0; // placeholder value
        this._width_CatMeasureLabel = 10; // placeholder values
        this._width_CatText = 175; // placeholder value
        // ********************************************************************
        // Updating layout
        // ********************************************************************
        this.heightRemaining = 0;
        // ********************************************************************
        // Synced scales
        // ********************************************************************
        this._syncedMeasureExtent = [0, 1]; // temp init value
        this.browser = browser;
        this._name = name;
        this.DOM = {
            root: parentDOM
                .append("div")
                .attr("class", "panel panel_" + this.name)
                .classed("panel_side", this.name === "left" || this.name === "right")
                .classed("hasBlocks", false),
        };
        this.initDOM_AdjustWidth();
        this.addDOM_DropZone();
        this.refreshBlocksDropZonesOrder();
        let targetWidth = this.browser.width_Canvas;
        if (this.name !== "bottom")
            targetWidth /= 3;
        this.setWidth(targetWidth);
    }
    get name() {
        return this._name;
    }
    /** -- If there's enough space, the panel welcomes new blocks */
    welcomesNewBlock() {
        return (this.isEmpty()
            || this.blocks.length < Math.floor(this.height / 150)
            || this.heightRemaining > 0);
    }
    /** -- */
    get width_CatText() {
        return this._width_CatText;
    }
    /** -- */
    get width_CatLabel() {
        return (this.width_CatText -
            (this.browser.stackedCompare.is(true) && !this.hiddenCatBars()
                ? 0
                : this.width_CatMeasureLabel));
    }
    /** -- */
    get width_CatMeasureLabel() {
        return this._width_CatMeasureLabel;
    }
    get width_Real_withGap() {
        if (this.width_Real === 0) {
            return 0;
        }
        if (this.name === "left" || this.name === "right") {
            return this.hasBlocks() ? this.width_Real + Base.width_PanelGap : 0;
        }
        return this.width_Real;
    }
    /** -- */
    get width_Real() {
        if (this.name === "middle") {
            return (this.browser.width_Canvas -
                this.browser.panels.left.width_Real_withGap -
                this.browser.panels.right.width_Real_withGap);
        }
        if (this.name === "bottom") {
            return this.browser.width_Canvas;
        }
        if (this.isEmpty()) {
            return 0;
        }
        if (this.isCollapsed()) {
            return this.DOM.root.node().offsetWidth;
        }
        return this.width_CatText + this.width_CatBars + Base.width_ScrollBar; // 8 pixels of gap
    }
    /** Adjusts width_CatBar based on previous size as well */
    set width_CatText(width) {
        width = Math.max(Base.width_CatLabelMin, width); // must be at least a specific min-value.
        if (width === this.width_CatText)
            return;
        let widthDif = this.width_CatText - width;
        this._width_CatText = width;
        this.attribs_Categorical.forEach(attrib => attrib.block.refreshLabelWidth());
        // updates category bar widths
        this.width_CatBars = this.width_CatBars + widthDif;
    }
    /** -- */
    get width_CatBars() {
        return this._width_CatBars;
    }
    /** -- */
    set width_CatBars(width) {
        width = Math.max(width, 0); // cannot be negative
        this._width_CatBars = width;
        this.DOM.root.classed("hideCatBars", this.hiddenCatBars() ? true : false);
        this.refreshWidth();
    }
    /** -- */
    setWidth(width) {
        this.width_CatBars = width - this.width_CatText - Base.width_ScrollBar;
    }
    /** --- */
    refreshWidth() {
        this.DOM.root.style("width", this.width_Real + "px");
        this.attribs.forEach(attrib => attrib.block.refreshWidth());
    }
    /** --- */
    updateWidth_CatMeasureLabels() {
        // even if width is the same, stacked/not-stacked may have changed
        this._width_CatMeasureLabel = this.calcWidth_MeasureLabel();
        this.attribs_Categorical.forEach(attrib => attrib.block.refreshLabelWidth());
    }
    /** -- */
    hiddenCatBars() {
        return this.width_CatBars <= 20;
    }
    /** -- */
    initDOM_AdjustWidth() {
        if (this.name === "middle" || this.name === "bottom") {
            return; // not supported
        }
        this.DOM.root
            .append("span")
            .attr("class", "panelAdjustWidth")
            .tooltip(i18n["Adjust Panel Width"])
            .on("mousedown", (event) => {
            if (event.which !== 1)
                return; // only respond to left-click
            var mouseDown_x = d3$2.pointer(event, document.body)[0];
            var mouseDown_width = this.width_CatBars;
            this.browser.activateWidthDrag(event.currentTarget, event, (event2) => {
                var mouseMove_x = d3$2.pointer(event2, document.body)[0];
                var mouseDif = mouseMove_x - mouseDown_x;
                if (this.name === "right")
                    mouseDif *= -1;
                this.width_CatBars = mouseDown_width + mouseDif;
                this.browser.updateMiddlePanelWidth();
                this.browser.updateLayout_Height();
            });
        })
            .on("click", (event) => {
            event.stopPropagation();
            event.preventDefault();
        });
    }
    /** --- */
    calcWidth_MeasureLabel() {
        var _a;
        if (this.isEmpty())
            return 0;
        var activeAggrMax, activeAggrMin;
        if (this.browser.percentBreakdown) {
            // 100 / %
            activeAggrMax = 99; // 2 digits
            activeAggrMin = 0; // 1 digit
        }
        else {
            activeAggrMax = d3$2.max(this.attribs, (_) => _.getPeakAggr(d3$2.max, "Active"));
            activeAggrMin = d3$2.max(this.attribs, (_) => _.getPeakAggr(d3$2.min, "Active"));
            if (activeAggrMax === 0 && activeAggrMin === 0)
                return 0;
        }
        var _w_ = 2;
        // compute number of digits
        var digits = 1;
        while (activeAggrMax > 9) {
            digits++;
            activeAggrMax = Math.floor(activeAggrMax / 10);
        }
        if (!this.browser.hasIntOnlyMeasure()) {
            digits += 2;
            _w_ += 8; // Space for ","
        }
        if (digits > 4) {
            digits = 3;
            _w_ += 3; // Space for the splitting "." character (e.q. 3.2k)
            _w_ += 10; // M, k, B, etc.
        }
        _w_ += digits * 6.5;
        if (this.browser.percentBreakdown) {
            if (Base.percentDecimal) {
                _w_ += 24; // "%" character + "." character + 1 significant digit
            }
            else {
                _w_ += 13; // "%" character + "." character + 1 significant digit
            }
        }
        else {
            // Account for the unitName displayed
            var unitName = (_a = this.browser.measureSummary.get()) === null || _a === void 0 ? void 0 : _a.unitName;
            if (unitName) {
                // TO-DO: Use the rendered width, instead of fixed multiplier, "11"
                _w_ += 2 + unitName.length * 7;
            }
        }
        // negative values have "-" character
        if (activeAggrMin < 0)
            _w_ += 5;
        return _w_;
    }
    // ********************************************************************
    // Add / remove blocks
    // ********************************************************************
    /** -- */
    addBlock(block, index) {
        block.panel = this;
        var beforeDOM = this.DOM.root.selectAll(".dropZone").nodes()[index];
        if (block.DOM.root && beforeDOM) {
            block.DOM.root.style("display", "");
            this.DOM.root.node().insertBefore(block.DOM.root.node(), beforeDOM);
        }
        else {
            if (!block.initDOM(beforeDOM))
                return;
        }
        this.DOM.root.classed("hasBlocks", true);
        var curIndex = -1;
        this.attribs.forEach((attrib, i) => {
            if (attrib.block === block)
                curIndex = i;
        });
        if (curIndex === -1) {
            // block is new to this panel
            if (index >= this.attribs.length)
                this.attribs.push(block.attrib);
            else
                this.attribs.splice(index, 0, block.attrib);
            this.updateWidth_CatMeasureLabels();
            if (block instanceof Block_Categorical) {
                block.refreshLabelWidth();
                if (block.viewType === "map") {
                    block.catViewAs("map"); // donno why this is needed for now.
                }
            }
            //
        }
        else {
            // block was in the panel. Change position
            this.attribs.splice(curIndex, 1);
            this.attribs.splice(index, 0, block.attrib);
        }
        if (this.attribs.length === 1)
            this.refreshWidth();
        this.refreshCollapsed();
        this.addDOM_DropZone(block.DOM.root.node());
        this.addRemove_Finalize();
    }
    /** -- */
    removeBlock(block) {
        block.panel = undefined;
        // remove the drop zone that this block created
        var dropZoneDOM = this.DOM.root.selectAll(".dropZone").nodes()[block.orderInPanel];
        dropZoneDOM.parentNode.removeChild(dropZoneDOM);
        this.attribs.splice(block.orderInPanel, 1);
        this.updateWidth_CatMeasureLabels();
        this.DOM.root.classed("hasBlocks", this.hasBlocks());
        if (!this.hasBlocks())
            this.refreshCollapsed();
        this.addRemove_Finalize();
    }
    addRemove_Finalize() {
        this.refreshBlocksDropZonesOrder();
        if (this.name === "bottom") {
            this.browser.DOM.panel_Wrapper.classed("panel_bottom_empty", !this.hasBlocks());
        }
        this.refreshSharedMeasureExtent();
        this.attribs.forEach(attrib => attrib.updateChartScale_Measure());
    }
    /** -- */
    refreshBlocksDropZonesOrder() {
        this.attribs.forEach((attrib, i) => {
            attrib.block.orderInPanel = i;
        });
        this.DOM.root.selectAll(".dropZone").each(function (_, i) {
            this.__data__ = i;
        });
    }
    /** Adds the dropZone DOM BEFORE the provided dom-- */
    addDOM_DropZone(beforeDOM = null) {
        let zone;
        if (beforeDOM) {
            zone = this.DOM.root.insert("div", () => beforeDOM); // must be a function returning a dom object...
        }
        else {
            zone = this.DOM.root.append("div");
        }
        zone
            .attr("class", "dropZone")
            .on("mouseenter", function () {
            this.classList.add("onHover");
            this.children[0].classList.add("onReadyToDrop");
        })
            .on("mouseleave", function () {
            this.classList.remove("onHover");
            this.children[0].classList.remove("onReadyToDrop");
        })
            .on("mouseup", (event) => {
            var attrib = this.browser.movedAttrib;
            if (!attrib)
                return;
            if (attrib.block.panel) {
                // if the block was in the panels already
                attrib.block.DOM.root.node().nextSibling.style.display = "";
                attrib.block.DOM.root.node().previousSibling.style.display = "";
            }
            attrib.block.addToPanel(this, event.currentTarget.__data__);
            this.browser.updateLayout();
        })
            .call((dropZone) => {
            dropZone.append("div").attr("class", "dropIcon fa fa-chart-bar");
            dropZone
                .append("div")
                .attr("class", "dropZoneText")
                .text(i18n["Drop Chart"]);
        });
    }
    /** -- */
    setHeightAndLayout(targetHeight) {
        this.height = targetHeight;
        this.heightRemaining = targetHeight;
        var finalPass = false, lastRound = false;
        // initialize all blocks as not yet processed.
        this.blocks.forEach((block) => {
            block.dueForLayout = true;
        });
        var dueBlockCount = this.attribs.length;
        var markDone = (block) => {
            if (!block.dueForLayout)
                return;
            this.heightRemaining -= block.height_withMargin;
            // see if the panel is on the bottom
            setTimeout(() => {
                var node = block.DOM.root.node();
                var top = node.getBoundingClientRect().top;
                var pos = "onBottom";
                if (top > 300) {
                    pos = "onTop";
                }
                if (top < 300 || this.width_Real < 400) {
                    if (this.name === "left") {
                        pos = "onRight";
                    }
                    else if (this.name === "right") {
                        pos = "onLeft";
                    }
                }
                block.DOM.root
                    .select(".summaryConfig")
                    .classed("onBottom", pos === "onBottom")
                    .classed("onTop", pos === "onTop")
                    .classed("onRight", pos === "onRight")
                    .classed("onLeft", pos === "onLeft");
            }, 1000);
            delete block.dueForLayout;
            dueBlockCount--;
        };
        this.blocks
            .filter((block) => !block.isVisible() || // Empty or collapsed
            block.hasStaticHeight())
            .forEach((block) => markDone(block));
        while (true) {
            if (dueBlockCount === 0)
                break;
            var dueBlockCount_Pre = dueBlockCount;
            // Distribute remaining space
            this.blocks
                .filter((block) => block.dueForLayout)
                .forEach((block) => {
                // in last round, if _block can expand, expand it further
                if (finalPass && block.attrib.type == "content") {
                    if (block.height_RangeMin < this.heightRemaining) {
                        block.setHeight(this.heightRemaining);
                    }
                    else {
                        block.setCollapsed(true);
                    }
                    markDone(block);
                    return;
                }
                if (lastRound === true) {
                    if (block.height_RangeMax > block.getHeight()) {
                        this.heightRemaining += block.getHeight();
                        block.setHeight(this.heightRemaining);
                        this.heightRemaining -= block.getHeight();
                        return;
                    }
                }
                if (dueBlockCount === 0)
                    return;
                // Fairly distribute remaining size across all remaining
                var _heightRemaining = Math.floor(this.heightRemaining / dueBlockCount);
                if (_heightRemaining >= block.height_RangeMax) {
                    // Panel has more space than what the block needs
                    block.setHeight(block.height_RangeMax);
                    markDone(block);
                }
                else if (finalPass) {
                    if (_heightRemaining >= block.height_RangeMin) {
                        // Use whatever space
                        block.setHeight(_heightRemaining);
                        markDone(block);
                    }
                    else {
                        // auto-collapse block if you do not have enough space
                        if (block.attrib.type !== "content") {
                            block.setCollapsed(true);
                            markDone(block);
                        }
                    }
                }
            });
            finalPass = dueBlockCount_Pre === dueBlockCount;
            if (lastRound === true)
                break;
            if (dueBlockCount === 0)
                lastRound = true;
        }
        if (this.name === "left" || this.name === "right") {
            this.refreshCollapsed();
        }
        if (this.name === "bottom" || this.name === "middle") {
            this.height = this.height - this.heightRemaining;
            this.heightRemaining = 0;
        }
        this.attribs.forEach((attrib, i) => {
            attrib.block.DOM.root.style("margin-bottom", i === this.attribs.length - 1 ? "0" : null);
        });
    }
    // ********************************************************************
    // Collapsing panel
    // ********************************************************************
    /** -- */
    collapseAllSummaries(except) {
        this.attribs.forEach(attrib => attrib.block.setCollapsed(attrib !== except));
        this.browser.updateLayout_Height();
    }
    /** -- */
    isCollapsed() {
        return this.hasBlocks() && this.attribs.every(attrib => attrib.block.collapsed);
    }
    /** -- */
    refreshCollapsed() {
        let _old = this.DOM.root.classed("collapsed");
        let _new = this.isCollapsed();
        this.DOM.root.classed("collapsed", _new);
        this.refreshWidth();
        if (_old !== _new) {
            this.browser.updateLayout();
        }
    }
    /** -- */
    refreshSharedMeasureExtent() {
        let scales = this.attribs
            .filter(attrib => (attrib instanceof Attrib_Categorical && attrib.block.isView_List) ||
            (attrib instanceof Attrib_Interval && attrib.block.showHistogram.is(true)))
            .map(attrib => attrib.measureExtent_Self);
        this._syncedMeasureExtent = [
            d3$2.min(scales, (range) => range[0]),
            d3$2.max(scales, (range) => range[1]),
        ];
    }
    /** -- */
    get syncedMeasureExtent() {
        return this._syncedMeasureExtent;
    }
    // ********************************************************************
    // Export / import
    // ********************************************************************
    /** -- */
    exportConfig() {
        return {
            catBarWidth: this.name !== "bottom" && this.width_CatBars,
            catLabelWidth: this.width_CatText,
        };
    }
    importConfig(config) {
        if (!config)
            return;
        if (config.catLabelWidth) {
            this.width_CatText = config.catLabelWidth;
        }
        if (config.catBarWidth && this.name !== "bottom") {
            this.width_CatBars = config.catBarWidth;
        }
    }
}

class DataLoader_FetchURL {
    accepts(dt) {
        return dt.fileExt;
    }
    // can be extended by sub-classes to customize http request headers
    defaultFetchConfig() {
        return {
            credentials: "same-origin",
            method: "GET",
        };
    }
    load(dt) {
        return __awaiter(this, void 0, void 0, function* () {
            // Lets Papaparse handle the streaming data loading
            if (dt.isCSV && dt.stream) {
                return dt.parseData_CSV(dt.sourceURL);
            }
            return fetch(dt.sourceURL, Object.assign({}, this.defaultFetchConfig(), dt.fetchConfig))
                .then((response) => response.text())
                .then((data) => {
                if (data.error) {
                    return Promise.reject(data.error);
                }
                return dt.parseData(data);
            });
        });
    }
}

class DataLoader_GoogleSheets {
    constructor() { }
    accepts(dt) {
        return dt.type === "GoogleSheets";
    }
    load(dt) {
        return __awaiter(this, void 0, void 0, function* () {
            yield import('https://apis.google.com/js/platform.js');
            var gapi = window.gapi;
            yield new Promise((resolve, reject) => {
                gapi.load("client", () => {
                    gapi.client
                        .init({
                        discoveryDocs: [
                            "https://sheets.googleapis.com/$discovery/rest?version=v4",
                            "https://www.googleapis.com/discovery/v1/apis/drive/v3/rest",
                        ],
                        apiKey: Base.gapi.gKey,
                        clientId: Base.gapi.clientId,
                        scope: 'profile email',
                    })
                        .then(() => {
                        console.log("✓ gapi.client.init");
                        resolve(true);
                    }, (error) => {
                        console.log(error);
                        reject();
                    });
                });
            });
            // Supporting custom data loading proxy
            gapi.client.setToken(null);
            return new Promise((resolve, reject) => {
                gapi.client.sheets.spreadsheets.values.get({
                    spreadsheetId: dt.gdocId,
                    range: dt.name + "!" + (dt.range ? dt.range : "1:300000"),
                    valueRenderOption: "UNFORMATTED_VALUE",
                    dateTimeRenderOption: "SERIAL_NUMBER", // vs. "FORMATTED_STRING"
                }).then((response) => {
                    if (!response.result && response.data) {
                        // node API returns a different structure
                        response.result = { values: response.data.data.values };
                    }
                    var header = response.result.values[0];
                    var hasIDcolumn = header.filter((columnName) => columnName === dt.id).length > 0;
                    for (var row = 1; row < response.result.values.length; row++) {
                        var c = {};
                        for (var col = 0; col < header.length; col++) {
                            c[header[col]] = response.result.values[row][col];
                        }
                        if (!hasIDcolumn)
                            c[dt.id] = "" + (row - 1);
                        dt.createRecord(c);
                    }
                    dt.processHeaderHierarchy(header);
                    resolve(true);
                }, (err) => {
                    reject(err);
                });
            });
        });
    }
}

// Static data loader
var DataLoaderRegistry = [];
/** -- */
class DataTable {
    getRecord(key) {
        return this._byKey[key];
    }
    get isLoaded() {
        return this._isLoaded;
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._isLoaded)
                return;
            if (this.onLoad) {
                this._isLoaded = this.onLoad();
                if (!this._isLoaded) {
                    return Promise.reject("Cannot load data via custom loader");
                }
                return;
            }
            // check loaders, and if loader accepts descriptor, try to load with the loader
            for (const loader of DataLoaderRegistry) {
                if (loader.accepts(this)) {
                    var result = yield loader.load(this);
                    if (result) {
                        if (this.postLoad) {
                            this.postLoad();
                        }
                        this._isLoaded = true;
                        return;
                    }
                }
            }
            return Promise.reject("Cannot find data loader");
        });
    }
    createRecord(_data) {
        var record = new Record(_data, this.id);
        this.records.push(record);
        this._byKey[record.id] = record;
    }
    /** -- */
    static registerLoader(loader) {
        DataLoaderRegistry.push(loader);
    }
    /** -- */
    constructor(dataDescr) {
        var _a;
        // ********************************************************************
        // Records
        // ********************************************************************
        this.records = [];
        this._byKey = {};
        // ********************************************************************
        // Loading data
        // ********************************************************************
        this.onLoad = null;
        this.postLoad = null;
        this._isLoaded = false;
        // CSV parsin settings with defaults
        this.header = true;
        this.fastMode = false;
        this.dynamicTyping = true;
        this.download = false;
        this.stream = false;
        if (dataDescr instanceof File) {
            this.type = "file";
            this.name = dataDescr.name;
            this.file = dataDescr;
            return;
        }
        if (typeof dataDescr === "string") {
            dataDescr = { name: dataDescr };
        }
        dataDescr = Object.assign({}, dataDescr);
        for (var x in dataDescr) {
            this[x] = dataDescr[x];
        }
        if (this.gdocId) {
            this.type = "GoogleSheets";
        }
        this.id = (_a = this.id) !== null && _a !== void 0 ? _a : "id";
        Base.tables.set(this.name, this);
    }
    get fileExt() {
        return this.fileType ? "." + this.fileType.toLowerCase() : "";
    }
    get isCSV() {
        return this.fileExt === ".csv" || this.fileExt === ".tsv";
    }
    get isGoogleFile() {
        return (this.dirPath === "GoogleDrive" ||
            this.dirPath === "https://drive.google.com/file/d/");
    }
    get sourceURL() {
        if (this.fullURL)
            return this.fullURL;
        if (this.isGoogleFile)
            return `https://www.googleapis.com/drive/v3/files/${this.name}?alt=media&key=${Base.gapi.gKey}`;
        return (this.dirPath || "") + this.name + this.fileExt;
    }
    get linkToData() {
        if (this.gdocId) {
            return "https://docs.google.com/spreadsheets/d/" + this.gdocId;
        }
        return this.sourceURL;
    }
    /** -- */
    parseData(rawData) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isCSV) {
                return yield this.parseData_CSV(rawData);
            }
            else {
                return yield this.parseData_JSON(rawData);
            }
        });
    }
    /** -- */
    parseData_JSON(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof data === "string") {
                data = JSON.parse(data);
            }
            var idColumn = this.id;
            data.forEach((_d, i) => {
                if (_d[idColumn] === undefined)
                    _d[idColumn] = "" + i;
                this.createRecord(_d);
            });
            return true;
        });
    }
    /** -- */
    parseData_CSV(data) {
        return __awaiter(this, void 0, void 0, function* () {
            let Papa = window.Papa;
            if (!Papa) {
                // Sets window.Papa / Not a proper ES6 module
                yield import('./papaparse.js');
                Papa = window.Papa;
            }
            return new Promise((resolve, reject) => {
                let _i = 0;
                Papa.parse(data, {
                    header: this.header === false ? false : true,
                    fastMode: this.fastMode !== undefined ? this.fastMode : false,
                    dynamicTyping: this.dynamicTyping !== undefined ? this.dynamicTyping : true,
                    download: this.stream === true,
                    chunk: (_rows) => {
                        _rows.data.forEach((row) => {
                            if (row[this.id] === undefined) {
                                row[this.id] = "" + _i++;
                            }
                            this.createRecord(row);
                        });
                    },
                    complete: () => {
                        this.processHeaderHierarchy();
                        resolve === null || resolve === void 0 ? void 0 : resolve(true);
                    },
                    error: (error) => {
                        console.log(error);
                        reject === null || reject === void 0 ? void 0 : reject("CSV parsing error.");
                    },
                });
            });
        });
    }
    /** Helper function to process column name header hierarchies (..->..->..) */
    processHeaderHierarchy(columns = null) {
        if (!columns) {
            columns = Object.keys(this.records[0].data);
        }
        columns.forEach((flatColName) => {
            if (typeof flatColName !== "string")
                return;
            var keys = flatColName.split("->");
            if (keys.length === 1) {
                return; // no hierarchy
            }
            keys = keys.map((_) => _.trim()); // trim keys
            var lastKey = keys.pop();
            this.records.forEach((rec) => {
                var _data = rec.data;
                var _value = _data[flatColName];
                if (_value != null) {
                    keys.forEach((key) => {
                        _data = _data[key] = _data[key] || {};
                    });
                    _data[lastKey] = _value;
                }
                delete rec.data[flatColName];
            });
        });
    }
}

class Block_Content extends Block {
    constructor(attrib) {
        super(attrib);
        // ********************************************************************
        // ********************************************************************
        this.height_content = 0;
        this.height_max = 10000;
        this.height_min = 100;
        // ********************************************************************
        // ********************************************************************
        this.curStep = -1;
        this.onStep = null;
    }
    hasStaticHeight() {
        return false;
    }
    get height_Content() {
        return this.isVisible() ? this.height_content : 0;
    }
    get height_RangeMin() {
        if (this.attrib.isEmpty())
            return this.height_Header;
        return this.height_min;
    }
    get height_RangeMax() {
        if (this.attrib.isEmpty())
            return this.height_Header;
        return this.height_max;
    }
    setHeight(targetHeight) {
        this.height_content =
            Math.min(targetHeight, this.height_max) - this.height_Header;
    }
    refreshWidth() { }
    /** -- */
    onCollapse() {
        if (this.collapsed)
            return;
        this.displayStep(0);
    }
    /** -- */
    initDOM(beforeDOM) {
        if (this.attrib.isEmpty())
            return false;
        if (this.DOM.inited)
            return true;
        this.insertRoot(beforeDOM);
        this.setCollapsed(this.collapsed);
        this.DOM.contentWrapper = this.DOM.wrapper
            .append("div")
            .attr("class", "contentWrapper");
        this.DOM.contentBlock = this.DOM.contentWrapper
            .append("div")
            .attr("class", "contentBlock");
        if (this.attrib.isMultiStep()) {
            var stepControls = this.DOM.contentWrapper
                .append("div")
                .attr("class", "stepControls");
            stepControls
                .append("div")
                .attr("class", "stepDots")
                .selectAll("div")
                .data([...Array(this.attrib.content.length).keys()])
                .enter()
                .append("div")
                .attr("class", "stepDot")
                .html("●")
                .tooltip(i18n["Jump to step"])
                .on("click", (_event, i) => this.displayStep(i));
            stepControls
                .append("div")
                .attr("class", "dismissButton")
                .html(i18n.Close)
                .on("click", () => this.setCollapsedAndLayout(true));
            stepControls.append("div").attr("class", "stepControlGap");
            this.DOM.stepPrev = stepControls
                .append("div")
                .attr("class", "stepButton stepPrev")
                .html("<i class='fa fa-angle-double-left'></i>" + i18n.Previous)
                .on("click", () => this.displayStep(this.curStep - 1));
            this.DOM.stepNext = stepControls
                .append("div")
                .attr("class", "stepButton stepNext")
                .html(i18n.Next + "<i class='fa fa-angle-double-right'></i>")
                .on("click", () => this.displayStep(this.curStep + 1));
            this.DOM.stepClose = stepControls
                .append("div")
                .attr("class", "stepButton stepClose")
                .html(i18n.Close + "<i class='fa fa-compress-alt'></i>")
                .on("click", () => this.setCollapsedAndLayout(true));
        }
        this.DOM.inited = true;
        this.displayStep(0);
        return true;
    }
    /** -- */
    displayStep(stepIndex) {
        if (!this.DOM.inited)
            return;
        if (this.attrib.content.length == 0)
            return;
        stepIndex = Math.min(Math.max(0, stepIndex), this.attrib.content.length - 1);
        if (this.curStep === stepIndex)
            return;
        this.curStep = stepIndex;
        var content = this.attrib.content[stepIndex];
        if (typeof content === "string") {
            this.DOM.contentBlock.html(content);
            this.DOM.contentWrapper.classed("fullIframe", false);
        }
        else if (content.youtube) {
            this.DOM.contentBlock.html(`<iframe ` +
                `src='https://www.youtube-nocookie.com/embed/${content.youtube}?controls=0` +
                `frameborder=0 allow="autoplay; encrypted-media; picture-in-picture"`);
            this.DOM.contentWrapper.classed("fullIframe", true);
        }
        if (this.onStep) {
            this.onStep.call(this);
        }
        this.DOM.contentBlock.node().scrollTop = 0;
        this.DOM.contentWrapper
            .classed("firstStep", this.curStep === 0)
            .classed("lastStep", this.curStep === this.attrib.content.length - 1);
        this.DOM.contentWrapper
            .selectAll(".stepDot")
            .classed("active", (i) => this.curStep === i);
    }
    refreshViz_Axis() {
    }
    refreshViz_Active() {
        return; // no action
    }
    refreshViz_Compare(cT, curGroup, totalGroups, prevCts) {
        return; // no action
    }
    chartAxis_Measure_TickSkip() {
        return; // no action
    }
    updateAfterFilter(refreshViz) {
        return; // no action
    }
}

/** -- */
class Attrib_Content extends Attrib {
    get block() {
        return this._block;
    }
    get content() {
        return this._content;
    }
    /** -- */
    constructor(browser, name) {
        super(browser, name, null, "content", "kshfBlock_Content", "fa fa-file-alt");
        /** -- */
        this._content = [];
        this._block = new Block_Content(this);
    }
    /** -- */
    isEmpty() {
        var _a;
        return !(((_a = this._content) === null || _a === void 0 ? void 0 : _a.length) > 0);
    }
    isMultiStep() {
        var _a;
        return ((_a = this._content) === null || _a === void 0 ? void 0 : _a.length) > 1;
    }
    /** -- */
    applyConfig(blockCfg) {
        const _super = Object.create(null, {
            applyConfig: { get: () => super.applyConfig }
        });
        return __awaiter(this, void 0, void 0, function* () {
            _super.applyConfig.call(this, blockCfg);
            this.setContent(blockCfg.content);
            this.block.height_max = blockCfg.maxHeight;
            this.block.height_min = blockCfg.minHeight;
            this.block.onStep = blockCfg.onStep;
        });
    }
    /** -- */
    setContent(v = []) {
        var _a;
        this._content = v;
        (_a = this.block) === null || _a === void 0 ? void 0 : _a.displayStep(0);
    }
    initializeAggregates() { }
    updateChartScale_Measure() { }
    get measureRangeMax() {
        throw new Error("Not supported");
    }
}

const d3$1 = {
    select,
    max,
    scaleLinear: linear,
};
class RecordDetailPopup {
    constructor(browser) {
        this.recordDetailAttribs = [];
        this.browser = browser;
        if (this.browser.options.recordDetailAttribs) {
            this.recordDetailAttribs = Array.from(this.browser.options.recordDetailAttribs);
        }
    }
    get DOM() {
        return this.browser.DOM;
    }
    initDOM() {
        var overlay_recordDetails = this.DOM.overlay_wrapper
            .append("div")
            .attr("class", "overlay_content overlay_recordDetails");
        overlay_recordDetails.append("div").attr("class", "overlay_Header");
        overlay_recordDetails
            .append("div")
            .attr("class", "overlay_Close fa fa-window-close")
            .tooltip(i18n.Close, { placement: "bottom" })
            .on("click", () => this.closeRecordDetailPanel());
        overlay_recordDetails
            .append("div")
            .attr("class", "filterOutRecord fa fa-filter")
            .tooltip(i18n["Filter out"], { placement: "bottom" })
            .on("click", () => {
            this.browser.recordDisplay.recordFilter.removeRecord(this.recordInDetail);
            this.DOM.overlay_wrapper.attr("show", "none");
        });
        this.DOM.overlay_recordDetails_content = overlay_recordDetails
            .append("div")
            .attr("class", "content");
    }
    /** -- */
    prepareRecordDetailColumns() {
        this.browser.attribs.forEach((attrib) => {
            if (attrib.hasTimeSeriesParent())
                return;
            if (attrib.attribName === "_Records")
                return;
            attrib.initializeAggregates();
            this.recordDetailAttribs.push(attrib.attribName);
        });
        this.recordDetailAttribs.sort((name1, name2) => {
            var s1 = this.browser.attribWithName(name1);
            var s2 = this.browser.attribWithName(name2);
            if (!s1)
                return -1;
            if (!s2)
                return 1;
            var diff = Util.getAttribTypeOrder(s1.type) - Util.getAttribTypeOrder(s2.type);
            return diff
                ? diff
                : Util.sortFunc_List_String(s1.attribName, s2.attribName);
        });
    }
    /** -- */
    updateRecordDetailPanel_Header(record) {
        var idSummary = this.browser.attribWithName(this.browser.idSummaryName);
        idSummary.initializeAggregates();
        var overlay_Header = this.DOM.overlay_wrapper.select(".overlay_recordDetails > .overlay_Header");
        overlay_Header.html("");
        overlay_Header
            .append("span")
            .attr("class", "idSummaryName")
            .html(idSummary.attribName);
        var disableRecordSelectBox = this.browser.records.length >= 2500;
        var _ = overlay_Header
            .append("span")
            .attr("class", "idContentWrapper")
            .classed("disabled", disableRecordSelectBox);
        _.append("span")
            .attr("class", "theText")
            .html(idSummary.getRecordValue(record));
        if (!disableRecordSelectBox) {
            _.append("select").on("change", (event) => {
                this.updateRecordDetailPanel(event.currentTarget.selectedOptions[0].__data__[0]);
            });
            _.select("select").selectAll("option").remove();
            _.select("select")
                .selectAll("option")
                .data(this.browser.records
                .map((r) => [r, idSummary.getRecordValue(r)])
                .sort((a, b) => Util.sortFunc_List_String(a[1], b[1])))
                .enter()
                .append("option")
                .attr("selected", (r) => (r[0].id === record.id ? true : null))
                .html((r) => r[1]);
        }
    }
    /** -- */
    closeRecordDetailPanel() {
        var _a;
        if (!this.recordInDetail)
            return;
        this.recordInDetail = null;
        (_a = this.browser.options.onRecordClose) === null || _a === void 0 ? void 0 : _a.call(this);
        this.DOM.overlay_wrapper.attr("show", "none");
    }
    /** -- */
    updateRecordDetailPanel(record) {
        var _a;
        if (record == null) {
            this.closeRecordDetailPanel();
            return;
        }
        this.recordInDetail = record;
        this.DOM.overlay_wrapper
            .attr("show", "recordDetails")
            .classed("easyDismiss", true);
        this.updateRecordDetailPanel_Header(record);
        if (this.browser.options.onRecordView) {
            this.DOM.overlay_recordDetails_content.html(this.browser.options.onRecordView.call(record.data, record));
            return;
        }
        if (this.recordDetailAttribs.length === 0) {
            this.prepareRecordDetailColumns();
        }
        // extend the "hidden" list based on what this record also contains
        this.recordDetailAttribs_Hidden = [];
        this.browser.attribs.forEach((attrib) => {
            attrib.initializeAggregates();
            if (attrib.hasTimeSeriesParent())
                return;
            if (this.recordDetailAttribs.indexOf(attrib.attribName) >= 0)
                return;
            if (attrib.getRecordValue(record) == null)
                return;
            this.recordDetailAttribs_Hidden.push(attrib.attribName);
        });
        var menuOpt = {
            name: "Edit order",
            items: [
                {
                    name: "▲ Move up",
                    do: (summary) => {
                        var movedSummaryName = summary.summaryName;
                        var _i = this.recordDetailAttribs.indexOf(movedSummaryName);
                        if (_i == -1 || _i === 0)
                            return;
                        this.recordDetailAttribs.splice(_i, 1);
                        this.recordDetailAttribs.splice(_i - 1, 0, movedSummaryName);
                        this.updateRecordDetailPanel(record);
                    },
                },
                {
                    name: "▼ Move down",
                    do: (summary) => {
                        var movedSummaryName = summary.summaryName;
                        var _i = this.recordDetailAttribs.indexOf(movedSummaryName);
                        if (_i == -1 || _i === this.recordDetailAttribs.length - 1)
                            return;
                        this.recordDetailAttribs.splice(_i, 1);
                        this.recordDetailAttribs.splice(_i + 1, 0, movedSummaryName);
                        this.updateRecordDetailPanel(record);
                    },
                },
                {
                    name: "Remove",
                    iconClass: "fa fa-minus-square",
                    do: (a) => {
                        this.recordDetailAttribs = this.recordDetailAttribs.filter((c) => c !== a.attribName);
                        this.updateRecordDetailPanel(record);
                    },
                },
                {
                    name: "Add below",
                    iconClass: "fa fa-plus-square",
                    when: () => this.recordDetailAttribs_Hidden.length > 0,
                    do: (selectedSummary, summaryNameToAdd) => {
                        // add to visible list
                        var pos = this.recordDetailAttribs.indexOf(selectedSummary.attribName);
                        if (pos === -1)
                            return;
                        this.recordDetailAttribs.splice(pos + 1, 0, summaryNameToAdd);
                        // remove from hidden list
                        this.recordDetailAttribs_Hidden =
                            this.recordDetailAttribs_Hidden.filter((hc) => hc !== summaryNameToAdd);
                        this.updateRecordDetailPanel(record);
                    },
                    options: this.recordDetailAttribs_Hidden.map((c) => ({
                        name: c,
                        value: c,
                    })),
                },
            ],
        };
        // create the hierarchical outline!
        var outline = {
            _basic: [],
            _timeseries: [],
        };
        this.recordDetailAttribs.forEach((attribName) => {
            if (attribName === this.browser.idSummaryName)
                return;
            var attrib = this.browser.attribWithName(attribName);
            if (!attrib)
                return;
            var v = attrib.getRecordValue(record);
            if (v == null)
                return;
            if (v.length === 0)
                return;
            var _outline = attrib.type === "timeseries" ? outline._timeseries : outline._basic;
            attrib.pathName.forEach((path) => {
                if (!_outline.some((item) => {
                    if (item instanceof Attrib)
                        return false;
                    if (item.path === path) {
                        _outline = item.items;
                        return true;
                    }
                    return false;
                })) {
                    // path not found
                    var _ = {
                        path: path,
                        items: [],
                    };
                    _outline.push(_);
                    _outline = _.items;
                }
            });
            _outline.push(attrib);
        });
        // if a summary has a printName same as its last path name, move it under to last path
        ["_basic", "_timeseries"].forEach((p) => {
            var proc = (_outline) => _outline.filter((item) => {
                if (item.path) {
                    item.items = proc(item.items);
                    return true;
                }
                return !_outline.some((item2, i) => {
                    if (item2 instanceof Attrib)
                        return false;
                    if (item2.path === item.printName) {
                        item2.items.unshift(item);
                        return true;
                    }
                    return false;
                });
            });
            outline[p] = proc(outline[p]);
        });
        var getMaxDepth = (_outline) => _outline.reduce((accum, item) => {
            return !item.path
                ? accum
                : 1 + d3$1.max(item.items, (_) => (_.items ? getMaxDepth(_.items) : 1));
        }, 0);
        var maxDepth = getMaxDepth(outline._timeseries);
        // removes any content that was here previously.
        this.DOM.overlay_recordDetails_content.html("");
        var _table = this.DOM.overlay_recordDetails_content
            .append("table")
            .attr("class", "recordAttribTable");
        var renderRecordValues = (tbody, items, prevPath) => {
            var rowsDOM = tbody
                .selectAll("tr.nonexistent")
                .data(items)
                .enter()
                .append("tr");
            var lastPath = prevPath[prevPath.length - 1] || "";
            var addHWrapper = (_td) => {
                _td
                    .append("div")
                    .attr("class", "attribHierarchyWrapper")
                    .call((_div) => {
                    _div
                        .filter((s) => !s.printName || s.printName === lastPath)
                        .append("span")
                        .attr("class", "hrchyItem collapseArrow")
                        .on("click", () => _td.node().parentNode.parentNode.classList.toggle("collapsed"))
                        .append("span")
                        .attr("class", "fa fa-caret-down")
                        .tooltip("Show/Hide components");
                    _div
                        .selectAll("span.extendLine")
                        .data((s) => Array.from(prevPath).filter((_) => _ != s.printName))
                        .enter()
                        .append("span")
                        .attr("class", "hrchyItem extendLine");
                });
            };
            var addRecAttribName = (_tr) => {
                _tr
                    .append("td")
                    .attr("class", "recAttribName")
                    .call((recAttribName) => {
                    recAttribName
                        .filter((attrib) => attrib.description)
                        .append("span")
                        .attr("class", "summaryDescription far fa-info-circle")
                        .tooltip((_) => _.description, { placement: "bottom" });
                    recAttribName
                        .append("span")
                        .attr("class", "TheName")
                        .style("font-size", Math.pow(1.1, maxDepth - prevPath.length) + "em")
                        .html((attrib) => attrib.printName.trim()); //+("<i class='fa fa-level-up'></i>").repeat(prevPath.length));
                    recAttribName
                        .append("span")
                        .attr("class", "modifyAttribPos fa fa-bars")
                        .on("click", (event, attrib) => Modal.popupMenu(event, menuOpt, attrib));
                    addHWrapper(recAttribName);
                });
            };
            rowsDOM
                .filter((_) => !(_ instanceof Attrib_Timeseries))
                .attr("class", "attribRow basicAttrib")
                .classed("groupTitle", (s) => s.printName === lastPath)
                .attr("summaryID", (s) => s.attribID)
                .each((attrib, i, nodes) => {
                if (!(attrib instanceof Attrib))
                    return;
                var _tr = d3$1.select(nodes[i]);
                attrib.initializeAggregates();
                addRecAttribName(_tr);
                var _recAttribVal = _tr
                    .append("td")
                    .attr("class", "recAttribVal")
                    .attr("colspan", 5);
                attrib.renderRecordValue(record, _recAttribVal);
            });
            rowsDOM
                .filter((_) => _ instanceof Attrib_Timeseries)
                .attr("class", "attribRow timeseriesAttrib")
                .classed("groupTitle", (s) => s.printName === lastPath)
                .attr("summaryID", (s) => s.attribID)
                .call((_tr) => {
                addRecAttribName(_tr);
                _tr
                    .append("td")
                    .attr("class", "recTimeKeyValue")
                    .call((td) => {
                    td.append("div").attr("class", "ValueText");
                    td.filter((s) => s.isComparable.val)
                        .append("div")
                        .attr("class", "ValueBar")
                        .append("div")
                        .attr("class", "TheBar");
                });
                _tr
                    .append("td")
                    .attr("class", "recTimeKeyChange")
                    .tooltip("", { placement: "bottom" })
                    .html("<i class='fa fa-angle-right'></i>");
                _tr.append("td").attr("class", "recTimeKeyRank");
                _tr
                    .append("td")
                    .attr("class", "recAttribVal")
                    .each((attrib, i, nodes) => {
                    attrib.renderRecordValue(record, d3$1.select(nodes[i]), this.recordDetailTimeKeys);
                });
            });
            rowsDOM
                .filter((_) => !(_ instanceof Attrib))
                .attr("class", "groupedTableWrapper")
                .append("td")
                .append("table")
                .append("tbody")
                .attr("class", "groupedTable collapsed")
                .each((_item, i, nodes) => {
                var _tbody = d3$1.select(nodes[i]);
                if (_item.items[0].printName !== _item.path) {
                    var _tr = _tbody.append("tr").attr("class", "groupTitle");
                    _tr
                        .append("td")
                        .attr("class", "recAttribName")
                        .call((groupName) => {
                        groupName
                            .append("span")
                            .attr("class", "TheName")
                            .style("font-size", Math.pow(1.1, maxDepth - prevPath.length) + "em")
                            .on("click", () => _tbody.node().classList.toggle("collapsed"))
                            .html(_item.path.trim());
                        addHWrapper(groupName);
                    });
                    _tr.append("td").attr("class", "groupNameGap");
                }
                renderRecordValues(_tbody, _item.items, prevPath.concat([_item.path]));
                //_tbody.append("tr").attr("class","groupCloseRow").append("td");
            });
        };
        renderRecordValues(_table.append("tbody").attr("class", "basicAttribs"), outline._basic, []);
        if (outline._timeseries.length > 0) {
            _table
                .append("tr")
                .style("height", "0.5em")
                .style("grid-column", "1 / span 5");
            var _tbody = _table.append("tbody").attr("class", "timeseriesAttribs");
            this.recordDetailTimeKeys = record.getTimeKeys();
            this.browser.recordDisplay.config.timeseriesWidth = Math.min((this.recordDetailTimeKeys.length - 1) * 70, 400);
            var _tr = _tbody.append("tr");
            _tr.append("td");
            var timeKeySelect = _tr
                .append("td")
                .attr("colspan", 3)
                .attr("class", "timeKeySelect");
            timeKeySelect
                .append("i")
                .attr("class", "prevTimeKey fa fa-caret-left")
                .tooltip(i18n.Previous)
                .on("click", () => this.updateFocusedTimeKey(this.timeKey_Step("previous")));
            timeKeySelect
                .append("select")
                .on("change", (event) => this.updateFocusedTimeKey(event.currentTarget.selectedOptions[0].__data__))
                .selectAll("option")
                .data(this.recordDetailTimeKeys, (x) => x._time)
                .enter()
                .append("option")
                .text((k) => k._time_src);
            timeKeySelect
                .append("i")
                .attr("class", "nextTimeKey fa fa-caret-right")
                .tooltip(i18n.Next)
                .on("click", () => this.updateFocusedTimeKey(this.timeKey_Step("next")));
            _tr.append("td").attr("class", "timeseriesEditView");
            var _tr = _tbody.append("tr").attr("class", "columnHead");
            _tr.append("td");
            _tr.append("td").attr("class", "columnHead_Value").text("Value");
            _tr.append("td").attr("class", "columnHead_Change").text("Change");
            _tr.append("td").attr("class", "columnHead_Rank").text("Rank");
            _tr
                .append("td")
                .attr("class", "columnHead_TimeTrends")
                .text("Time Trends");
            renderRecordValues(_tbody, outline._timeseries, []);
            this.updateFocusedTimeKey(this.recordDetailTimeKeys[0]);
        }
        // Some Keshif projects use this to inject some code after main record display view.
        (_a = this.browser["updateRecordDetailPanel_custom"]) === null || _a === void 0 ? void 0 : _a.call(this, record);
    }
    /** -- */
    updateFocusedTimeKey(timeKey) {
        var _a;
        if (!this.recordInDetail || !timeKey)
            return;
        var _time_src = timeKey._time_src;
        var timeKeyPos = this.getTimeKey_Index(timeKey);
        if (timeKeyPos < 0)
            return; // cannot find the timeKey within the record
        this.timeKeyInDetail = timeKey;
        var prevTimeKey = timeKeyPos >= this.recordDetailTimeKeys.length - 1
            ? null
            : this.recordDetailTimeKeys[timeKeyPos + 1];
        d3$1.select(".timeKeySelect > .nextTimeKey").classed("active", timeKeyPos !== 0);
        d3$1.select(".timeKeySelect > .prevTimeKey").classed("active", timeKeyPos !== this.recordDetailTimeKeys.length - 1);
        var _table = this.DOM.overlay_recordDetails_content.select("table.recordAttribTable");
        _table
            .selectAll(".timeseriesAttribs tr:first-child > td > select > option")
            .data([timeKey], (x) => x._time)
            .node().selected = true;
        _table
            .selectAll(".timeseriesAttribs .recTimeKeyValue")
            .each((attrib) => attrib.computeRecordRanks());
        _table
            .selectAll(".timeseriesAttribs .recTimeKeyValue > .ValueText")
            .html((attrib) => {
            var ts = attrib.getRecordValue(this.recordInDetail);
            if (!ts)
                return "-";
            let v = ts._keyIndex[_time_src];
            if (!v)
                return "-";
            return attrib.getFormattedValue(v._value);
        });
        var clampScale = d3$1
            .scaleLinear()
            .domain([0, 100])
            .range([0, 100])
            .clamp(true);
        _table
            .selectAll(".timeseriesAttribs .recTimeKeyValue > .ValueBar > .TheBar")
            .style("width", (attrib) => {
            var ts = attrib.getRecordValue(this.recordInDetail);
            if (!ts)
                return null;
            var v = ts._keyIndex[_time_src];
            if (!v)
                return null;
            if (attrib.unitName === "%") {
                // value is measured in percentage anyway, and width is percentage of the box!
                return clampScale(v._value) + "%";
            }
            return clampScale(attrib.timeSeriesScale_Value(v._value) * 100) + "%"; // cannot exceed 100%
        });
        _table
            .selectAll(".timeseriesAttribs .recTimeKeyChange")
            .attr("data-status", (attrib, i, nodes) => {
            nodes[i];
            var diff = null, _title = "-", status = "noValue";
            var ts = attrib.getRecordValue(this.recordInDetail);
            if (!ts || ts.isEmpty()) {
                nodes[i].tippy.setContent("No data");
                return "";
            }
            if (prevTimeKey) {
                var prev = ts._keyIndex[prevTimeKey._time_src];
                var cur = ts._keyIndex[_time_src];
                if (prev && cur)
                    diff = cur._value - prev._value;
                if (attrib.hasFlippedDomain())
                    diff *= -1; // flip
            }
            if (diff !== null) {
                let domain = attrib.timeSeriesScale_Value.domain();
                let threshold = Math.abs(domain[1] - domain[0]) / 50; // 1/50th of the range is the signal of change
                // TODO: make this a parameter
                if (diff > threshold) {
                    status = "improve";
                }
                else if (diff < -threshold) {
                    status = "decline";
                }
                else {
                    status = "steady";
                }
                _title =
                    `<b>Change from<br>${prevTimeKey._time_src} to ${_time_src}</b>:<br>` +
                        attrib.getFormattedValue(diff);
            }
            nodes[i].tippy.setContent(_title);
            return status;
        });
        _table
            .selectAll(".timeseriesAttribs .recTimeKeyRank")
            .html((attrib, i, nodes) => {
            var DOM = nodes[i];
            DOM.__NumRecords = 0;
            var ts = attrib.getRecordValue(this.recordInDetail);
            if (!ts || ts.isEmpty())
                return "-";
            let v = ts._keyIndex[_time_src];
            if (!v || v._rank == 0)
                return "-";
            DOM.__NumRecords = this.browser.records.reduce((accumulator, rec) => {
                if (rec.filteredOut)
                    return accumulator;
                var ts = attrib.getRecordValue(rec);
                if (!ts || ts.isEmpty())
                    return accumulator;
                let _val = ts._keyIndex[_time_src];
                if (_val == null)
                    return accumulator;
                return accumulator + 1;
            }, 0);
            return `<span class='rankValue'>${v._rank}</span><span class='rankOutOf'>${DOM.__NumRecords}</span>`;
        })
            .tooltip("")
            .on("mouseover", (event) => {
            var DOM = event.currentTarget;
            // TODO: consider only records that have valid values
            // need to process per each row/attribute -
            // of the ones that are active, do not consider those that do not have a value for the
            DOM.tippy.setContent("Ranking among " +
                DOM.__NumRecords +
                (this.browser.isFiltered() ? " filtered " : " ") +
                this.browser.recordName);
        });
        var DOMdots = _table.selectAll(".recordTimeseriesDot");
        var refreshedCurrentKeyClass = (altKey) => {
            DOMdots.classed("currentKey", (d) => d._time.getTime() === altKey._time.getTime());
        };
        _table
            .selectAll(".recordTimeseriesDot")
            .classed("currentKey", (d) => d._time.getTime() === timeKey._time.getTime())
            .on("mouseover", (_event, x) => refreshedCurrentKeyClass(x))
            .on("mouseout", () => refreshedCurrentKeyClass(timeKey));
        refreshedCurrentKeyClass(timeKey);
        // Another project-specific customization that should be in the core in a different way
        (_a = this["updateFocusedTimeKey_custom"]) === null || _a === void 0 ? void 0 : _a.call(this);
    }
    getTimeKey_Index(timeKey) {
        return this.recordDetailTimeKeys.findIndex((tK) => tK._time.getTime() == timeKey._time.getTime());
    }
    /** next or previous */
    timeKey_Step(sequence) {
        if (!(sequence === "next" || sequence === "previous"))
            return null;
        var timeKeyPos = this.getTimeKey_Index(this.timeKeyInDetail);
        if (timeKeyPos < 0)
            return null;
        return (this.recordDetailTimeKeys[timeKeyPos + (sequence === "next" ? -1 : 1)] ||
            null);
    }
    exportConfig() {
        var _a;
        return {
            recordInDetail: (_a = this.recordInDetail) === null || _a === void 0 ? void 0 : _a.id,
            recordDetailAttribs: this.recordDetailAttribs
                ? Array.from(this.recordDetailAttribs)
                : undefined,
        };
    }
}

const d3 = Object.assign({ select,
    pointer,
    rgb,
    max,
    scaleLinear: linear }, d3Chromatic);
/**
    Detected transformations:
    > STR
    > JSON
    > POSITIVE
    > DATETIME
    > DELETE
    > LAT_LONG(lat,long)
    > MULTIVAL(a;b;c;d;...)
    > ${DATETIME}
    > SPLIT
   */
function applyPreProc(_key, _transform, recordList) {
    var keySequence = _key.split("->");
    var keyIndex = keySequence[keySequence.length - 1];
    var keyHostFunc = (v) => {
        for (var i = 0; i < keySequence.length - 1; i++) {
            v = v[keySequence[i]];
            if (v == null)
                return;
        }
        return v;
    };
    if (_transform === "DELETE()") {
        recordList.forEach((r) => {
            var host = keyHostFunc(r.data);
            if (host)
                delete host[keyIndex];
        });
        return;
    }
    let transformFunc = null;
    /* jshint ignore:start */
    const isTimeseries = RegExp(/(.+)->\$\{(.+)\}/).exec(_transform);
    const isDateTime = RegExp("DATETIME\\((.+)\\)").exec(_transform);
    const isMultiVal = RegExp("MULTIVAL\\((.+)\\)").exec(_transform);
    const isSplit = RegExp("SPLIT\\((.+)\\)").exec(_transform);
    const isLatLong = RegExp("LAT_LONG\\((.+),(.+)\\)").exec(_transform);
    /* jshint ignore:end */
    if (_transform === "STR()") {
        // convert value to string
        transformFunc = (v) => (v == null ? null : "" + v);
        //
    }
    else if (_transform === "JSON()") {
        // parse value as JSON string
        transformFunc = (v) => (v == null ? null : JSON.parse(v));
        //
    }
    else if (_transform === "POSITIVE()") {
        // keep only positive values
        transformFunc = (v) => (v && typeof v === "number" && v > 0 ? v : null);
        //
    }
    else if (!isTimeseries && isDateTime && isDateTime.length > 1) {
        // parse the date given a string
        var _timeParse = Util.getTimeParseFunc(isDateTime[1]);
        transformFunc = (v) => (v == null ? null : _timeParse(v));
        //
    }
    else if (isSplit && isSplit.length > 1) {
        // split values in a string into multiple string
        var splitExpr = RegExp(isSplit[1]);
        transformFunc = (v) => {
            if (v == null)
                return null;
            if (typeof v === "number") {
                return ["" + v];
            }
            if (Array.isArray(v)) {
                if (v.length === 1) {
                    v = v[0]; // try to split the first/only element
                }
                else {
                    return v;
                }
            }
            // split, trim and cleanup
            return v
                .split(splitExpr)
                .map((x) => x.trim())
                .filter((x) => x !== "");
        };
    }
    else if (isMultiVal && isMultiVal.length > 1) {
        // merge data from multiple columns
        const colNames = isMultiVal[1]
            .split(RegExp("\\s*;\\s*"))
            .map((x) => x.trim())
            .filter((x) => x !== "");
        if (colNames.length >= 2) {
            transformFunc = (v, r) => {
                let _return = [];
                colNames.forEach((c) => {
                    if (r[c]) {
                        _return.push(r[c]);
                        delete r[c];
                    }
                });
                return _return;
            };
        }
    }
    else if (isTimeseries && isTimeseries.length > 1) {
        // prepare timeseries structure
        var _isDateTime = RegExp("DATETIME\\((.+)\\)").exec(isTimeseries[2]);
        if ((_isDateTime === null || _isDateTime === void 0 ? void 0 : _isDateTime.length) > 1) {
            var __timeParse = Util.getTimeParseFunc(_isDateTime[1]);
            var valueKey = null;
            var hasValueKey = RegExp("::(.+)").exec(isTimeseries[2]);
            if (hasValueKey && hasValueKey.length > 1) {
                valueKey = hasValueKey[1];
            }
            transformFunc = (v) => {
                if (v == null)
                    return null;
                let _ts = new TimeSeriesData();
                for (var timeKey in v) {
                    var _value = v[timeKey];
                    if (typeof _value !== "number") {
                        continue; // Must be numeric value
                    }
                    var _time = __timeParse(timeKey.trim());
                    if (_time == null) {
                        continue; // cannot parse the string key to date object
                    }
                    _ts.addTimeData({
                        _time: _time,
                        _time_src: timeKey,
                        _value: valueKey ? _value[valueKey] : _value,
                    });
                }
                // merge timeseries data with object
                return _ts;
            };
        }
    }
    if (transformFunc) {
        recordList.forEach((r) => {
            let host = keyHostFunc(r.data);
            if (host == null)
                return;
            try {
                host[keyIndex] = transformFunc(host[keyIndex], r.data);
            }
            catch (e) {
                console.log("onLoad _transform error: " + e);
            }
        });
        return;
    }
    if (isLatLong && isLatLong.length > 1) {
        const latAttrib = isLatLong[1];
        const lonAttrib = isLatLong[2];
        recordList.forEach((r) => {
            var host = keyHostFunc(r.data);
            if (!host)
                return;
            var _lat = r.data[latAttrib];
            var _lng = r.data[lonAttrib];
            if (_lat &&
                _lng &&
                typeof _lat === "number" &&
                typeof _lng === "number") {
                host[keyIndex] = {
                    type: "Point",
                    coordinates: [_lng, _lat],
                };
            }
            delete r.data[latAttrib];
            delete r.data[lonAttrib];
        });
        return;
    }
}
class Browser {
    get attribsInDashboard() {
        return this.attribs.filter((attrib) => { var _a; return (_a = attrib.block) === null || _a === void 0 ? void 0 : _a.inDashboard; });
    }
    // always in dashboard
    get blocks() {
        return this.attribsInDashboard.map((attrib) => attrib.block);
    }
    // query by attribute name
    attribWithName(name) {
        return this.attribs.find((attrib) => { var _a; return name === (attrib === null || attrib === void 0 ? void 0 : attrib.attribName) || name === ((_a = attrib === null || attrib === void 0 ? void 0 : attrib.template) === null || _a === void 0 ? void 0 : _a.str); }) || null;
    }
    get _attribs() {
        var r = {};
        this.attribs.forEach((attrib) => {
            r[attrib.attribName] = attrib;
            if (attrib.template.str) {
                r[attrib.template.str] = attrib;
            }
        });
        return r;
    }
    constructor(options) {
        this.records = [];
        this.recordName = "";
        this.idSummaryName = null;
        this.primaryTableName = null;
        this.recordDisplay = null;
        this.allRecordsAggr = null;
        this.allAggregates = [];
        this.configs = {};
        this.DOM = {};
        this.panels = {};
        this.flexAggrs = {};
        this.addedCompare = false;
        // ********************************************************************
        // Attributes
        // ********************************************************************
        this.attribs = [];
        this.attribCounter = 0;
        // used to render attribute list hierarchy
        this.attribs_by_group = {};
        // ********************************************************************
        //
        // ********************************************************************
        this.finalized = false;
        // active color theme
        this.activeColorTheme = "sequential";
        this.preventAxisScaleTransition = true;
        this.onLoad = { callback: null, main: {} };
        this.onModeChange = null;
        this.dataTypeDescrs = [
            {
                name: "Categorical",
                icon: "far fa-font",
                member: (attrib) => attrib instanceof Attrib_Categorical,
                active: false,
            },
            {
                name: "MultiValued",
                icon: "far fa-tags",
                member: (attrib) => attrib instanceof Attrib_Categorical && attrib.isMultiValued,
                active: false,
            },
            {
                name: "Numeric",
                icon: "far fa-hashtag",
                member: (attrib) => attrib instanceof Attrib_Numeric,
                active: false,
            },
            {
                name: "Timestamp",
                icon: "far fa-calendar-day",
                member: (attrib) => attrib instanceof Attrib_Timestamp,
                active: false,
            },
            {
                name: "Timeseries",
                icon: "far fa-chart-line",
                member: (attrib) => attrib instanceof Attrib_Timeseries,
                active: false,
            },
            {
                name: "Location",
                icon: "far fa-map-marker",
                member: (attrib) => attrib instanceof Attrib_RecordGeo ||
                    (attrib instanceof Attrib_Categorical && attrib.hasMap()),
                active: false,
            },
            {
                name: "Unique",
                icon: "far fa-fingerprint",
                member: (attrib) => attrib instanceof Attrib_Categorical && attrib.uniqueCategories(),
                active: false,
            },
            {
                name: "Function",
                icon: "fal fa-function",
                member: (attrib) => !attrib.template.str,
                active: false,
            },
            {
                name: "Content",
                icon: "fa fa-file-alt",
                member: (attrib) => attrib instanceof Attrib_Content,
                active: false,
            },
        ];
        this.needToRefreshLayout = false;
        this.blockWithOpenConfig = null;
        /** -- */
        this.noAnim = false;
        // ********************************************************************
        // Warning panel
        // ********************************************************************
        this.panel_warningBox = null;
        this.mouseSpeed = 0;
        // prevents inserting credits, which sets img src tags and adds image requests, until it is shown
        this.creditsInserted = false;
        this._attribPanelWidth = Base.width_AttribPanelDefault;
        this.attribTextQuery = null;
        // ********************************************************************
        // Full screen control
        // ********************************************************************
        this.isFullscreen = false;
        // ********************************************************************
        // Data loading
        // ********************************************************************
        this._loadedTableCount = 0;
        this._totalTableCount = 0;
        this.chartsLoaded = false;
        // ********************************************************************
        // Moving blocks across panels
        // ********************************************************************
        this.movedAttrib = null;
        this.showDropZones = false;
        /**************************************************************
         * FILTERS
         **************************************************************/
        this.filters = [];
        this.filterCounter = 0;
        this.skipSortingSummary = null;
        /**************************************************************
         * ANALYTICS MODES
         **************************************************************/
        this.enableAnalytics = false;
        /**************************************************************
         * COMPARISONS
         **************************************************************/
        /** True if given compare type is locked */
        this.lockedCompare = {};
        /** Returns selected aggregate, if selection is active on given compare type */
        this.selectedAggrs = {};
        /** -- */
        this.crumbs = {};
        this.selectTimeouts = {};
        /** -- */
        this.filters_wrap_letItWrap = false;
        this.options = options;
        // TODO: Cannot do await here since this is constructor
        // but it'd be nice to wait until everything is loaded
        Base.loadResources();
        this.domID = this.options.domID || Base.defaultDOM;
        // BASIC OPTIONS
        Base.Compare_List.forEach((cT) => {
            this.lockedCompare[cT] = false;
            this.selectedAggrs[cT] = null;
            this.crumbs[cT] = new BreadCrumb(this, cT);
        });
        this.measureFunc = new Config({
            parent: this,
            cfgTitle: "Measure Function",
            cfgClass: "measureFunc",
            iconClass: "fa fa-cubes",
            UISeperator: {
                title: "Analytics",
            },
            default: "Count",
            tooltip: "The metric that aggregates values in each category / range.",
            helparticle: "5e9516452c7d3a7e9aeae06e",
            itemOptions: [
                // TODO: implement deactive / empty options
                // see: addMeasureOptions_Func
                { name: "measure_Count", value: "Count" },
                {
                    name: "measure_Sum",
                    value: "Sum",
                    activeWhen: () => this.getMeasurableSummaries("Sum").length > 0,
                },
                {
                    name: "measure_Avg",
                    value: "Avg",
                    activeWhen: () => this.getMeasurableSummaries("Avg").length > 0,
                },
            ],
            onRefreshDOM: (cfg) => {
                // Update text
                this.DOM.metricFuncText
                    .select(".measureFuncText")
                    .html(i18n["measure_" + cfg.get()]);
                // Update select box
                this.addMeasureOptions_Func(this.DOM.metricFuncText.select(".measureFuncOptions"));
            },
            preSet: (v) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                if (v === "Count")
                    return v;
                // v is Sum or Avg - we need to make sure measureSummary is valid.
                if (!((_a = this.measureSummary) === null || _a === void 0 ? void 0 : _a.get())) {
                    let attrib = this.getMeasurableSummaries(v)[0];
                    if (!attrib) {
                        throw Error(`No numeric data attribute supports ${v} measure function.`);
                    }
                    yield ((_b = this.measureSummary) === null || _b === void 0 ? void 0 : _b.set(attrib));
                }
                return v;
            }),
            onSet: () => __awaiter(this, void 0, void 0, function* () {
                yield this.refreshMeasureMetric();
            }),
        });
        this.measureSummary = new Config({
            parent: this,
            cfgTitle: "Measure Attribute",
            cfgClass: "measureSummary",
            iconClass: "far fa-cube",
            default: null,
            helparticle: "5e9516452c7d3a7e9aeae06e",
            onDOM: (DOM) => {
                var _ = DOM.root.select(".configItem_Options");
                DOM.mainSelect = _.append("select").attr("class", "mainSelect");
                DOM.timeKeys = _.append("select")
                    .attr("class", "timeKeys")
                    .on("input", (event) => {
                    var selectedKey = event.currentTarget.selectedOptions[0].__data__;
                    this.measureSummary.set(this.measureSummary.get().timeseriesParent.getTimepointSummary(selectedKey));
                });
            },
            onRefreshDOM: (cfg) => {
                if (!cfg.get())
                    return; // nothing to do!
                var attrib = this.measureSummary.get();
                this.addMeasureOptions_Summaries(cfg.DOM.mainSelect);
                this.addMeasureOptions_Summaries(this.DOM.metricFuncText.select("select.measureSummary"));
                // If measureSummary is timeseries, we need to show the keys
                var withKeys = attrib.timeseriesParent;
                cfg.DOM.timeKeys.classed("hide", !withKeys);
                this.DOM.metricFuncText
                    .select(".timeKeys.metricOptionWrapper")
                    .classed("hide", !withKeys);
                this.DOM.metricFuncText
                    .select(".measureSummaryName")
                    .html((withKeys ? attrib.timeseriesParent : attrib).attribNameHTML);
                if (withKeys) {
                    this.addMeasureOptions_Keys(cfg.DOM.timeKeys);
                    this.addMeasureOptions_Keys(this.DOM.metricFuncText.select("select.timeKeys"));
                    this.DOM.metricFuncText
                        .select(".timeKeyText")
                        .html(attrib.timeKey._time_src);
                }
            },
            preSet: (v) => __awaiter(this, void 0, void 0, function* () {
                var _c;
                var attrib = v;
                if (typeof attrib === "string") {
                    attrib = this.attribWithName(v);
                    if (!attrib)
                        attrib = this.createAttrib(v);
                }
                if (attrib instanceof Attrib_Timeseries) {
                    // First, try to use the timeKey of current measure attrib
                    attrib.initializeAggregates(); // before this, timeKeys is not computed.
                    var key = ((_c = this.measureSummary.get()) === null || _c === void 0 ? void 0 : _c.timeKey) ||
                        this.recordDisplay.currentTimeKey.get() ||
                        attrib.timeKeys[attrib.timeKeys.length - 1];
                    attrib = attrib.getTimepointSummary(key);
                }
                if (!attrib || !(attrib instanceof Attrib_Numeric))
                    return; // not a valid value
                // make sure attrib caches are initialized...
                attrib.initializeAggregates();
                return attrib; // allright
            }),
            onSet: (v) => __awaiter(this, void 0, void 0, function* () {
                if (!v || this.measureFunc_Count)
                    return;
                yield this.refreshMeasureMetric();
            }),
        });
        this.breakdownMode = new Config({
            parent: this,
            cfgTitle: "Breakdown",
            cfgClass: "breakdownMode",
            iconClass: "far fa-percent",
            default: "absolute",
            helparticle: "5e89445604286364bc97d5eb",
            tooltip: `How to compute and compare data groups`,
            itemOptions: [
                { name: "# Absolute", value: "absolute" },
                { name: "% of Compared", value: "dependent" },
                { name: "% of Groups", value: "relative" },
                { name: "% of All", value: "total" },
            ],
            forcedValue: () => {
                if (!this.measureWithPositiveValues())
                    return "absolute";
            },
            preSet: (v) => __awaiter(this, void 0, void 0, function* () {
                if (v !== "absolute" && this.measureFunc_Avg) {
                    throw Error(`You cannot analyze data by ${i18n.DialogComparisonSelection} when<br>
            using <i>average</i> as aggregation function for <i>${this.measureSummary.get().attribName}</i>.`);
                }
                if (v !== "absolute" && this.measureSumWithNegativeValues()) {
                    throw Error(i18n.DialogCompareForRelative);
                }
                return v;
            }),
            onSet: (v) => __awaiter(this, void 0, void 0, function* () {
                this.preventAxisScaleTransition = true;
                this.addedCompare = false;
                for (let attrib of this.attribsInDashboard) {
                    yield attrib.axisScaleType.set(v === "relative" ? "full" : "fit");
                    attrib.refreshChartScale_Measure();
                }
                yield this.refreshAnalytics();
                this.preventAxisScaleTransition = false;
            }),
        });
        this.stackedCompare = new Config({
            parent: this,
            cfgTitle: "GroupView",
            cfgClass: "stackedCompare",
            iconClass: "CompareModeIcon",
            UISeperator: {
                title: "Visualization",
            },
            default: true,
            helparticle: "5e88ff692c7d3a7e9aea6475",
            tooltip: `The comparison view mode<br><br>
        <b>Side-by-side</b>: Compare on shared baseline<br><br>
        <b>Stacked</b>: Compare on stacked baseline`,
            itemOptions: [
                { name: "SideBySide", value: false },
                { name: "Stacked", value: true },
            ],
            onDOM: (DOM) => {
                DOM.root
                    .select(".CompareModeIcon")
                    .selectAll("div")
                    .data([0, 1, 2])
                    .enter()
                    .append("div")
                    .attr("class", "CompareModeIcon-block");
            },
            forcedValue: () => {
                if (this.dependentBreakdown) {
                    return false;
                }
                if (this.relativeBreakdown) {
                    if (!this.comparedAttrib)
                        return false;
                    return !this.isComparedSummaryMultiValued(); // stack if it's not multi-valued
                }
                if (this.totalBreakdown) {
                    if (!this.comparedAttrib)
                        return false;
                    if (this.isComparedSummaryMultiValued())
                        return false;
                }
                // absoluteBreakdown from now on
                // detect cases when you cannot stack
                if (this.comparedAttrib && this.isComparedSummaryMultiValued())
                    return false;
                if (!this.measureWithPositiveValues())
                    return false;
            },
            preSet: (v) => __awaiter(this, void 0, void 0, function* () {
                if (v !== true && v !== false)
                    return; // not valid input
                if (v && this.comparedAttrib && this.isComparedSummaryMultiValued()) {
                    throw i18n.DialogStackedMultiValue(this.comparedAttrib.attribName);
                }
                if (!v &&
                    this.comparedAttrib &&
                    !this.isComparedSummaryMultiValued() &&
                    this.relativeBreakdown) {
                    throw i18n.DialogSideBySideSingleValue(this.comparedAttrib.attribName);
                }
                if (v && this.measureFunc_Avg) {
                    throw (i18n.DialogStackedCharts +
                        " cannot be used with <i>average</i> measure function.");
                }
                if (v && this.dependentBreakdown) {
                    throw (i18n.DialogStackedCharts +
                        " cannot be used with " +
                        i18n.DialogDependentBreakdown);
                }
                if (v && this.measureSumWithNegativeValues()) {
                    throw (i18n.DialogStackedCharts +
                        " cannot be used with measuring totals with negative values.");
                }
                return v;
            }),
            onSet: () => __awaiter(this, void 0, void 0, function* () {
                this.attribsInDashboard.forEach((attrib) => attrib.refreshChartScale_Measure());
                yield this.refreshAnalytics();
            }),
        });
        this.showWholeAggr = new Config({
            parent: this,
            cfgTitle: "Whole Distribution",
            cfgClass: "showWholeAggr",
            iconClass: "fa fa-square",
            default: true,
            tooltip: `When you have two or more compare selections, 
                you can choose to show the whole value of the aggreagates.`,
            helparticle: "5e893d7a2c7d3a7e9aea656f",
            itemOptions: [
                { name: "Show", value: true },
                { name: "Hide", value: false },
            ],
            forcedValue: () => {
                if (this.activeComparisonsCount === 0)
                    return true;
                if (this.dependentBreakdown) {
                    return false;
                }
                if (this.relativeBreakdown) {
                    if (!this.comparedAttrib)
                        return false;
                    return !this.isComparedSummaryMultiValued();
                }
                if (this.totalBreakdown) {
                    if (!this.comparedAttrib)
                        return false;
                    return;
                    //if(this.comparedSummary.isMultiValued) return false;
                }
                // of-total or absolute breakdown, with comparisons
                if (this.stackedCompare.is(true)) {
                    var totalOfCompared = this.activeComparisons.reduce((accum, val) => {
                        if (this.selectedAggrs[val]) {
                            return accum + this.selectedAggrs[val][val].measure;
                        }
                        return accum;
                    }, 0);
                    if (totalOfCompared === this.allRecordsAggr.measure("Active"))
                        return false;
                }
                if (!this.measureWithPositiveValues())
                    return false;
            },
            onSet: () => __awaiter(this, void 0, void 0, function* () { return yield this.refreshAnalytics(); }),
        });
        this.filteringMode = new Config({
            parent: this,
            cfgTitle: "Filtering",
            cfgClass: "filteringMode",
            iconClass: "fal fa-filter",
            UISeperator: {
                title: "Selections",
            },
            default: "chained",
            tooltip: `<b>Combined</b> allows combining multiple filters together<br><br>
        <b>Single</b> forces to have at most one active filter.`,
            helparticle: "5e88eff404286364bc97d459",
            itemOptions: [
                { name: "Chained", value: "chained" },
                { name: "Single", value: "single" },
            ],
            preSet: (v) => __awaiter(this, void 0, void 0, function* () {
                v = v.toLowerCase();
                if (v === "combined")
                    v = "chained";
                return v;
            }),
            onSet: (v) => {
                if (v === "single" && this.numOfActiveFilters > 1) {
                    this.clearFilters_All(this.filters.find((_) => _.isFiltered)); // remove our all but one
                }
            },
        });
        this.mouseOverCompare = new Config({
            parent: this,
            cfgTitle: "Hover Highlight",
            cfgClass: "mouseOverCompare",
            iconClass: "fal fa-mouse-pointer",
            default: true,
            helparticle: "5e8905c52c7d3a7e9aea6489",
            itemOptions: [
                { name: "Enabled", value: true },
                { name: "Disabled", value: false },
            ],
        });
        this.recordChartType = new Config({
            parent: this,
            cfgTitle: "Record Chart Type",
            cfgClass: "recordChartType",
            iconClass: "fal fa-bullseye",
            UISeperator: {
                title: "Record Chart",
            },
            default: "none",
            helparticle: "5eadcca72c7d3a5ea54a59e9",
            noExport: true,
            itemOptions: [
                { name: "None", value: "none" },
                {
                    name: "ListButton",
                    value: "list",
                    activeWhen: () => true, // always visible
                },
                {
                    name: "MapButton",
                    value: "map",
                    activeWhen: () => {
                        var _a;
                        return ((_a = this.recordDisplay) === null || _a === void 0 ? void 0 : _a.getRecordGeoAttributes().length) > 0;
                    },
                },
                {
                    name: "TimeSeriesButton",
                    value: "timeseries",
                    activeWhen: () => {
                        var _a, _b;
                        if (((_a = this.records) === null || _a === void 0 ? void 0 : _a.length) < 2)
                            return false;
                        return ((_b = this.recordDisplay) === null || _b === void 0 ? void 0 : _b.getAttribOptions_UI("timeSeries").length) > 0;
                    },
                },
                {
                    name: "ScatterButton",
                    value: "scatter",
                    activeWhen: () => {
                        var _a, _b;
                        if (((_a = this.records) === null || _a === void 0 ? void 0 : _a.length) < 5)
                            return false;
                        return ((_b = this.recordDisplay) === null || _b === void 0 ? void 0 : _b.getAttribOptions_UI("scatterX").length) > 1;
                    },
                },
            ],
            preSet: (v) => __awaiter(this, void 0, void 0, function* () {
                if (!this.records)
                    return; // data not loaded yet
                if (!this.recordDisplay)
                    return;
                if (this.records.length > 5000 && !["list", "none"].includes(v)) {
                    yield Modal.confirm("<div style='text-align:center;''>There are more than 2,000 records.<br>" +
                        `The ${v} chart will be crowded and potentially slow.<br><Br>` +
                        `Are you sure you want to change to ${v} chart?</div>`, "Change chart type");
                }
                if (v === "map") {
                    // Make sure recordDisplay.config.geo is set.
                    if (!this.recordDisplay.config.geo) {
                        var _ = this.recordDisplay.getRecordGeoAttributes()[0];
                        if (!_)
                            throw "Geo attribute not found";
                    }
                }
                return v;
            }),
            onSet: (_type) => __awaiter(this, void 0, void 0, function* () {
                var _d, _e;
                try {
                    if (!this.recordDisplay)
                        return;
                    if (_type === "map") {
                        // Make sure recordDisplay.config.geo is set.
                        if (!this.recordDisplay.config.geo) {
                            var _ = this.recordDisplay.getRecordGeoAttributes()[0];
                            if (!_)
                                throw "Geo attribute not found";
                            this.recordDisplay.config.geo = _.attribName;
                        }
                    }
                    // setting the css style here so that the UI can prepare the layout
                    (_d = this.DOM.root) === null || _d === void 0 ? void 0 : _d.attr("recordChartType", _type);
                    yield this.recordDisplay.setView(_type);
                    this.refreshIsEmpty();
                    this.updateLayout_Height();
                }
                catch (e) {
                    console.log(e);
                    (_e = this.recordChartType) === null || _e === void 0 ? void 0 : _e.undoChange();
                }
            }),
        });
        this.dashboardMode = new Config({
            parent: this,
            cfgTitle: "Dashboard Mode",
            cfgClass: "dashboardMode",
            iconClass: "fa fa-wrench",
            UI: { disabled: true },
            default: "Explore",
            helparticle: "5e8943d504286364bc97d5e6",
            itemOptions: [
                { name: "Explore", value: "Explore" },
                { name: "Author", value: "Author" },
                { name: "Adjust", value: "Adjust" },
                { name: "Capture", value: "Capture" },
                { name: "Save", value: "Save" },
            ],
            preSet: (v) => __awaiter(this, void 0, void 0, function* () {
                if (v === "Print")
                    return "Capture";
                return v;
            }),
            onSet: (v, cfg) => __awaiter(this, void 0, void 0, function* () {
                var _f;
                if (this.finalized) {
                    this.setNoAnim(true);
                    if (v === "Author")
                        this.refreshAttribList();
                    this.panels.bottom.setWidth(this.width_Canvas);
                    this.panels.bottom.refreshWidth();
                    this.updateLayout();
                    //updateLayout may not be "effective" if loading is not finalized...
                    this.updateMiddlePanelWidth();
                    setTimeout(() => this.setNoAnim(false), 500);
                    (_f = this.onModeChange) === null || _f === void 0 ? void 0 : _f.call(this);
                }
                yield cfg.refresh();
            }),
            onRefreshDOM: (cfg) => {
                if (!this.DOM.panel_Footer)
                    return;
                this.DOM.panel_Footer
                    .selectAll(".dashSelectMode")
                    .classed("active", (_) => cfg.is(_.name));
                this.DOM.root
                    .attr("data-dashboardMode", cfg.get());
            },
        });
        [
            "measureFunc",
            "measureSummary",
            "breakdownMode",
            "stackedCompare",
            "showWholeAggr",
            "filteringMode",
            "mouseOverCompare",
            "recordChartType",
        ].forEach((_) => {
            this.configs[_] = this[_];
        });
        var me = this;
        this.colorTheme = {
            browser: this,
            // defaults
            sequential: "YlGnBu",
            diverging: "Spectral",
            getDiscrete(bins = 9) {
                let _theme = me.activeColorTheme;
                let scale = d3["scheme" + this[_theme]];
                if (scale && scale[bins]) {
                    return scale[bins].slice(); // return a copy in case someone wants to edit
                }
                scale = d3["interpolate" + this[_theme]];
                var colors = [];
                if (bins === 1) {
                    colors.push(d3.rgb(scale(0.8)).hex());
                }
                else if (bins === 2) {
                    colors.push(d3.rgb(scale(0.8)).hex());
                    colors.push(d3.rgb(scale(0.2)).hex());
                }
                else {
                    for (let i = 0; i < bins; ++i) {
                        colors.push(d3.rgb(scale(i / (bins - 1))).hex());
                    }
                }
                return colors.reverse(); // cividis, etc, need to reverse from light to dark
            },
            getContinuous() {
                return d3["interpolate" + this[me.activeColorTheme]];
            },
            exportConfig() {
                var _ = {};
                if (this.sequential !== "YlGnBu")
                    _.sequential = this.sequential;
                if (this.diverging !== "Spectral")
                    _.diverging = this.diverging;
                return _;
            },
        };
        this.allRecordsAggr = new Aggregate(null); // not placed in an attribute
        this.allAggregates.push(this.allRecordsAggr);
        Base.browsers[this.getDashboardID()] = this;
        Base.browser = this;
        if (this.options.onLoad) {
            // callback
            if (this.options.onLoad.callback) {
                if (this.options.onLoad.callback instanceof Function) {
                    this.onLoad.callback = this.options.onLoad.callback;
                }
                else {
                    delete this.options.onLoad;
                }
            }
            // main keys
            for (var key in this.options.onLoad) {
                this.onLoad.main[key] = this.options.onLoad[key];
            }
        }
        let lastMouseMoveEvent = null;
        this.DOM.root = d3
            .select(this.domID)
            .classed("kshf", true)
            .classed("noAnim", true)
            .attr("data-dashboardMode", this.dashboardMode.get())
            .attr("recordChartType", "none")
            .on("mousemove", (event) => {
            // Compute mouse moving speed, to adjust repsonsiveness
            if (!lastMouseMoveEvent) {
                lastMouseMoveEvent = event;
                return;
            }
            var timeDif = event.timeStamp - lastMouseMoveEvent.timeStamp;
            if (timeDif === 0)
                return;
            var xDif = Math.abs(event.x - lastMouseMoveEvent.x);
            var yDif = Math.abs(event.y - lastMouseMoveEvent.y);
            // controls highlight selection delay
            this.mouseSpeed = Math.min((xDif + yDif) / timeDif, 2);
            lastMouseMoveEvent = event;
        });
        if (this.dashZoomLevel != "1.00") {
            this.attemptToFixBrowserZoomLevel(this.dashZoomLevel);
        }
        this.updateWidth_Total();
        this.recordName = this.options.recordName || "";
        // remove any DOM elements under this domID, kshf takes complete control over what's inside
        var rootDomNode = this.DOM.root.node();
        while (rootDomNode.hasChildNodes())
            rootDomNode.removeChild(rootDomNode.lastChild);
        this.DOM.pointerBlock = this.DOM.root
            .append("div")
            .attr("class", "pointerBlock");
        this.DOM.attribDragBox = this.DOM.root
            .append("div")
            .attr("class", "attribDragBox");
        this.insertDOM_WarningBox();
        //this.DOM.mainWrapper = this.DOM.root.append("div").attr("class","mainWrapper");
        this.recordDetailsPopup = new RecordDetailPopup(this);
        this.insertDOM_Panel_Overlay();
        this.insertDOM_AttribPanel();
        this.DOM.panel_Wrapper = this.DOM.root
            .append("div")
            .attr("class", "panel_Wrapper")
            .classed("emptyDashboard", true)
            .classed("panel_bottom_empty", true);
        this.insertDOM_PanelBasic();
        this.dashboardConfigPanel = new ConfigPanel(this.DOM.panel_Wrapper, "DashboardAnalyticsConfig", "DashboardAnalyticsConfig", Object.values(this.configs), this, this.DOM.metricFuncSelectButton);
        this.panels.left = new Panel(this, "left", this.DOM.panel_Wrapper);
        this.panels.right = new Panel(this, "right", this.DOM.panel_Wrapper);
        this.DOM.middleColumn = this.DOM.panel_Wrapper
            .append("div")
            .attr("class", "middleColumn");
        this.panels.middle = new Panel(this, "middle", this.DOM.middleColumn);
        this.DOM.middleColumn.append("div").attr("class", "recordDisplay");
        this.panels.bottom = new Panel(this, "bottom", this.DOM.panel_Wrapper);
        this.DOM.panelEmpty = this.DOM.panel_Wrapper
            .append("div")
            .attr("class", "panelEmpty")
            .append("div")
            .attr("class", "actionInfo")
            .html(i18n.EmptyDashboardNotice);
        this.insertDOM_Panel_Footer();
        this.DOM.root.selectAll(".panel").on("mouseleave", () => {
            setTimeout(() => {
                if (!this.needToRefreshLayout)
                    return;
                this.updateLayout_Height();
                this.needToRefreshLayout = false;
            }, 1500); // update layout after 1.5 seconds
        });
        this.loadDataSources();
    }
    /** -- */
    refreshConfigs() {
        Object.values(this.configs).forEach((cfg) => cfg.refresh());
        this.attribsInDashboard.forEach((attrib) => attrib.refreshConfigs());
        this.refreshAnalytics();
    }
    /** -- */
    activateWidthDrag(DOM, event, onMove) {
        DOM.classList.add("dragging");
        this.setNoAnim(true);
        this.DOM.root
            .style("cursor", "ew-resize")
            .on("mousemove.temp", onMove)
            .on("mouseup.temp", () => {
            DOM.classList.remove("dragging");
            this.setNoAnim(false);
        });
        event.preventDefault();
    }
    /** -- */
    closeConfigPanels() {
        var _a, _b;
        (_b = (_a = this.blockWithOpenConfig) === null || _a === void 0 ? void 0 : _a.DOM) === null || _b === void 0 ? void 0 : _b.root.classed("showConfig", false);
        this.blockWithOpenConfig = undefined;
        this.dashboardConfigPanel.hide();
        this.recordDisplay.recordConfigPanel.hide();
    }
    setNoAnim(v) {
        if (!this.finalized)
            return;
        this.noAnim = v;
        this.DOM.root.classed("noAnim", this.noAnim);
        this.DOM.pointerBlock.attr("active", this.noAnim ? "" : null);
        if (!this.noAnim) {
            this.DOM.root
                .style("cursor", null)
                .on("mousemove.temp", null)
                .on("mouseup.temp", null);
        }
    }
    /** -- */
    refreshIsEmpty() {
        this.DOM.panel_Wrapper.classed("emptyDashboard", this.attribsInDashboard.length === 0 && this.recordChartType.is("none"));
    }
    /** Returns data type based on first found valid value, null if type not detected */
    getAttribTypeFromFunc(func) {
        var type = null;
        this.records.some((record) => {
            var _val = func.call(record.data, record);
            if (_val == null || _val == "")
                return false; // cannot infer type
            var v_type = typeof _val;
            if (v_type === "object" && _val._timeseries_) {
                type = "timeseries";
            }
            else if (v_type === "object" && _val.coordinates) {
                type = "recordGeo";
            }
            else if (v_type === "number") {
                type = "numeric";
            }
            else if (_val instanceof Date) {
                type = "timestamp";
            }
            else if (v_type === "string" || v_type === "boolean") {
                // TO-DO: Think about boolean summaries (?)
                type = "categorical";
            }
            else if (Array.isArray(_val)) {
                type = "categorical";
            }
            return type ? true : false;
        });
        return type;
    }
    /** -- */
    createAttrib(name, func = undefined, type = undefined) {
        if (!name)
            return;
        // return existing block with same name
        if (this.attribWithName(name)) {
            return this.attribWithName(name);
        }
        var attrib;
        if (type === "content") {
            attrib = new Attrib_Content(this, name);
        }
        else {
            if (func == null) {
                func = name;
            }
            var _v = new AttribTemplate(func, this);
            type = type !== null && type !== void 0 ? type : _v.blockType;
            if (!type) {
                type = this.getAttribTypeFromFunc(_v.func);
            }
            if (!type) {
                console.log(`Summary data type could not be detected for: ${name}`);
                return;
            }
            if (type === "categorical") {
                attrib = new Attrib_Categorical(this, name, _v);
                //
            }
            else if (type === "timeseries") {
                attrib = new Attrib_Timeseries(this, name, _v);
                //
            }
            else if (type === "recordGeo") {
                attrib = new Attrib_RecordGeo(this, name, _v);
                //
            }
            else if (type === "timestamp") {
                attrib = new Attrib_Timestamp(this, name, _v);
                //
            }
            else if (type === "numeric") {
                attrib = new Attrib_Numeric(this, name, _v);
            }
        }
        this.insertAttribIntoGroupIndex(attrib);
        return attrib;
    }
    /** -- */
    destroyAttrib(attrib) {
        var _a, _b;
        (_a = attrib === null || attrib === void 0 ? void 0 : attrib.block) === null || _a === void 0 ? void 0 : _a.removeFromPanel();
        var indexFrom = -1;
        this.attribs.forEach((a, i) => {
            if (a === attrib)
                indexFrom = i;
        });
        if (indexFrom === -1)
            return;
        this.attribs.splice(indexFrom, 1);
        // if the attrib is within the record display sorting list, remove!
        (_b = this.recordDisplay) === null || _b === void 0 ? void 0 : _b.refreshAttribOptions("sort");
        this.removeAttribFromGroupIndex(attrib);
        this.refreshAttribList();
    }
    /** -- */
    insertAttribIntoGroupIndex(attrib) {
        var target = this.attribs_by_group;
        // find position in hierarchy
        attrib.groupPath.forEach((_key, i, list) => {
            if (!target[_key]) {
                // "group" node (simple string, not a summary group)
                target[_key] = {
                    name: _key,
                    item: _key,
                    parents: list.slice(0, i),
                    sub: {},
                };
            }
            target = target[_key].sub;
        });
        var _key = attrib.printName;
        if (!target[_key]) {
            target[_key] = {
                name: _key,
                parents: attrib.groupPath,
                sub: {},
            };
        } // if new, establish "sub".
        target[_key].item = attrib;
    }
    /** -- */
    removeAttribFromGroupIndex(attrib) {
        var _a;
        var target = this.attribs_by_group;
        attrib.groupPath.forEach((_key) => {
            // when changing timeseries, the key numeric summaries get updated after timeseries name is updated
            // target[_key] may be indexing old stuff that's no longer valid
            target = target && target[_key] && target[_key].sub;
        });
        if (target)
            delete target[attrib.printName];
        (_a = attrib === null || attrib === void 0 ? void 0 : attrib.block) === null || _a === void 0 ? true : delete _a.DOM.nugget;
        this.removeEmptySubs();
    }
    /** -- */
    removeEmptySubs() {
        function recurse(obj) {
            for (let [key, value] of Object.entries(obj)) {
                let v = value;
                if (typeof v.item === "string" && Object.entries(v.sub).length === 0) {
                    // not a block, doesn't have sub-blocks
                    delete obj[key];
                }
                else {
                    recurse(v.sub);
                }
            }
        }
        recurse(this.attribs_by_group);
    }
    /** -- */
    setRecordName(v) {
        this.recordName = v;
        this.DOM.root.selectAll(".recordName").html(this.recordName);
    }
    /** -- */
    setDescription(t) {
        this.options.description = t;
        this.DOM.browserDescription
            .select(".customDescription")
            .style("display", t ? "inline-block" : null);
        this.DOM.browserDescription.select(".customDescriptionText").html(t);
    }
    /** -- */
    updateWidth_Total() {
        this.divWidth = this.DOM.root.node().clientWidth;
    }
    /** -- */
    getWidth_Total() {
        return this.divWidth;
    }
    /** This also considers if the available attrib panel is shown */
    get width_Canvas() {
        return (this.divWidth -
            (this.authorMode ? this._attribPanelWidth : 0) -
            2 * Base.width_PanelGap); // 8 pixels on both sides are gone
    }
    /** -- */
    get height_PanelHeader() {
        var _ = parseInt(this.DOM.panel_DataStatus.style("height"));
        return isNaN(_) ? 0 : _;
    }
    /** -- */
    get height_PanelFooter() {
        var _ = parseInt(this.DOM.panel_Footer.style("height"));
        return isNaN(_) ? 0 : _;
    }
    /** -- */
    getDashboardID() {
        return window.location.pathname + this.domID;
    }
    /* -- */
    insertDOM_WarningBox() {
        this.panel_warningBox = this.DOM.root
            .append("div")
            .attr("class", "warningBox_wrapper");
        var x = this.panel_warningBox.append("span").attr("class", "warningBox");
        this.DOM.warningText = x.append("span").attr("class", "warningText");
        x.append("span")
            .attr("class", "dismiss fa fa-times")
            .tooltip(i18n.Close)
            .on("click", () => this.hideWarning());
    }
    showWarning(v) {
        this.panel_warningBox.classed("active", true);
        this.DOM.warningText.html(v);
        setTimeout(() => this.hideWarning(), 5000); // auto-hide after 5 seconds
    }
    hideWarning() {
        if (this.panel_warningBox)
            this.panel_warningBox.classed("active", null);
    }
    get movingMouseDelay() {
        return this.mouseSpeed < 0.2 ? 0 : this.mouseSpeed * 500;
    }
    /** -- */
    getMeasurableSummaries(_t) {
        return this.attribs
            .filter((attrib) => attrib.supportedMetricFuncs.includes(_t) &&
            !attrib.isEmpty() &&
            !attrib.hasTimeSeriesParent())
            .sort((s1, s2) => Util.sortFunc_List_String(s1.attribName, s2.attribName));
    }
    /** -- */
    addMeasureOptions_Summaries(dom) {
        dom
            .on("change", (event) => __awaiter(this, void 0, void 0, function* () { return yield this.measureSummary.set(event.currentTarget.selectedOptions[0].__data__); }))
            .selectAll("option")
            .remove();
        if (this.measureFunc.is("Count"))
            return;
        dom
            .selectAll("option")
            .data(this.getMeasurableSummaries(this.measureFunc.get()))
            .enter()
            .append("option")
            .attr("selected", (s) => { var _a; return s.attribID === ((_a = this.measureSummary.get()) === null || _a === void 0 ? void 0 : _a.attribID) ? true : null; })
            .html((s) => s.attribName);
    }
    /** -- */
    addMeasureOptions_Keys(dom) {
        dom.selectAll("option").remove();
        dom // slice creates a copy, reverse in-place updates this copy
            .selectAll("option")
            .data(this.measureSummary.get().timeseriesParent.timeKeys.slice().reverse())
            .enter()
            .append("option")
            .attr("value", (timeKey) => timeKey._time_src)
            .attr("selected", (timeKey) => timeKey._time_src === this.measureSummary.get().timeKey._time_src
            ? "true"
            : null)
            .html((timeKey) => timeKey._time_src);
    }
    /** -- */
    addMeasureOptions_Func(dom) {
        dom
            .on("change", (event) => __awaiter(this, void 0, void 0, function* () { return yield this.measureFunc.set(event.currentTarget.selectedOptions[0].__data__.v); }))
            .selectAll("option")
            .remove();
        var opts = [{ v: "Count", l: i18n.measure_Count, active: true }];
        ["Sum", "Avg"].forEach((_t) => {
            opts.push({
                v: _t,
                l: i18n["measure_" + _t],
                active: this.getMeasurableSummaries(_t).length > 0,
            });
        });
        dom
            .selectAll("option")
            .data(opts)
            .enter()
            .append("option")
            .attr("disabled", (d) => (d.active ? null : true))
            .attr("selected", (d) => (d.v === this.measureFunc.get() ? true : null))
            .html((d) => d.l);
    }
    /** -- */
    insertDOM_Panel_DatasetInfo() {
        this.DOM.datasource = this.DOM.browserDescription
            .append("a")
            .attr("class", "fal fa-table datasource")
            .attr("target", "_blank")
            .tooltip(i18n.OpenDataSource);
        this.DOM.browserDescription
            .append("div")
            .attr("class", "DataPrivacy")
            .html('<span class="DataPrivacy-Public">Public data</span>' +
            '<span class="DataPrivacy-Private">Private data</span>');
        var x = this.DOM.browserDescription
            .append("span")
            .attr("class", "customDescription");
        x.append("span")
            .attr("class", "customDescriptionButton")
            .tooltip("Edit")
            .on("click", () => {
            var _descr = Modal.prompt("Provide a short description or credit for the dataset", this.options.description);
            if (_descr === "") {
                this.setDescription(null);
                return;
            }
            if (!_descr)
                return;
            var _url = Modal.prompt("Provide the link for credit", "");
            if (_url) {
                // if _url doesn't start with http, add http://
                if (_url.substr(0, 4) !== "http")
                    _url = "http://" + _url;
                _descr =
                    "<a target='_blank' rel='noopener noreferrer' href='" +
                        _url +
                        "'>" +
                        _descr +
                        "</a>";
            }
            this.setDescription(_descr);
        })
            .html("<i class='fa fa-info-circle'></i> ");
        x.append("span").attr("class", "customDescriptionText");
        this.setDescription(this.options.description);
    }
    /** -- */
    insertDOM_Panel_Footer() {
        this.DOM.panel_Footer = this.DOM.root
            .append("div")
            .attr("class", "panel_Footer");
        var x = this.DOM.panel_Footer
            .append("div")
            .attr("class", "dashboardModeSelect");
        x.append("div")
            .attr("class", "dashboardModeSelectTitle")
            .attr("data-helparticle", "5e8943d504286364bc97d5e6")
            .html(i18n.Mode);
        Modal.createHelpScoutLinks(x, true);
        x.selectAll("div.dashSelectMode")
            .data([
            {
                name: "Explore",
                class: "far fa-compass",
            },
            {
                name: "Author",
                class: "far fa-pen-fancy",
            },
            {
                name: "Adjust",
                class: "far fa-sliders-h",
            },
            {
                name: "Capture",
                class: "far fa-draw-square",
            },
            {
                name: "Save",
                class: "far fa-bookmark",
            },
        ])
            .enter()
            .append("div")
            .attr("class", (_) => `dashSelectMode dashSelectMode-${_.name}`)
            .classed("active", (_) => this.dashboardMode.is(_.name))
            .on("click", (_event, _) => __awaiter(this, void 0, void 0, function* () { return yield this.dashboardMode.set(_.name); }))
            .tooltip((_) => i18n[`${_.name} Mode`])
            .call((dashSelectMode) => {
            dashSelectMode.append("div").attr("class", (_) => _.class);
            dashSelectMode
                .append("div")
                .attr("class", "theText")
                .html((_) => i18n[_.name]);
        });
        this.DOM.browserDescription = this.DOM.panel_Footer
            .append("span")
            .attr("class", "browserDescription");
        // Info & Credits
        var x = this.DOM.panel_Footer
            .append("span")
            .attr("class", "logoHost")
            .tooltip(i18n.ShowInfoCredits)
            .on("click", () => {
            this.showCredits();
            this.DOM.overlay_wrapper
                .attr("show", "infobox")
                .classed("easyDismiss", true);
        })
            .html(`<span class='keshifSVG'>Keshif<img></span>
        <span class='theDataMadeExplorable'>Data Made Explorable</span>
        `);
        x.select("svg")
            .style("width", "20px")
            .style("width", "18px")
            .style("height", "19px");
    }
    /** -- */
    insertDOM_PanelBasic() {
        var me = this;
        this.DOM.panel_DataStatus = this.DOM.root
            .append("div")
            .attr("class", "panel_DataStatus");
        this.DOM.metricFuncSelectButton = this.DOM.panel_DataStatus
            .append("span")
            .attr("class", "metricFuncSelectButton basicIcon fal fa-cog")
            .tooltip(i18n.DashboardAnalyticsConfig)
            .on("click", () => this.dashboardConfigPanel.showAtPos(8, 8));
        this.DOM.recordInfo = this.DOM.panel_DataStatus
            .append("span")
            .attr("class", "recordInfo");
        this.DOM.activeRecordMeasure = this.DOM.recordInfo
            .append("span")
            .attr("class", "activeRecordMeasure");
        this.DOM.metricFuncText = this.DOM.recordInfo
            .append("span")
            .attr("class", "metricFuncText");
        this.DOM.metricFuncText.html("" +
            "<span class='measureFunc metricOptionWrapper'>" +
            "<span class='measureFuncText metricOptionWrapper_Text'></span>" +
            "<select class='measureFuncOptions metricOptionWrapper_Opts'></select>" +
            "</span>" +
            "<span class='timeKeys metricOptionWrapper'>" +
            "<i class='fal fa-calendar'></i>" +
            "<span class='timeKeyText metricOptionWrapper_Text'></span>" +
            "<select class='timeKeys metricOptionWrapper_Opts'></select>" +
            "</span>" +
            "<span class='measureSummary metricOptionWrapper'>" +
            "<span class='measureSummaryName metricOptionWrapper_Text'></span>" +
            "<select class='measureSummary metricOptionWrapper_Opts'></select>" +
            "</span>" +
            `<span class='Of_NumberRecord'>${i18n.Of_NumberRecord}</span>`);
        this.DOM.metricFuncText.select("select.timeKeys").on("input", (event) => __awaiter(this, void 0, void 0, function* () {
            yield this.measureSummary.set(this.measureSummary.get().timeseriesParent.getTimepointSummary(event.currentTarget.selectedOptions[0].__data__));
        }));
        this.DOM.recordName = this.DOM.recordInfo
            .append("span")
            .attr("class", "recordName")
            .tooltip("")
            .on("mouseenter", function (event) {
            this.tippy.setContent(this.isContentEditable ? "OK" : i18n.EditTitle);
            event.stopPropagation();
            event.preventDefault();
        })
            .on("focus", function () {
            this.tippy.hide();
            this._initValue = purify.sanitize(this.innerHTML);
        })
            .on("blur", function () {
            this.tippy.hide();
            this.contentEditable = false;
        })
            .on("keyup", (event) => event.stopPropagation())
            .on("keypress", (event) => event.stopPropagation())
            .on("keydown", function (event) {
            if (event.keyCode === 27) {
                // Escape : Do not apply the new label
                this.blur();
                this.innerHTML = purify.sanitize(this._initValue);
                return;
            }
            if (event.keyCode === 13) {
                // ENTER
                me.setRecordName(this.textContent);
                this.blur();
            }
            event.stopPropagation();
        })
            .on("click", function () {
            if (!this.isContentEditable) {
                this.contentEditable = true;
                this.focus();
            }
            else {
                this.contentEditable = false;
                me.setRecordName(purify.sanitize(this.innerHTML));
            }
        });
        var dashboardSettings = this.DOM.panel_DataStatus
            .append("span")
            .attr("class", "iconGroup dashboardSettings");
        this.DOM.panel_Basic_In = this.DOM.panel_DataStatus
            .append("div")
            .attr("class", "panel_Basic_In");
        this.DOM.panel_DataStatus
            .append("div")
            .attr("class", "iconGroup rightSideIcons")
            .call((rightSideIcons) => {
            rightSideIcons
                .append("div")
                .attr("class", "viewFullscreen basicIcon far fa-expand-arrows-alt")
                .tooltip(i18n.ShowFullscreen)
                .on("click", () => this.showFullscreen());
            if (this.dashZoomLevel !== "1.00") {
                rightSideIcons
                    .append("div")
                    .attr("class", "basicIcon fa fa-window-restore")
                    .tooltip(i18n["Reset Zoom Level"])
                    .on("click", () => this.attemptToFixBrowserZoomLevel("1.00", true));
            }
            rightSideIcons
                .append("div")
                .attr("class", "showHelpIn basicIcon fal fa-question-circle")
                .tooltip(i18n.Help)
                .on("click", () => Modal.helpUI());
        });
        dashboardSettings
            .append("span")
            .attr("class", "dashboardSetting breakdownModeIcon far fa-percent")
            .tooltip("", {
            onShow: (instance) => {
                instance.reference.tippy.setContent(`<div>${i18n["Breakdown"]}</div>
          <b>${this.breakdownMode}</b><br>
          <i>${i18n["Click to change"]}</i>`);
            },
        })
            .on("click", (event) => {
            Modal.popupMenu(event, {
                name: "Breakdown",
                items: [
                    {
                        id: "absoluteBreakdown",
                        name: "Absolute",
                        iconClass: "far fa-hashtag",
                        helparticle: "5e8944682c7d3a7e9aea659a",
                        active: this.breakdownMode.is("absolute"),
                        do: () => __awaiter(this, void 0, void 0, function* () { return yield this.breakdownMode.set("absolute"); }),
                    },
                    {
                        id: "percentBreakdown",
                        name: "Percentage",
                        iconClass: "far fa-percent",
                        expanded: true,
                        options: [
                            {
                                id: "dependentBreakdown",
                                name: "% of Compared",
                                helparticle: "5e8944812c7d3a7e9aea659b",
                                active: this.breakdownMode.is("dependent"),
                                do: () => __awaiter(this, void 0, void 0, function* () { return yield this.breakdownMode.set("dependent"); }),
                            },
                            {
                                id: "relativeBreakdown",
                                name: "% of Groups",
                                helparticle: "5e8944932c7d3a7e9aea659c",
                                active: this.breakdownMode.is("relative"),
                                do: () => __awaiter(this, void 0, void 0, function* () { return yield this.breakdownMode.set("relative"); }),
                            },
                            {
                                id: "totalBreakdown",
                                name: "% of All",
                                helparticle: "5e94ff6904286364bc984a7a",
                                active: this.breakdownMode.is("total"),
                                do: () => __awaiter(this, void 0, void 0, function* () { return yield this.breakdownMode.set("total"); }),
                            },
                        ],
                    },
                ],
            }, this, { placement: "bottom-start" });
        });
        dashboardSettings
            .append("span")
            .attr("class", "dashboardSetting lockCrumbMode")
            .tooltip("", {
            onShow: (instance) => {
                instance.reference.tippy.setContent(`<div>${i18n["Group View"]}</div> <b>${this.stackedCompare}</b><br> <i>${i18n["Click to change"]}</i>`);
            },
        })
            .on("click", () => __awaiter(this, void 0, void 0, function* () { return yield this.stackedCompare.set(!this.stackedCompare.get()); }))
            .append("div")
            .attr("class", "CompareModeIcon")
            .selectAll("div")
            .data([0, 1, 2])
            .enter()
            .append("div")
            .attr("class", "CompareModeIcon-block");
        this.DOM.breadCrumbs_Filter = this.DOM.panel_Basic_In
            .append("div")
            .attr("class", "breadCrumbs breadCrumbs_Filter")
            .call((breadCrumbs_Filter) => {
            breadCrumbs_Filter
                .append("div")
                .attr("class", "breadCrumbHeader")
                .tooltip(i18n.RemoveAllFilters)
                .text(i18n.Filters)
                .on("click", () => this.clearFilters_All());
            breadCrumbs_Filter
                .append("div")
                .attr("class", "breadCrumbCollapseControl far fa-angle-double-right")
                .tooltip("", {
                onTrigger: (instance) => {
                    instance.reference.tippy.setContent(i18n[(breadCrumbs_Filter.node().classList.contains("collapsed")
                        ? "Show"
                        : "Hide") + " Filters"]);
                },
            })
                .on("click", () => {
                var cl = breadCrumbs_Filter.node().classList;
                cl.toggle("collapsed");
                if (!cl.contains("collapsed")) {
                    this.filters_wrap_letItWrap = true;
                }
            });
        });
        this.DOM.breadCrumbs_Compare = this.DOM.panel_Basic_In
            .append("div")
            .attr("class", "breadCrumbs breadCrumbs_Compare")
            .call((breadCrumbs_Compare) => {
            breadCrumbs_Compare
                .append("span")
                .attr("class", "breadCrumbHeader")
                .tooltip(i18n.Unlock)
                .text(i18n.Compare)
                .on("click", () => this.clearSelect_Compare(this.activeComparisons, true, true))
                .append("span")
                .attr("class", "lockCrumbSummary blockName");
        });
    }
    /** -- */
    applyConfig(config) {
        return __awaiter(this, void 0, void 0, function* () {
            // Import panel config
            Base.Panel_List.forEach((p) => this.panels[p].importConfig(Object.assign(Object.assign({}, config.panels[p]), config.panels.default)));
            config.summaries = config.summaries || [];
            for (let cfg of config.summaries) {
                yield this.applyBlockConfig(cfg);
            }
            if (config.recordName && this.recordName !== config.recordName) {
                this.setRecordName(config.recordName);
            }
            if (config.metric) {
                var a = this.attribWithName(config.metric.summary);
                if (a instanceof Attrib_Numeric) {
                    yield this.measureSummary.set(a);
                    yield this.measureFunc.set(config.metric.type);
                }
            }
            else {
                yield this.measureFunc.set("Count");
            }
            yield this.breakdownMode.set(config.breakdownMode);
            yield this.stackedCompare.set(config.stackedCompare);
            yield this.filteringMode.set(config.filteringMode);
            yield this.showWholeAggr.set(config.showWholeAggr);
            yield this.mouseOverCompare.set(config.mouseOverCompare);
            yield this.recordDisplay.importConfig(config.recordDisplay);
            this.records.forEach((rec) => rec.refreshFilterCache());
            this.updateRecordCount_Active();
            this.updateAfterFilter();
            this.updateLayout();
        });
    }
    /* -- */
    insertDOM_Panel_Overlay() {
        this.DOM.overlay_wrapper = this.DOM.root
            .append("div")
            .attr("class", "overlay_wrapper");
        // BACKGROUND
        this.DOM.overlay_wrapper
            .append("div")
            .attr("class", "fullBackground")
            .on("click", (event) => {
            if (!event.currentTarget.parentNode.classList.contains("easyDismiss"))
                return;
            this.DOM.overlay_wrapper.attr("show", "none");
            this.recordDetailsPopup.closeRecordDetailPanel();
            Modal._removeModal(this.DOM.overlay_wrapper);
        });
        // LOADING BOX
        this.DOM.loadingBox = this.DOM.overlay_wrapper
            .append("div")
            .attr("class", "overlay_content overlay_loading");
        this.DOM.loadingBox
            .append("span")
            .attr("class", "spinner")
            .selectAll(".spinner_x")
            .data([1, 2, 3, 4, 5])
            .enter()
            .append("span")
            .attr("class", (d) => "spinner_x spinner_" + d);
        var status_text = this.DOM.loadingBox.append("div").attr("class", "status_text");
        status_text
            .append("span")
            .attr("class", "status_text_sub info")
            .html(i18n.LoadingData);
        status_text
            .append("span")
            .attr("class", "status_text_sub dynamic");
        // CREDITS
        this.DOM.overlay_infobox = this.DOM.overlay_wrapper
            .append("div")
            .attr("class", "overlay_content overlay_infobox");
        this.DOM.overlay_infobox
            .append("div")
            .attr("class", "overlay_Close fa fa-times fa-times-circle")
            .tooltip(i18n.Close)
            .on("click", () => this.DOM.overlay_wrapper.attr("show", "none"));
        // RECORD DETAILS
        this.recordDetailsPopup.initDOM();
        // HELP
        this.DOM.overlay_wrapper
            .append("div")
            .attr("class", "overlay_content overlay_help");
    }
    showCredits() {
        if (this.creditsInserted)
            return;
        this.DOM.overlay_infobox
            .append("div")
            .attr("class", "creditsBox")
            .html(`<div style="text-align: center;">
  <a target='_blank' href='https://keshif.me'><img class='kshfLogo'></a>
</div>
<div>
  <a class='creditsLink' target='_blank' href='https://keshif.me/Terms'>Terms of Use</a>
  <a class='creditsLink' target='_blank' href='https://keshif.me/Privacy'>Privacy Policy</a>
  <a class='creditsLink' target='_blank' href='https://keshif.me/License'>Other Licenses</a>
</div>
<div class='copyright'>© Keshif, LLC 203. All rights reserved.</div>
`);
        this.creditsInserted = true;
    }
    /** -- */
    helper_AddSidePanelGroup(className, _title, _tooltip) {
        this.DOM[className] = this.DOM.authoringPanel
            .append("div")
            .attr("class", "sidePanelGroup " + className);
        var xx = this.DOM[className]
            .append("div")
            .attr("class", "sidePanelGroupHeader");
        xx.append("span").html(_title);
        xx.select(".fa").tooltip(_tooltip);
        xx.append("span")
            .attr("class", "closeAttribPanel fa fa-window-close")
            .tooltip(i18n.Close)
            .on("click", () => __awaiter(this, void 0, void 0, function* () { return yield this.dashboardMode.set("Explore"); }));
        return this.DOM[className]
            .append("div")
            .attr("class", "sidePanelGroupContent");
    }
    /** -- */
    refreshAttibFilterState() {
        this.DOM.dataTypeFilters.classed("active", (_) => _.active);
        var filterActive = this.dataTypeDescrs.some((_) => _.active);
        var filterLevel;
        var isExcluded = (_) => {
            var visibleSubItems = filterLevel(Object.values(_.sub));
            if (visibleSubItems > 0)
                return false;
            if (typeof _.item === "string") {
                return visibleSubItems === 0; // no visible items in the sub-tree
            }
            _ = _.item;
            if (this.attribTextQuery) {
                // also searches the query in descriptions
                var searchIn = (_.attribName + (_.description ? " " + _.description : "")).toLowerCase();
                if (searchIn.indexOf(this.attribTextQuery) === -1)
                    return true; // not found
            }
            if (!filterActive)
                return false;
            return !this.dataTypeDescrs.some((descr) => descr.active && descr.member(_));
        };
        filterLevel = (items) => {
            var visibleCount = 0;
            items.forEach((_) => {
                var s = isExcluded(_);
                d3.select(_.DOM).classed("filtered", s);
                if (!s)
                    visibleCount++;
            });
            return visibleCount;
        };
        this.removeEmptySubs();
        filterLevel(Object.values(this.attribs_by_group));
    }
    /** -- */
    refreshAttibButtonState() {
        this.DOM.dataTypeFilters.classed("hidden", (_) => this.attribs.every((attrib) => { var _a; return !((_a = attrib === null || attrib === void 0 ? void 0 : attrib.block) === null || _a === void 0 ? void 0 : _a.hasNugget) || !_.member(attrib); }));
    }
    get attribPanelWidth() {
        return this._attribPanelWidth;
    }
    /** -- */
    setAttribPanelWidth(v) {
        v = Number(v);
        if (typeof v !== "number" || isNaN(v))
            return;
        v = Math.max(Math.min(v, 400), 200);
        if (v === this._attribPanelWidth)
            return;
        this._attribPanelWidth = v;
        this.DOM.authoringPanel.style("width", this._attribPanelWidth + "px");
        this.updateLayout();
    }
    /** -- */
    insertDOM_AttribPanel() {
        this.DOM.authoringPanel = this.DOM.root
            .append("div")
            .attr("class", "authoringPanel");
        this.DOM.authoringPanel.style("width", this._attribPanelWidth + "px");
        // ****************************************************************************
        // ***************************************************************************
        var attributeInfo = this.helper_AddSidePanelGroup("attributePanel", `<i class='panelIcon fal fa-cube'></i> ${i18n.Attributes}`, "<b>Author</b> your dashboard<br> using dataset attributes");
        attributeInfo
            .append("div")
            .attr("class", "panelAdjustWidth")
            .tooltip(i18n["Adjust Panel Width"])
            .on("mousedown", (event) => {
            if (event.which !== 1)
                return; // only respond to left-click
            var mouseDown_width = this._attribPanelWidth - d3.pointer(event, document.body)[0];
            this.activateWidthDrag(event.currentTarget, event, (event2) => {
                this.setAttribPanelWidth(mouseDown_width + d3.pointer(event2, document.body)[0]);
            });
        })
            .on("click", (event) => {
            event.stopPropagation();
            event.preventDefault();
        });
        var attributePanelFilters = attributeInfo
            .append("div")
            .attr("class", "attributePanelFilters");
        this.DOM.dataTypeFilters = attributePanelFilters
            .append("div")
            .attr("class", "dataTypeFilters")
            .selectAll("div")
            .data(this.dataTypeDescrs)
            .enter()
            .append("div")
            .each((_) => {
            _.active = false;
        })
            .attr("class", (_) => "filterTypeButton " + _.icon)
            .html((_) => _.iconDiv)
            .tooltip((_) => i18n[_.name + "Attribute"], { placement: "bottom" })
            .on("click", (event, _) => {
            _.active = !_.active;
            this.refreshAttibFilterState();
        });
        var attributePanelControl;
        attributePanelFilters
            .append("div")
            .attr("class", "filterTypeButton attribTextSearchIcon far fa-search")
            .on("click", (event) => {
            event.currentTarget.classList.toggle("active");
            attributePanelControl.node().classList.toggle("active");
            this.DOM.attribTextSearch.select("input").node().focus();
        });
        attributePanelFilters
            .append("div")
            .attr("class", "filterTypeButton attribListConfiguration fal fa-cog")
            .tooltip(i18n.Configure, { placement: "bottom" })
            .on("click", (event) => Modal.popupMenu(event, MenuOpts.AttribPanel, this));
        attributePanelControl = attributeInfo
            .append("div")
            .attr("class", "attributePanelControl");
        // *******************************************************
        // TEXT SEARCH
        // *******************************************************
        this.DOM.attribTextSearch = attributePanelControl
            .append("span")
            .attr("class", "textSearchBox attribTextSearch");
        this.DOM.attribTextSearch
            .append("input")
            .attr("class", "textSearchInput")
            .attr("type", "text")
            .attr("placeholder", i18n.Search)
            .on("keydown", (event) => event.stopPropagation())
            .on("keypress", (event) => event.stopPropagation())
            .on("keyup", (event) => event.stopPropagation())
            .on("input", (event) => {
            var DOM = event.currentTarget;
            if (DOM.timer)
                clearTimeout(DOM.timer);
            this.attribTextQuery = DOM.value.toLowerCase();
            this.DOM.attribTextSearch.classed("showClear", this.attribTextQuery !== "");
            DOM.timer = setTimeout(() => this.refreshAttibFilterState(), 250);
        });
        this.DOM.attribTextSearch
            .append("span")
            .attr("class", "fa fa-times-circle")
            .tooltip(i18n.ClearTextSearch)
            .on("click", () => {
            this.attribTextQuery = "";
            this.DOM.attribTextSearch
                .classed("showClear", false)
                .select("input")
                .property("value", "");
            this.refreshAttibFilterState();
        });
        this.DOM.attributeList = attributeInfo
            .append("div")
            .attr("class", "attributeList");
        this.DOM.boostButton = attributeInfo
            .append("div")
            .attr("class", "boostButton")
            .html("<i class='fal fa-rocket-launch'></i> Boost")
            .tooltip("Auto-boost dashboard")
            .on("click", () => this.runMagic());
    }
    /** -- */
    collapseAttribListGroups(v = true) {
        this.DOM.root
            .selectAll(".AttribListItem.hasSubItems")
            .nodes()
            .forEach((node) => {
            node.classList[v ? "add" : "remove"]("collapsed");
        });
    }
    /** -- */
    refreshAttribList() {
        if (!this.finalized)
            return;
        var recurse = (_selection, level) => _selection.each((_item, i, nodes) => {
            refreshLevel(d3.select(nodes[i]).select(".subItems"), _item.sub, level + 1);
        });
        var refreshLevel = (_dom, _data, level) => {
            _data = Object.values(_data).sort((a, b) => {
                var isGroup_A = Object.keys(a.sub).length > 0 && typeof a.item === "string";
                var isGroup_B = Object.keys(b.sub).length > 0 && typeof b.item === "string";
                // folders first
                if (isGroup_A !== isGroup_B)
                    return +isGroup_B - +isGroup_A;
                // first by type, then by name
                var diff = Util.getAttribTypeOrder(a.item.type) -
                    Util.getAttribTypeOrder(b.item.type);
                return diff ? diff : Util.sortFunc_List_String(a.name, b.name);
            });
            _dom.selectAll("div.AttribListItem-Level" + level).remove();
            _dom
                .selectAll("div.AttribListItem-Level" + level)
                .data(_data, (_) => _.name + "_" + typeof _.item)
                .join((enter) => {
                var listItems = enter
                    .append("div")
                    .attr("class", "AttribListItem AttribListItem-Level" + level)
                    .classed("hasSubItems", (_) => Object.entries(_.sub).length > 0)
                    .classed("collapsed", true);
                listItems
                    .append("div")
                    .attr("class", "nugget")
                    //.attr("tempColumnName",   _ => _.item.template.str || null)
                    .classed("inDashboard", (_) => { var _a, _b; return (_b = (_a = _.item) === null || _a === void 0 ? void 0 : _a.block) === null || _b === void 0 ? void 0 : _b.inDashboard; })
                    .classed("condensedText", (_) => { var _a; return ((_a = _.name) === null || _a === void 0 ? void 0 : _a.length) > 30; })
                    .each((_, i, nodes) => {
                    var _a, _b;
                    _.DOM = nodes[i];
                    var isGroup = typeof _.item === "string";
                    let _dom = d3.select(nodes[i]);
                    _dom.on("click", (event) => {
                        if (event.which !== 1)
                            return; // only respond to left-click
                        nodes[i].parentNode.classList.toggle("collapsed");
                    });
                    _dom
                        .append("div")
                        .attr("class", "groupControl")
                        .tooltip(i18n["Open/Close"])
                        .on("click", (event) => {
                        event.stopPropagation();
                        event.preventDefault();
                        nodes[i].parentNode.classList.toggle("collapsed");
                    })
                        .append("div")
                        .attr("class", "fa fa-caret-down");
                    _dom
                        .append("span")
                        .attr("class", "nuggetIcon")
                        .append("div")
                        .attr("class", isGroup ? "fa fa-circle" : (_a = _.item) === null || _a === void 0 ? void 0 : _a.nuggetClassName);
                    _dom
                        .append("span")
                        .attr("class", "summaryName")
                        .html(_.name)
                        .tooltip(i18n.EditTitle);
                    var Y = _dom
                        .append("div")
                        .attr("class", "iconWrapper")
                        .on("dblclick", (event) => {
                        event.stopPropagation();
                        event.preventDefault();
                    });
                    if (!isGroup) {
                        let a = _.item;
                        if (a.attribName === this.idSummaryName) {
                            Y.append("div")
                                .attr("class", "summaryRecordIDIcon far fa-fingerprint")
                                .tooltip(i18n["Record ID"], { placement: "bottom" });
                        }
                        if (a.type === "categorical") {
                            Y.append("div")
                                .attr("class", "summaryMultiCat far fa-tags")
                                .tooltip(i18n.MultiValued, { placement: "bottom" });
                        }
                        // no descriptions of simple groups currently
                        Y.append("div")
                            .attr("class", "summaryDescription far fa-info-circle")
                            .classed("active", !!a.description)
                            .tooltip(a.description, { placement: "bottom" })
                            .on("click", function () {
                            this.tippy.show();
                        });
                        (_b = a.block) === null || _b === void 0 ? void 0 : _b.refreshNugget(_dom);
                    }
                    Y.append("div")
                        .attr("class", "showDeriveMenu fa fa-ellipsis-v")
                        .tooltip(i18n.Settings, { placement: "bottom" })
                        .on("mousedown", (event) => event.stopPropagation())
                        .on("click", (event) => {
                        event.currentTarget.parentNode.parentNode.classList.add("popupVisible");
                        if (isGroup) {
                            Modal.popupMenu(event, MenuOpts.Attrib_Grouping, _);
                        }
                        else {
                            _.item.initializeAggregates();
                            Modal.popupMenu(event, MenuOpts.Attribute, _.item);
                        }
                        event.stopPropagation();
                        event.preventDefault();
                    });
                });
                listItems.append("div").attr("class", "subItems");
                recurse(listItems, level);
                return listItems;
            }, (update) => recurse(update, level), (exit) => exit.remove())
                .order();
        };
        this.removeEmptySubs();
        refreshLevel(this.DOM.attributeList, this.attribs_by_group, 0);
        this.refreshAttibButtonState();
    }
    /** -- */
    showFullscreen() {
        this.isFullscreen = this.isFullscreen ? false : true;
        var elem = this.DOM.root.node();
        if (this.isFullscreen) {
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            }
            else if (elem.msRequestFullscreen) {
                elem.msRequestFullscreen();
            }
            else if (elem.mozRequestFullScreen) {
                elem.mozRequestFullScreen();
            }
            else if (elem.webkitRequestFullscreen) {
                elem.webkitRequestFullscreen();
            }
        }
        else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
            else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
            else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            }
            else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            }
        }
    }
    /** Setter & getter accecss so that UI can be updated when data is updated */
    set loadedTableCount(v) {
        var _a;
        this._loadedTableCount = v;
        (_a = this.DOM.root) === null || _a === void 0 ? void 0 : _a.select('.status_text_sub').text(`(${this._loadedTableCount} / ${this._totalTableCount})`);
    }
    get loadedTableCount() {
        return this._loadedTableCount;
    }
    /** -- */
    loadDataSources() {
        this.DOM.overlay_wrapper.attr("show", "loading");
        DataTable.registerLoader(new DataLoader_FetchURL());
        DataTable.registerLoader(new DataLoader_GoogleSheets());
        this.insertDOM_Panel_DatasetInfo();
        var tableLoadPromises = [];
        if (this.options.source) {
            let tableSpecs = this.options.source;
            if (!Array.isArray(tableSpecs)) {
                tableSpecs = [tableSpecs];
            }
            this.loadedTableCount = 0;
            this._totalTableCount = tableSpecs.length;
            tableLoadPromises = tableSpecs.map((tableDescr, i) => __awaiter(this, void 0, void 0, function* () {
                var dt = new DataTable(tableDescr);
                yield dt.load();
                this._loadedTableCount++;
                if (i === 0) {
                    this.primaryTableName = dt.name;
                    this.idSummaryName = dt.id || "id";
                    if (dt.linkToData) {
                        this.DOM.datasource
                            .style("display", "inline-block")
                            .attr("href", dt.linkToData);
                    }
                }
                return true;
            }));
        }
        // Execute async data loading on multiple tables
        Promise.all(tableLoadPromises)
            // load charts
            .then(() => {
            var _a;
            if (!this.primaryTableName) {
                Modal.alert("Cannot load dashboard. Please define primaryTableName.");
                return;
            }
            this.records = ((_a = Base.tables.get(this.primaryTableName)) === null || _a === void 0 ? void 0 : _a.records) || [];
            this.records.forEach((record, i) => {
                record.recordOrder = i;
            });
            this.setRecordName(this.recordName || this.primaryTableName);
            // uses setTimeout to be able to render the updated "Creating browser..." text.
            this.DOM.overlay_wrapper
                .select("div.status_text .info")
                .text(i18n.CreatingBrowser);
            this.DOM.overlay_wrapper.select("div.status_text .dynamic").text("");
            window.setTimeout(() => __awaiter(this, void 0, void 0, function* () { return this._loadCharts(); }), 20);
        })
            .catch((err) => {
            console.log(err);
            Modal.alert("Error in loading data.<br><br> Error: " + err);
        });
    }
    /** -- */
    prepBlockConfig(blockCfg) {
        // **************************************************
        // Deprecated/renamed configurations
        if (blockCfg.showPercentile)
            blockCfg.showPercentiles = blockCfg.showPercentile;
        if (blockCfg.intervalScale)
            blockCfg.valueScaleType = blockCfg.intervalScale;
        if (blockCfg.scaleType)
            blockCfg.valueScaleType = blockCfg.scaleType;
        if (blockCfg.minAggrValue)
            blockCfg.minAggrSize = blockCfg.minAggrValue;
        if (blockCfg.supportsCompareLock === false) {
            blockCfg.isComparable = false;
        }
        // Set type of summary automatically if type-specific attributes have been defined
        if (!blockCfg.type) {
            if (blockCfg.catLabel ||
                blockCfg.catTooltip ||
                blockCfg.catSortBy ||
                blockCfg.catGeo ||
                blockCfg.barHeight ||
                blockCfg.showSetMatrix) {
                blockCfg.type = "categorical";
            }
            else if (blockCfg.showPercentile || blockCfg.skipZero) {
                blockCfg.type = "numeric";
            }
            else if (blockCfg.recordGeo) {
                blockCfg.type = "recordGeo";
            }
            else if (blockCfg.content) {
                blockCfg.type = "content";
            }
        }
    }
    /** -- */
    applyBlockConfig(attribCfg) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (Object.keys(attribCfg).length === 0)
                return; // NO-OP
            if (attribCfg.skipConfig)
                return;
            this.prepBlockConfig(attribCfg);
            var attrib = this.attribWithName(attribCfg.name);
            var _byValue = null;
            if (typeof attribCfg.value === "string" && attribCfg.type !== "recordGeo") {
                _byValue = this.attribWithName(attribCfg.value);
            }
            if (!attrib && _byValue) {
                // converting name from "value" to "name"
                attrib = _byValue;
                attrib.attribName = attribCfg.name;
            }
            else {
                if (attrib &&
                    attribCfg.value &&
                    attribCfg.value !== attribCfg.name &&
                    attrib.template.str !== attribCfg.value) {
                    // redefining the attrib with the requested name using the new value function
                    attrib.destroy();
                }
                attrib = this.createAttrib(attribCfg.name, attribCfg.value, attribCfg.type);
            }
            // handle summary/attribCfg type mismatch...
            if (attribCfg.type && attribCfg.type !== attrib.type) {
                attrib.destroy();
                attribCfg.value = attribCfg.value || attribCfg.name;
                if (typeof attribCfg.value === "string") {
                    attrib = this.createAttrib(attribCfg.value, null, attribCfg.type);
                    attrib.attribName = attribCfg.name;
                }
                else if (typeof attribCfg.value === "function") {
                    attrib = this.createAttrib(attribCfg.name, attribCfg.value, attribCfg.type);
                }
            }
            // If attrib object is not found/created, nothing else to do
            if (!attrib)
                return;
            yield attrib.applyConfig(attribCfg);
            if (attrib.isEmpty() &&
                (attrib instanceof Attrib_Categorical ||
                    attrib instanceof Attrib_Interval)) {
                attrib.destroy();
                return;
            }
            if (attribCfg.panel) {
                (_a = attrib.block) === null || _a === void 0 ? void 0 : _a.addToPanel(this.panels[attribCfg.panel], undefined, true);
            }
        });
    }
    /** -- */
    runMagic() {
        var _a;
        var newConfig = this.exportConfig();
        var potentialChanges = [];
        // See if we can detect some auto-conversions!
        var recordKeys = Object.keys(this.records[0].data);
        // LAT_LONG conversion
        var latKey, longKey;
        var hasLat = recordKeys.some((k) => {
            latKey = k;
            var _ = k.toUpperCase();
            return ["LAT", "LATITUDE"].includes(_);
        });
        var hasLong = recordKeys.some((k) => {
            longKey = k;
            var _ = k.toUpperCase();
            return ["LON", "LONGITUDE", "LNG", "LONG"].includes(_);
        });
        if (hasLat && hasLong && !this.options.onLoad["_POINT"]) {
            potentialChanges.push({
                i: '<i class="far fa-map-marker"></i>',
                q: `(<b>${latKey}</b>, <b>${longKey}</b>) is the point location.`,
                a: () => {
                    this.options.onLoad["_POINT"] = `LAT_LONG(${latKey},${longKey})`;
                    // delete lat/long summaries
                    newConfig.summaries = newConfig.summaries.filter((cfg) => {
                        return cfg.name !== latKey && cfg.name !== longKey;
                    });
                    if (!newConfig.recordDisplay.geo)
                        newConfig.recordDisplay.geo = "_POINT";
                    if (newConfig.recordDisplay.viewAs === "none")
                        newConfig.recordDisplay.viewAs = "map";
                },
            });
        }
        // Derive time feature
        var timeStampSummaries = this.attribs.filter((attrib) => attrib instanceof Attrib_Timestamp);
        timeStampSummaries.forEach((attrib) => {
            [
                { typed: "month", derivative: "Month" },
                { typed: "day", derivative: "DayOfMonth" },
                { typed: "day", derivative: "WeekDay" },
                { typed: "hour", derivative: "Hour" },
            ].forEach((_opt) => {
                if (!attrib.timeTyped[_opt.typed] ||
                    attrib.derivatives[_opt.derivative]) {
                    return;
                }
                potentialChanges.push({
                    i: '<i class="far fa-calendar-day"></i>',
                    q: `Derive ${_opt.derivative} of <b>${attrib.attribName}</b>`,
                    a: () => {
                        newConfig.summaries.push({
                            name: attrib.attribName + "->" + _opt.derivative,
                            value: attrib.template.str + "->" + _opt.derivative + "()",
                            panel: "none",
                        });
                    },
                });
            });
        });
        // Detect TIMESERIES
        // Merge first ten records
        var _mergedRecData = {};
        this.records.slice(0, 10).forEach((rec) => {
            for (var k in rec.data) {
                _mergedRecData[k] = _mergedRecData[k] || [];
                _mergedRecData[k].push(rec.data[k]);
            }
        });
        recordKeys.forEach((k) => {
            var _values = _mergedRecData[k];
            _values.some((v) => {
                if (v == null || typeof v !== "object" || Array.isArray(v))
                    return false;
                // TO-DO: Process non-number, string types time series field info ("2017-05","2017-04", etc)
                // both keys and values must be numbers
                if (Object.entries(v).every(([key, val]) => {
                    return !isNaN(Number(key)) && val !== null && !isNaN(Number(val));
                })) {
                    potentialChanges.push({
                        i: '<i class="fa fa-chart-line"></i>',
                        q: `<b>${k}</b> is timeseries by year/order.`,
                        a: () => {
                            this.options.onLoad[k] = k + "->${DATETIME(%Y)}";
                            // Remove summaries of individual time keys
                            newConfig.summaries = newConfig.summaries.filter((s) => {
                                if (s.panel !== "none")
                                    return true;
                                var _t = new AttribTemplate(s.name, this);
                                return !(_t && _t.pathStr === k);
                            });
                        },
                    });
                    return true;
                }
                return false;
            });
        });
        // ZIPCODE?
        var isZipCode = (attrib) => {
            var _ = attrib.attribName;
            return _.toUpperCase() === "ZIP" || _.toUpperCase() === "ZIPCODE";
        };
        // Convert from integer to string
        this.attribs.forEach((attrib) => {
            if (attrib instanceof Attrib_Numeric && isZipCode(attrib)) {
                potentialChanges.push({
                    i: '<i class="far fa-map-marker"></i>',
                    q: `<b>${attrib.attribName}</b> is zipcode.`,
                    a: () => {
                        this.options.onLoad[attrib.template.str] = "STR()";
                        newConfig.summaries = newConfig.summaries.filter((_) => {
                            return _.name !== attrib.attribName;
                        });
                        attrib.destroy();
                    },
                });
            }
        });
        var numToDateMagic = [
            {
                // Serial dates
                filter: (attrib) => {
                    return (attrib instanceof Attrib_Numeric &&
                        attrib.aggr_initialized &&
                        !attrib.unitName &&
                        attrib.rangeOrg[0] >= 18264 && // =DATEVALUE("1/1/1950")
                        attrib.rangeOrg[1] <= 54789 && // =DATEVALUE("1/1/2050")
                        !isZipCode(attrib));
                },
                i: "hashtag",
                convert: "DATETIME(%sn)",
                message: " is a spreadsheet date field?",
            },
            {
                // Year only
                filter: (attrib) => {
                    return (attrib instanceof Attrib_Numeric &&
                        attrib.aggr_initialized &&
                        !attrib.unitName &&
                        attrib.rangeOrg[0] >= 1950 && // =DATEVALUE("1/1/1950")
                        attrib.rangeOrg[1] <= 2050 && // =DATEVALUE("1/1/2050")
                        !isZipCode(attrib));
                },
                convert: "DATETIME(%Y)",
                message: " stores year values?",
            },
            // Timestamp: -631152000 ... 2524608000
            // Range too wide. Need more complex analysis to detect if fields are potentially dates
        ];
        this.attribs.forEach((attrib) => {
            numToDateMagic.some((_) => {
                if (_.filter(attrib)) {
                    potentialChanges.push({
                        i: '<i class="fa fa-calendar-day"></i>',
                        q: attrib.attribName + _.message,
                        a: () => {
                            this.options.onLoad[attrib.template.str] = _.convert;
                            // delete the type of existing attrib
                            newConfig.summaries
                                .filter((s) => s.name === attrib.attribName)
                                .forEach((c) => delete c.type);
                        },
                    });
                }
                return false;
            });
        });
        // SPLIT CATEGORIES
        this.attribs.forEach((attrib) => {
            if (!(attrib instanceof Attrib_Categorical) || attrib.isEmpty())
                return;
            var allText = "";
            attrib._aggrs.forEach((aggr) => {
                allText += aggr.id;
            });
            [
                { char: ",", convert: "SPLIT(\\s*,\\s*)" },
                { char: ";", convert: "SPLIT(\\s*;\\s*)" },
                { char: "|", convert: "SPLIT(\\s*\\|\\s*)" },
                { char: "+", convert: "SPLIT(\\s*\\+\\s*)" },
            ].forEach((_) => {
                var n = allText.split(_.char).length - 1;
                if (n <= allText.length / 20)
                    return;
                potentialChanges.push({
                    i: '<i class="far fa-tags"></i>',
                    q: `<b>${attrib.attribName}</b> has multiple categories split by <b>${_.char}</b>`,
                    a: () => {
                        this.options.onLoad[attrib.template.str] = _.convert;
                    },
                });
            });
        });
        // Detect ID field
        var recordTextCandidate = null;
        if (this.idSummaryName === "id") {
            let candidateSummaries = this.attribs.filter((attrib) => {
                if (attrib instanceof Attrib_Categorical &&
                    attrib.uniqueCategories() &&
                    attrib.template.str &&
                    attrib.template.str !== "id") {
                    var allText = "";
                    attrib._aggrs.forEach((aggr) => {
                        allText += aggr.id;
                    });
                    attrib["___temp"] = allText.length;
                    return true;
                }
                return false;
            });
            candidateSummaries.sort((a, b) => a["___temp"] - b["___temp"]); // shortest first
            var idCandidate = candidateSummaries[0];
            if (idCandidate) {
                potentialChanges.push({
                    i: "<i class='far fa-fingerprint'></i>",
                    q: `<b>${idCandidate.attribNameHTML}</b> is the unique fingerprint (ID) of the ${this.recordName}`,
                    a: () => {
                        newConfig.source.tables[0].id = idCandidate.template.str;
                        if (this.attribWithName("id"))
                            this.attribWithName("id").destroy();
                        newConfig.summaries = newConfig.summaries.filter((_) => {
                            return _.name !== "id";
                        });
                    },
                });
            }
            recordTextCandidate = candidateSummaries[1] || candidateSummaries[0];
        }
        if (!this.recordDisplay.codeBy.text) {
            if (!recordTextCandidate) {
                let candidateSummaries = this.attribs
                    .filter((attrib) => {
                    if (attrib.type === "categorical" &&
                        attrib.template.str &&
                        attrib.template.str !== "id" &&
                        attrib._aggrs) {
                        attrib["___temp"] = attrib._aggrs.length;
                        return true;
                    }
                    return false;
                })
                    .sort((a, b) => b["___temp"] - a["___temp"]); // longest first
                recordTextCandidate = candidateSummaries[0];
            }
            if (recordTextCandidate) {
                potentialChanges.push({
                    i: '<i class="fa fa-font"></i>',
                    q: `<b>${recordTextCandidate.summaryName}</b> can be used as record text.`,
                    a: () => {
                        newConfig.recordDisplay.textBy = recordTextCandidate.summaryName;
                        if (newConfig.recordDisplay.viewAs === "none") {
                            newConfig.recordDisplay.viewAs = "list";
                        }
                    },
                });
            }
        }
        if (timeStampSummaries.length > 0 &&
            timeStampSummaries.length < 3 &&
            this.panels.bottom.isEmpty()) {
            let attrib = timeStampSummaries[0];
            if (!((_a = attrib.block) === null || _a === void 0 ? void 0 : _a.inDashboard)) {
                potentialChanges.push({
                    i: '<i class="fa fa-th"></i>',
                    q: `Place <b>${attrib.attribName}</b> on dashboard bottom`,
                    a: () => {
                        newConfig.summaries.forEach((s) => {
                            if (s.name === attrib.attribName)
                                s.panel = "bottom";
                        });
                    },
                });
            }
        }
        this.attribs.forEach((attrib) => {
            delete attrib["___temp"];
        });
        if (potentialChanges.length === 0) {
            Modal.alert(i18n.Boost_NoSuggestions);
        }
        else {
            // set change by default
            potentialChanges.forEach((c) => {
                if (c.change === undefined)
                    c.change = true;
            });
            Modal.autoChanges(potentialChanges).then((potentialChanges) => {
                var reloadDashboard = false;
                potentialChanges.forEach((_) => {
                    if (_.change) {
                        _.a();
                        reloadDashboard = true;
                    } // apply
                });
                if (reloadDashboard) {
                    // delete the loaded dataset, so onLoad work correctly
                    Base.tables.delete(this.primaryTableName);
                    window.dashboard = new Browser(newConfig);
                }
                else {
                    // No changes applied. Remove animation.
                    if (this.DOM.boostButton)
                        this.DOM.boostButton.classed("animate", false);
                }
            }, () => {
                // Cancel changes
                if (this.DOM.boostButton)
                    this.DOM.boostButton.classed("animate", false);
            });
        }
    }
    /** -- */
    _loadCharts() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.chartsLoaded)
                return;
            this.DOM.root.classed("dataLoaded", true);
            if (this.records.length === 0) {
                Modal.alert(`Dataset (${this.recordName}) includes no records.`);
                return;
            }
            // process non-function specifications.
            for (var _key in this.onLoad.main) {
                applyPreProc(_key, this.onLoad.main[_key], this.records);
            }
            (_a = this.onLoad.callback) === null || _a === void 0 ? void 0 : _a.call(this);
            loadMapStandards();
            // apply panel layout
            if (!this.options.panels) {
                this.options.panels = {};
            }
            if (!this.options.panels.default) {
                this.options.panels.default = {};
            }
            if (this.options.panels.default.catBarWidth == null) {
                this.options.panels.default.catBarWidth = (() => {
                    var totalWidth = this.divWidth;
                    ["left", "middle", "right"].forEach((panelName) => {
                        if (this.panels[panelName].isEmpty())
                            return;
                        totalWidth -=
                            this.panels[panelName].width_Real -
                                this.panels[panelName].width_CatBars;
                    });
                    return Math.floor(totalWidth / 8);
                })();
            }
            ["left", "middle", "right"].forEach((side) => {
                let deprecatedPanelLabelWidth = this.options[side + "PanelLabelWidth"];
                if (deprecatedPanelLabelWidth) {
                    if (!this.options.panels[side])
                        this.options.panels[side] = {};
                    this.options.panels[side].catLabelWidth =
                        deprecatedPanelLabelWidth;
                }
            });
            yield this.breakdownMode.set(this.options.breakdownMode);
            yield this.stackedCompare.set(this.options.stackedCompare);
            yield this.filteringMode.set(this.options.filteringMode);
            yield this.showWholeAggr.set(this.options.showWholeAggr);
            yield this.mouseOverCompare.set(this.options.mouseOverCompare);
            this.records.forEach((rec) => this.allRecordsAggr.addRecord(rec));
            if (this.options.attribPanelWidth) {
                this.setAttribPanelWidth(this.options.attribPanelWidth);
            }
            if (this.options.colorTheme) {
                this.colorTheme = Object.assign(this.colorTheme, this.options.colorTheme);
            }
            Base.Panel_List.forEach((p) => this.panels[p].importConfig(this.options.panels[p]));
            // look at first "autoDetect_RowCount" rows to identify the column names
            var firstFiveRow_Cols = {};
            function _recurse(_src, _trgt) {
                if (!_src)
                    return;
                for (var _key in _src) {
                    var _v = _src[_key];
                    if (_v == null)
                        continue;
                    if (_v != null &&
                        typeof _v === "object" &&
                        !(_v instanceof Date) &&
                        !Array.isArray(_v) &&
                        !_v._timeseries_ &&
                        !_v.geometry &&
                        !_v.coordinates // map
                    ) {
                        // Object index
                        _trgt[_key] = _trgt[_key] || {};
                        _recurse(_v, _trgt[_key]);
                    }
                    else {
                        _trgt[_key] = _v;
                    }
                }
            }
            this.records
                .slice(0, Base.autoDetect_RowCount)
                .forEach((rec) => _recurse(rec.data, firstFiveRow_Cols));
            // Create a summary for each existing column in the data
            // Separated to a function to work recursively
            var addAttribs = (parentPath, _obj, timeSeriesParent = false) => {
                for (var attribName in _obj) {
                    if (typeof attribName !== "string") {
                        continue;
                    }
                    var _v = _obj[attribName];
                    if (_v != null && _v._timeseries_) {
                        let s = this.createAttrib(parentPath + attribName);
                        if (s) {
                            s.initializeAggregates();
                        }
                        // addAttribs(parentPath + attribName + "->", _v, true);
                        //
                    }
                    else if (_v != null &&
                        typeof _v === "object" &&
                        !(_v instanceof Date) &&
                        !Array.isArray(_v) &&
                        !_v.geometry &&
                        !_v.coordinates // map
                    ) {
                        addAttribs(parentPath + attribName + "->", _v);
                    }
                    else {
                        if (!timeSeriesParent) {
                            let s = this.createAttrib(parentPath + attribName);
                            if (s) {
                                s.initializeAggregates();
                            }
                        }
                    }
                }
            };
            addAttribs("", firstFiveRow_Cols);
            this.recordDisplay = new RecordDisplay(this, this.options.recordDisplay || {});
            if (this.options.metric) {
                var metric = this.options.metric;
                if (typeof metric === "string")
                    metric = { type: "Sum", summary: metric };
                let a = this.attribWithName(metric.summary);
                if (a instanceof Attrib_Numeric) {
                    yield this.measureSummary.set(a);
                    yield this.measureFunc.set(metric.type);
                }
            }
            this.options.summaries = this.options.summaries || [];
            for (let cfg of this.options.summaries) {
                yield this.applyBlockConfig(cfg);
            }
            yield this.recordDisplay.initialize();
            this.panels.bottom.refreshWidth();
            this.updateMiddlePanelWidth();
            this.records.forEach((rec) => rec.refreshFilterCache());
            this.updateRecordCount_Active();
            this.updateAfterFilter();
            // Load compare selections
            if (this.options.selections && !this.options.selections.auto) {
                var summary = this.attribWithName(this.options.selections.summary);
                Base.Compare_List.forEach((cT) => {
                    var selection = this.options.selections[cT];
                    if (!selection)
                        return;
                    if (!summary)
                        return;
                    summary.initializeAggregates();
                    var aggr;
                    if (summary instanceof Attrib_Categorical) {
                        aggr = summary.getAggrWithLabel(selection.id);
                    }
                    else if (summary instanceof Attrib_Numeric) {
                        this.flexAggrs[cT] = new Aggregate_Interval_Numeric(summary, selection.min, selection.max);
                        aggr = this.flexAggrs[cT];
                    }
                    if (!aggr)
                        return;
                    if (this.setSelect_Compare(aggr, cT, false)) {
                        this.lockSelect_Compare(false);
                    }
                });
            }
            this.enableAnalytics = true; // before this, do not run analytics computations
            this.refreshConfigs();
            // This needs to be called after analytics mode and configs are set-up.
            // Auto-compare works on "top" categories, which depend on various analytics & chart modes.
            if (this.options.selections && this.options.selections.auto) {
                (_b = this.attribWithName(this.options.selections.summary)) === null || _b === void 0 ? void 0 : _b.autoCompare();
            }
            this.checkBrowserZoomLevel();
            // hide overlay
            if (this.DOM.overlay_wrapper.selectAll(".overlay_modal").nodes().length === 0) {
                this.DOM.overlay_wrapper.attr("show", "none");
            }
            yield this.dashboardMode.set(this.options.dashboardMode);
            (_c = this.options.onReady) === null || _c === void 0 ? void 0 : _c.call(this);
            this.finalized = true;
            if (this.authorMode)
                this.refreshAttribList();
            // height of histograms depend on dashboard width, which depends on mode.
            this.updateLayout();
            setTimeout(() => this.setNoAnim(false), 1000);
            this.chartsLoaded = true;
            if (this.options.recordInDetail) {
                let record = Base.tables
                    .get(this.primaryTableName)
                    .getRecord(this.options.recordInDetail);
                this.recordDetailsPopup.updateRecordDetailPanel(record);
            }
        });
    }
    /** -- */
    unregisterBodyCallbacks() {
        d3.select("body")
            .on("mousemove.layout", null)
            .on("mouseup.layout", null)
            .on("keydown.layout", null);
    }
    /** -- */
    prepareDropZones(attrib, dropSource) {
        this.movedAttrib = attrib;
        this.showDropZones = true;
        this.DOM.root.classed("showDropZone", true).attr("dropSource", dropSource);
        this.DOM.attribDragBox.style("display", "block").html(attrib.attribName);
    }
    /** -- */
    clearDropZones() {
        this.movedAttrib = null;
        this.showDropZones = false;
        this.unregisterBodyCallbacks();
        this.DOM.root
            .classed("showDropZone", false)
            .attr("dropattrtype", null)
            .attr("dropSource", null);
        this.DOM.attribDragBox.style("display", "none");
    }
    /** -- */
    autoAddAttib(attrib) {
        var _a, _b;
        if ((_a = attrib === null || attrib === void 0 ? void 0 : attrib.block) === null || _a === void 0 ? void 0 : _a.inDashboard)
            return; //
        if (attrib instanceof Attrib_Timeseries) {
            this.recordDisplay.setAttrib("timeSeries", attrib)
                .then(() => __awaiter(this, void 0, void 0, function* () { return yield this.recordChartType.set("timeseries"); }));
            return;
        }
        if (attrib instanceof Attrib_RecordGeo) {
            this.recordDisplay.setAttrib("geo", attrib)
                .then(() => __awaiter(this, void 0, void 0, function* () { return yield this.recordChartType.set("map"); }));
            return;
        }
        if (attrib instanceof Attrib_Categorical && attrib.uniqueCategories()) {
            this.recordDisplay.setAttrib("text", attrib)
                .then(() => __awaiter(this, void 0, void 0, function* () { return yield this.recordChartType.set("list"); }));
            return;
        }
        var target_panel = {
            timestamp: "bottom",
            categorical: "left",
            numeric: "right",
        }[attrib.type] || "left";
        if (!this.panels[target_panel].welcomesNewBlock()) {
            target_panel = "middle";
        }
        (_b = attrib === null || attrib === void 0 ? void 0 : attrib.block) === null || _b === void 0 ? void 0 : _b.addToPanel(this.panels[target_panel]);
    }
    /** -- */
    getGlobalActiveMeasure() {
        if (this.allRecordsAggr.recCnt("Active") === 0)
            return i18n["No [Record]"];
        var numStr = this.allRecordsAggr.measure("Active").toLocaleString();
        return this.getMeasureFormattedValue(numStr);
    }
    /** -- */
    updateRecordCount_Active() {
        this.DOM.activeRecordMeasure.html(this.getGlobalActiveMeasure());
    }
    /** -- */
    get numOfActiveFilters() {
        return this.filters.filter((filter) => filter.isFiltered).length;
    }
    /** -- */
    isFiltered() {
        return this.numOfActiveFilters > 0;
    }
    /** -- */
    getFilteredSummaryText() {
        if (this.numOfActiveFilters === 0)
            return "";
        if (this.numOfActiveFilters > 1)
            return "filtered";
        var f = this.filters.find((filter) => filter.isFiltered);
        return f.getRichText_flipped();
    }
    /** -- */
    refresh_filterClearAll() {
        this.DOM.breadCrumbs_Filter.classed("isActive", this.isFiltered());
    }
    /** -- */
    clearFilters_All(exceptThis = null) {
        if (this.numOfActiveFilters === 0)
            return;
        // sometimes, it looks like the exceptThis selection is already filtered. Skip in that case
        if (this.numOfActiveFilters === 1 &&
            this.filters.filter((filter) => filter.isFiltered)[0] === exceptThis)
            return;
        if (this.skipSortingSummary) {
            // you can now sort the last filtered summary, attention is no longer there.
            this.skipSortingSummary.dirtySort = false;
        }
        // clear all registered filters
        this.filters.forEach((filter) => filter !== exceptThis && filter.clearFilter(false));
        // Only update records which were not wanted before.
        this.records.forEach((rec) => rec.filteredOut && rec.refreshFilterCache());
        this.updateRecordCount_Active();
        this.updateAfterFilter(true); // more results
        setTimeout(() => this.updateLayout_Height(), 1000); // update layout after 1 seconds
    }
    /** -- */
    updateAfterFilter(how = false) {
        Base.browser = this;
        Base.Compare_List.forEach((cT) => {
            var compared_Aggr = this.selectedAggrs[cT];
            if (compared_Aggr)
                this.refresh_Compare_Measures(compared_Aggr, cT);
        });
        this.refreshPanelsSyncedMeasureExtend();
        this.blocks.forEach((block) => block.updateAfterFilter(true)); // refresh viz
        this.recordDisplay.updateAfterFilter(how);
        this.updateWidth_CatMeasureLabels();
        this.refreshAllMeasureLabels();
        this.refresh_filterClearAll();
        this.filteringMode.refresh();
        this.needToRefreshLayout = true;
    }
    refreshAnalytics() {
        var _a, _b, _c;
        if (!this.enableAnalytics)
            return;
        (_b = (_a = this.DOM) === null || _a === void 0 ? void 0 : _a.root) === null || _b === void 0 ? void 0 : _b.classed("stackedCompare", this.stackedCompare.is(true)).classed("stackedChart", this.stackedChart).classed("showWholeAggr", this.showWholeAggr.is(true)).attr("breakdownMode", this.breakdownMode.get()).attr("measureFunc", this.measureFunc.get());
        this.updateWidth_CatMeasureLabels();
        if (this.stackedCompare.is(true)) {
            this.attribs.forEach((attrib) => {
                if (attrib.measureScale_Log)
                    attrib.measureScaleType.set("linear");
            });
        }
        this.refreshPanelsSyncedMeasureExtend();
        this.attribsInDashboard.forEach((attrib) => {
            attrib.updateChartScale_Measure(true); // skip refresh viz
            attrib.block.refreshViz_All();
            attrib.block.refreshMeasureDescrLabel();
            if (attrib instanceof Attrib_Categorical) {
                if (attrib.catOrder_Dynamic && attrib.catSortBy !== "Active") {
                    attrib.block.updateCatSorting(); // delay, with animation
                }
            }
        });
        (_c = this.recordDisplay.View) === null || _c === void 0 ? void 0 : _c.refreshSelect_Compare();
        this.refreshAllMeasureLabels();
    }
    /** -------------------------------------------------- */
    // Auto-computed from stacked compare setting
    get stackedChart() {
        if (this.stackedCompare.is(false))
            return false;
        if (this.activeComparisonsCount >= 1)
            return true;
        if (this.activeComparisonsCount === 0)
            return false;
        return this.lockedCompare[this.activeComparisons[0]]; // single comparison
    }
    /** -------------------------------------------------- */
    get exploreMode() {
        return this.dashboardMode.is("Explore");
    }
    get adjustMode() {
        return this.dashboardMode.is("Adjust");
    }
    get authorMode() {
        return this.dashboardMode.is("Author");
    }
    get captureMode() {
        return this.dashboardMode.is("Capture");
    }
    get saveMode() {
        return this.dashboardMode.is("Save");
    }
    /** -------------------------------------------------- */
    get measureFunc_Count() {
        return this.measureFunc.is("Count");
    }
    get measureFunc_Avg() {
        return this.measureFunc.is("Avg");
    }
    get measureFunc_Sum() {
        return this.measureFunc.is("Sum");
    }
    /** -------------------------------------------------- */
    get singleFiltering() {
        return this.filteringMode.is("single");
    }
    get chainedFiltering() {
        return this.filteringMode.is("chained");
    }
    /** -------------------------------------------------- */
    get absoluteBreakdown() {
        return this.breakdownMode.is("absolute");
    }
    get percentBreakdown() {
        return this.breakdownMode.get() != "absolute";
    }
    get relativeBreakdown() {
        return this.breakdownMode.is("relative");
    }
    get dependentBreakdown() {
        return this.breakdownMode.is("dependent");
    }
    get totalBreakdown() {
        return this.breakdownMode.is("total");
    }
    /** Updates shared (synced) measure extent within the panel (so bar charts can share the same scale) */
    refreshPanelsSyncedMeasureExtend() {
        Object.values(this.panels).forEach((panel) => panel.refreshSharedMeasureExtent());
    }
    /** -- */
    refreshAllMeasureLabels(t = null, _fixed = false) {
        if (!t) {
            // no mode specified, go through it all
            this.refreshAllMeasureLabels("Active", true);
            this.activeComparisons.forEach((cT) => this.refreshAllMeasureLabels(cT, true));
            return;
        }
        this.blocks.forEach((block) => {
            block.refreshMeasureLabelText(t);
            if (block instanceof Block_Categorical) {
                // refresh map visualization (TODO: fix/improve this part)
                if (!_fixed && block.isView_Map)
                    block.refreshViz(t);
            }
        });
    }
    /** -- */
    updateWidth_CatMeasureLabels() {
        Base.Panel_List.forEach((p) => this.panels[p].updateWidth_CatMeasureLabels());
    }
    /** True if selected comparison is active (checks selected aggregate)  */
    vizActive(key) {
        return this.selectedAggrs[key] !== null;
    }
    /** Locked attribute - equal to compared attribute, unless the compared one is not locked */
    get lockedAttrib() {
        var cT = Base.Compare_List.find((cT) => this.lockedCompare[cT]);
        return cT ? this.selectedAggrs[cT].attrib : null;
    }
    /** -- */
    get comparedAttrib() {
        var cT = Base.Compare_List.find((cT) => this.selectedAggrs[cT]);
        return cT ? this.selectedAggrs[cT].attrib : null;
    }
    /** Can select aggregate only with current active compared attribute */
    can_setSelect_Compare(aggr) {
        return !this.comparedAttrib || this.comparedAttrib === aggr.attrib;
    }
    /** -- */
    refresh_Compare_Measures(aggr, cT) {
        this.resetAllAggrMeasures(cT);
        aggr.records.forEach((record) => record.addToAggrMeasure(cT));
    }
    get activeComparisonsCount() {
        return this.activeComparisons.length;
    }
    get activeComparisons() {
        return Base.Compare_List.filter((cT) => this.vizActive(cT));
    }
    isCompared() {
        return this.activeComparisonsCount > 0;
    }
    /** Which Comparison (Compare_X) to use as highlighting */
    get Compare_Highlight() {
        return Base.Compare_List.find((cT) => {
            if (!this.lockedCompare[cT])
                return cT;
        });
    }
    /** Return the name for remaining "other" selection. Only valid if using categorical */
    get otherNameInCompare() {
        if (!this.comparedAttrib)
            return;
        if (this.comparedAttrib.type === "categorical") {
            var notCompared = this.comparedAttrib._aggrs.filter((_) => !_.compared);
            // only one other unselected option, no missing values, all that remains fall into one category
            if (notCompared.length === 1 &&
                this.comparedAttrib.noValueAggr.recCnt("Total") === 0) {
                return notCompared[0].label;
            }
        }
        return i18n.Other;
    }
    // creates a new breadcrumb for active highlight, and returns the previous crumb
    createNewCrumb() {
        let cT = this.Compare_Highlight;
        var r = this.crumbs[cT] || new BreadCrumb(this, cT);
        this.crumbs[cT] = new BreadCrumb(this, cT);
        return r;
    }
    isComparedSummaryMultiValued() {
        var a = this.comparedAttrib;
        if (a instanceof Attrib_Categorical) {
            return a.isMultiValued;
        }
        return false;
    }
    /** -- */
    get flexAggr_Highlight() {
        return this.flexAggrs[Base.Compare_List.find((cT) => !this.vizActive(cT))];
    }
    /** -- */
    set flexAggr_Highlight(aggr) {
        this.flexAggrs[Base.Compare_List.find((cT) => !this.vizActive(cT))] = aggr;
    }
    /** -- */
    refreshViz_Compare_All() {
        this.recordDisplay.refreshViz_Compare_All();
        this.blocks.forEach((block) => block.refreshViz_Compare_All());
    }
    /** -- */
    refreshComparedSummary() {
        var _a;
        if (!this.comparedAttrib)
            return;
        this.comparedAttrib.addDOMBlockName(this.DOM.breadCrumbs_Compare.select(".lockCrumbSummary"));
        (_a = this.comparedAttrib.block.DOM.root) === null || _a === void 0 ? void 0 : _a.classed("comparedSummary", true);
    }
    /** -- */
    lockSelect_Compare(refreshAnalytics = true) {
        var _a, _b, _c, _d;
        var cT = this.Compare_Highlight;
        if (!cT)
            return false; // cannot, sorry
        if (!this.vizActive(cT))
            return false;
        if (this.lockedCompare[cT])
            return false;
        if (!this.selectedAggrs[cT])
            return false;
        if ((_a = this.selectedAggrs[cT].attrib) === null || _a === void 0 ? void 0 : _a.isComparable.is(false)) {
            return false;
        }
        this.selectedAggrs[cT].lockSelection();
        this.lockedCompare[cT] = true;
        (_d = (_c = (_b = this.lockedAttrib) === null || _b === void 0 ? void 0 : _b.block) === null || _c === void 0 ? void 0 : _c.DOM.root) === null || _d === void 0 ? void 0 : _d.classed("lockedAttrib", true);
        if (refreshAnalytics)
            this.refreshAnalytics();
        return true;
    }
    /** -- */
    setSelect_Compare(selAggregate, cT = null, refreshAnalytics = true) {
        var _a;
        if (!selAggregate)
            return false;
        if (!cT)
            cT = this.Compare_Highlight;
        if (!cT)
            return false; // cT must be set beyond this point
        if (this.selectTimeouts[cT]) {
            window.clearTimeout(this.selectTimeouts[cT]);
            this.clearSelect_Compare(cT, false, true);
            delete this.selectTimeouts[cT];
        }
        // If there's active compared summary, cannot compare aggregate from another summary
        if (this.comparedAttrib &&
            selAggregate.attrib &&
            this.comparedAttrib !== selAggregate.attrib) {
            return false;
        }
        if (selAggregate !== this.flexAggr_Highlight) {
            // Already comparing that aggregate, nothing else to do
            if (this.vizActive(cT))
                return cT;
            if (selAggregate.compared)
                return cT;
        }
        this.addedCompare = true;
        this.DOM.root
            .classed("select" + cT, true)
            .classed("comparedMultiValue", this.isComparedSummaryMultiValued());
        this.DOM.breadCrumbs_Compare.classed("isActive", true);
        this.selectedAggrs[cT] = selAggregate;
        this.selectedAggrs[cT].selectCompare(cT);
        this.crumbs[cT].showCrumb(cT, (_a = selAggregate.attrib) === null || _a === void 0 ? void 0 : _a.summaryFilter);
        this.refreshComparedSummary();
        if (selAggregate.attrib instanceof Attrib_Interval) {
            selAggregate.attrib.block.refreshIntervalSlider([cT]);
        }
        this.blocks.forEach((block) => {
            if (block instanceof Block_Categorical) {
                if (block.isView_Dropdown)
                    block.dropdown_refreshCategories();
            }
        });
        if (refreshAnalytics) {
            this.refreshConfigs();
        }
        return cT;
    }
    /** -- */
    clearSelect_Compare(cT = this.Compare_Highlight, finalize = true, noWait = false) {
        if (!cT)
            return;
        if (!noWait && !Array.isArray(cT)) {
            if (this.selectTimeouts[cT])
                window.clearTimeout(this.selectTimeouts[cT]);
            this.selectTimeouts[cT] = window.setTimeout(() => {
                this.clearSelect_Compare(cT, finalize, true);
                delete this.selectTimeouts[cT];
            }, 750);
            return;
        }
        var comparedSummary_old = this.comparedAttrib;
        var lockedSummary_old = this.lockedAttrib;
        var finishClearSelect = () => {
            var _a, _b, _c;
            this.recordDisplay.refreshCompareLegend();
            this.blocks.forEach((block) => {
                if (block instanceof Block_Categorical && block.isView_Dropdown) {
                    block.dropdown_refreshCategories();
                }
            });
            if (this.comparedAttrib !== comparedSummary_old) {
                (_a = comparedSummary_old.block.DOM.root) === null || _a === void 0 ? void 0 : _a.classed("comparedSummary", false);
            }
            if (this.lockedAttrib !== lockedSummary_old) {
                (_c = (_b = lockedSummary_old.block) === null || _b === void 0 ? void 0 : _b.DOM.root) === null || _c === void 0 ? void 0 : _c.classed("lockedAttrib", false);
            }
            if (finalize) {
                this.refreshConfigs();
            }
        };
        if (Array.isArray(cT)) {
            cT.forEach((_) => this.clearSelect_Compare(_, false, noWait));
            finishClearSelect();
            return;
        }
        if (typeof cT !== "string")
            return;
        if (!this.vizActive(cT))
            return;
        this.addedCompare = false;
        this.crumbs[cT].removeCrumb();
        this.lockedCompare[cT] = false;
        if (this.selectedAggrs[cT]) {
            let a = this.selectedAggrs[cT].attrib;
            if (a instanceof Attrib_Interval) {
                a.block.refreshIntervalSlider([cT]);
            }
            this.selectedAggrs[cT].clearCompare(cT);
            this.selectedAggrs[cT] = null;
        }
        this.DOM.root.classed("select" + cT, this.vizActive(cT));
        this.DOM.breadCrumbs_Compare.classed("isActive", this.activeComparisonsCount !== 0);
        this.resetAllAggrMeasures(cT);
        if (finalize) {
            finishClearSelect();
        }
    }
    /** -- */
    resetAllAggrMeasures(t) {
        this.allAggregates.forEach((aggr) => aggr.resetMeasure(t));
    }
    /**************************************************************
     * MEASUREMENTS
     **************************************************************/
    /** -- */
    hasIntOnlyMeasure() {
        return (this.measureFunc_Count ||
            (this.measureFunc_Sum && !this.measureSummary.get().hasFloat));
    }
    /** --*/
    measureSumWithNegativeValues() {
        return this.measureFunc_Sum && this.measureSummary.get().hasNegativeValues();
    }
    /** --*/
    measureWithPositiveValues() {
        var _a;
        if (this.measureFunc_Count)
            return true;
        // TODO: This may return true, but other code relies on disabling when using avg measures
        if (this.measureFunc_Avg)
            return false;
        return (_a = this.measureSummary.get()) === null || _a === void 0 ? void 0 : _a.hasNegativeValues();
    }
    /** funcType: "Count", Sum" or "Avg" */
    refreshMeasureMetric() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.records)
                return; // if calling the function too early in initialization
            let attrib = (_a = this.measureSummary) === null || _a === void 0 ? void 0 : _a.get();
            if (!attrib)
                return;
            this.records.forEach(this.measureFunc_Count
                ? (rec) => {
                    rec.measure_Self = 1;
                }
                : (rec) => {
                    rec.measure_Self = attrib.getRecordValue(rec);
                });
            this.allAggregates.forEach((aggr) => aggr.resetAggregateMeasures());
            this.blocks.forEach((block) => block.updateAfterFilter(false));
            this.recordDisplay.refreshRecordVis();
            this.updateRecordCount_Active();
            this.refreshAnalytics();
            if (attrib.hasTimeSeriesParent()) {
                yield this.recordDisplay.currentTimeKey.set(attrib.timeKey);
            }
        });
    }
    /**************************************************************
     * ZOOM LEVELS (UI)
     **************************************************************/
    /** -- */
    get dashZoomLevel() {
        var r = "1.00";
        try {
            r = window.localStorage.getItem("kshfZoom") || "1.00";
        }
        catch (error) { }
        return r;
    }
    /** -- */
    attemptToFixBrowserZoomLevel(multiplier = "1.00" /*reset*/, forceReload = false) {
        // Doesn't apply in firefox.
        this.DOM.root.style("zoom", multiplier);
        try {
            window.localStorage.setItem("kshfZoom", multiplier);
        }
        catch (error) { }
        if (forceReload)
            window.location.reload();
    }
    /** -- */
    detectPageZoom() {
        // Other page size detection approaches:
        // document.documentElement.clientWidth;
        // document.documentElement.scrollWidth;
        // CONSTANT - Does not seem to be affected by zoom level. Thus, serves as the "default" (100%) zoom
        var windowOuterWidth = window.outerWidth;
        // On safari,
        // - Page zoomed in: innerWidth < outerwidth.
        // - Page zoomed out: innerWidth > outerWidth
        var windowInnerWidth = window.innerWidth;
        if (window.parent) {
            try {
                // if placed inside an iframe, window.outerWidth measures the size of the top window, not the current frame.
                // so, instead, when there's access to parent, I am using parent's zoom level detection.
                windowOuterWidth = window.parent.outerWidth;
                windowInnerWidth = window.parent.innerWidth;
            }
            catch (exception) {
                console.log("page detect zoom exception: " + exception);
                // use pageZoom URL parameter (TEMP - TODO. Not documented, may be removed in future)
                let URLparams = new URL(document.location).searchParams;
                if (URLparams && URLparams.get("pageZoom")) {
                    return Number(URLparams.get("pageZoom")) || 1;
                }
                return 1;
            }
            // visualViewport: Generally not useful. It reacts to pinch zoom and such.
            // Didn't find a useful case where it's needed
            // window.visualViewport.scale = Chrome only, pinch effect (not useful for detecting zoom level)
            //windowOuterWidth = window.visualViewport.width;
            // on safari, visualViewport.width is the window.innerWidth,
        }
        var pageZoomLevel_num = 1;
        if (windowInnerWidth !== windowOuterWidth) {
            pageZoomLevel_num = windowInnerWidth / windowOuterWidth;
        }
        return pageZoomLevel_num;
    }
    /** -- */
    checkBrowserZoomLevel() {
        var pageZoomLevel_num = this.detectPageZoom();
        // If diff between detected ideal and current is less than 1%, no need to change
        if (Math.abs(pageZoomLevel_num - parseFloat(this.dashZoomLevel)) < 0.01) {
            return;
        }
        setTimeout(() => {
            this.showWarning(i18n.ZoomLevelWarning);
            this.DOM.warningText
                .select(".attemptToFix")
                .on("click", () => this.attemptToFixBrowserZoomLevel(pageZoomLevel_num.toFixed(2), true));
            this.DOM.warningText
                .selectAll(".dismiss")
                .on("click", () => this.hideWarning());
        }, 1000);
    }
    /**************************************************************
     * UPDATING LAYOUT
     **************************************************************/
    /** -- */
    updateLayout() {
        if (this.finalized !== true)
            return;
        this.updateWidth_Total();
        this.updateLayout_Height();
        this.updateMiddlePanelWidth();
        this.panels.bottom.refreshWidth();
    }
    checkAndAdjustBreadcrumbs() {
        if (this.filters_wrap_letItWrap)
            return;
        var wrapped = this.isBreadcrumbAreaWrapped();
        if (wrapped) {
            this.DOM.breadCrumbs_Filter.classed("collapsed", true);
            this.filters_wrap_letItWrap = true;
        }
    }
    /** -- */
    isBreadcrumbAreaWrapped() {
        var DOM = this.DOM.breadCrumbs_Filter.node();
        if (DOM.classList.contains("collapsed"))
            return false; // not wrapped
        var _top = null, _height = null;
        var DOM_items = this.DOM.panel_Basic_In.selectAll(".breadCrumb").nodes();
        return DOM_items.some((DOM_item) => {
            if (_top != null && DOM_item.offsetTop > _top + _height * 0.7) {
                return true;
            }
            _height = DOM_item.offsetHeight;
            _top = DOM_item.offsetTop;
            return false;
        });
    }
    /** -- */
    updateLayout_Height() {
        if (!this.recordDisplay) {
            return; // dashboard not initialized yet
        }
        let divHeight = this.DOM.root.nodes()[0].offsetHeight;
        var divHeight_Total = divHeight -
            this.height_PanelHeader -
            this.height_PanelFooter -
            2 * Base.width_PanelGap;
        // ****************************************************************
        // BOTTOM PANEL
        var targetHeight_bottom = divHeight_Total;
        // In case there is something above the bottom panel, target half the size
        if (this.panels.left.hasBlocks() ||
            this.panels.right.hasBlocks() ||
            this.panels.middle.hasBlocks() ||
            this.recordChartType.get() !== "none") {
            // maximum half height if there is any other content
            targetHeight_bottom *= 0.5;
        }
        this.panels.bottom.setHeightAndLayout(targetHeight_bottom);
        var topPanelsHeight = divHeight_Total - this.panels.bottom.height;
        // ****************************************************************
        // LEFT PANEL
        this.panels.left.setHeightAndLayout(topPanelsHeight);
        // ****************************************************************
        // RIGHT PANEL
        this.panels.right.setHeightAndLayout(topPanelsHeight);
        // ****************************************************************
        // MIDDLE PANEL
        var targetHeight_middle = topPanelsHeight;
        if (this.recordChartType.get() !== "none") {
            targetHeight_middle -= this.recordDisplay.collapsed
                ? this.recordDisplay.height_Header + 4
                : 200;
            targetHeight_middle -= Base.width_PanelGap;
        }
        this.panels.middle.setHeightAndLayout(targetHeight_middle);
        // The part where summary DOM is updated
        this.blocks.forEach((block) => block.refreshHeight());
        if (!this.recordDisplay.collapsed && this.recordChartType.get() !== "none") {
            var listDisplayHeight = topPanelsHeight -
                this.recordDisplay.height_Header -
                this.panels.middle.height;
            if (this.showDropZones && this.panels.middle.isEmpty())
                listDisplayHeight *= 0.5;
            this.recordDisplay.setHeight(listDisplayHeight);
        }
    }
    /** -- */
    updateMiddlePanelWidth() {
        // for some reason, on page load, this variable may be null. urgh.
        var widthMiddlePanel = this.width_Canvas -
            this.panels.left.width_Real_withGap -
            this.panels.right.width_Real_withGap;
        this.panels.middle.setWidth(widthMiddlePanel);
        this.panels.middle.refreshWidth();
        // set summaries are also always placed in middle panel.
        this.blocks
            .filter((block) => block.attrib.type === "setpair")
            .forEach((block) => block.refreshWidth());
        if (this.recordDisplay) {
            this.recordDisplay.setWidth(widthMiddlePanel);
        }
    }
    // ********************************************************************
    // Value access
    // ********************************************************************
    /**  */
    getPercentageValue(_val, sT, breakMode = null, aggr = null) {
        breakMode = breakMode || this.breakdownMode.get();
        if (breakMode === "absolute") {
            return _val;
        }
        if (breakMode === "relative" && aggr) {
            if (!this.isCompared()) {
                return (100 * _val) / this.allRecordsAggr["Active"].measure;
            }
            if (aggr.Active.measure === 0)
                return 0;
            return (100 * _val) / aggr.Active.measure; // divide by aactive measure of aggregate
        }
        if (breakMode === "dependent") {
            return (100 * _val) / this.allRecordsAggr[sT].measure; // divide by total's compared measure
        }
        if (breakMode === "total") {
            return (100 * _val) / this.allRecordsAggr["Active"].measure; // divide by total's Active measure
        }
    }
    /** -- */
    getChartValue(aggr, sT) {
        return this.getPercentageValue(aggr.measure(sT), sT, null, aggr);
    }
    /** -- */
    getMeasureValue(aggr, sT = "Active", breakMode = null, offset = []) {
        var _val = aggr.measure(sT);
        if (sT === "Active" && offset) {
            offset.forEach((t) => {
                _val -= aggr.measure(t);
            });
        }
        return this.getPercentageValue(_val, sT, breakMode, aggr);
    }
    /** -- */
    getMeasureFormattedValue(_val, isSVG = false) {
        return this.measureFunc.get() !== "Count"
            ? this.measureSummary.get().getFormattedValue(_val, isSVG)
            : _val;
    }
    /** -- */
    getValueLabel(_val, isSVG = false, decimals = 1, withPercentage = null) {
        withPercentage =
            withPercentage != null ? withPercentage : this.percentBreakdown;
        if (withPercentage) {
            if (_val !== 100 && _val !== 0)
                _val = _val.toFixed(decimals);
            return _val + (isSVG ? "%" : "<span class='unitName'>%</span>");
        }
        if (this.measureFunc_Count) {
            return Util.formatForItemCount(_val);
        }
        const measureSummary = this.measureSummary.get();
        if (this.measureFunc_Sum &&
            !measureSummary.hasNegativeValues() &&
            !measureSummary.hasFloat) {
            return Util.formatForItemCount(_val, measureSummary.unitName);
        }
        if (_val <= -1000 || _val >= 1000) {
            return Util.formatForItemCount(_val, measureSummary.unitName);
        }
        if (this.measureFunc_Avg) {
            _val = _val.toFixed(decimals);
        }
        return this.measureSummary.get().getFormattedValue(_val);
    }
    // ********************************************************************
    // Export & import
    // ********************************************************************
    /** -- */
    exportData() {
        var out = [];
        var _clear = (_data) => {
            for (let attribName in _data) {
                var attr = _data[attribName];
                if (typeof attr !== "object")
                    continue;
                if (attr == null)
                    continue;
                if (attribName === "_timeseries_") {
                    delete _data[attribName];
                }
                if (attr._timeseries_) {
                    delete attr._timeseries_;
                }
                for (let key in attr) {
                    if (attr[key] === "")
                        delete attr[key];
                    if (typeof attr[key] == "object")
                        _clear(attr[key]);
                }
            }
        };
        this.records.forEach((record) => {
            if (record.filteredOut)
                return;
            let dataCopy = Object.assign({}, record.data);
            _clear(dataCopy);
            out.push(dataCopy);
        });
        return out;
    }
    exportConfig() {
        var config = {
            domID: this.domID !== Base.defaultDOM ? this.domID : undefined,
            recordName: this.recordName,
            source: Object.assign({}, this.options.source),
            description: this.options.description || undefined,
            attribPanelWidth: this.attribPanelWidth !== Base.width_AttribPanelDefault
                ? this.attribPanelWidth
                : undefined,
            summaries: [],
            panels: {},
            recordDisplay: this.recordDisplay.exportConfig(),
            colorTheme: this.colorTheme.exportConfig(),
        };
        Object.values(this.configs).forEach((_cfg) => _cfg.exportConfigTo(config));
        if (!this.measureFunc_Count && this.measureSummary.get()) {
            config.metric = {
                type: this.measureFunc.get(),
                summary: this.measureSummary.get().template.str,
            };
        }
        // ***********************************************
        // Export summary configuration
        var _exportAttrib = (attrib) => {
            if (attrib.isExportable()) {
                var cfg = attrib.exportConfig();
                Util.removeEmptyKeys(cfg);
                config.summaries.push(cfg);
            }
        };
        // export attribs within dashboard, ordered by block, in view order
        Object.values(this.panels).forEach((panel) => panel.blocks.forEach((block) => _exportAttrib(block.attrib)));
        // exports attribs that are not within the panels already / not exported yet
        this.attribs
            .filter((attrib) => { var _a; return !((_a = attrib === null || attrib === void 0 ? void 0 : attrib.block) === null || _a === void 0 ? void 0 : _a.inDashboard); })
            .forEach(_exportAttrib);
        // Export panel configurations
        for (let [name, panel] of Object.entries(this.panels)) {
            if (panel.hasBlocks()) {
                config.panels[name] = panel.exportConfig();
            }
        }
        // Export selections
        var comparedAttrib = this.comparedAttrib;
        if (comparedAttrib) {
            config.selections = {
                summary: comparedAttrib.attribName,
            };
            Base.Compare_List.forEach((cT) => {
                if (!this.selectedAggrs[cT] || !this.selectedAggrs[cT].locked)
                    return;
                config.selections[cT] = this.selectedAggrs[cT].exportAggregateInfo();
            });
        }
        // remove all settings that are {}
        let clearSetting = (_) => {
            if (!Object.keys(config[_]).length)
                delete config[_];
        };
        clearSetting("panels");
        clearSetting("colorTheme");
        Util.removeEmptyKeys(config);
        return config;
    }
}

export { Aggregate, Aggregate_Category, Aggregate_Interval, Aggregate_Interval_Numeric, Aggregate_NoValue, Aggregate_PointCluster, Aggregate_SetPair, Attrib, Attrib_Categorical, Attrib_Content, Attrib_Interval, Attrib_Numeric, Attrib_RecordGeo, Attrib_Set, Attrib_Timeseries, Attrib_Timestamp, Base, Block, Block_Categorical, Block_Content, Block_Interval, Block_Numeric, Block_Set, Block_Timestamp, Browser, Config, ConfigS, DataTable, Filter, Filter_Base, Filter_Categorical, Filter_Interval, Filter_Numeric, Filter_Record, Filter_Text, Filter_Timestamp, LoadLanguage, MapData, Record, RecordDisplay, RecordView, RecordView_List, RecordView_Map, RecordView_Scatter, RecordView_Timeseries, Util, i18n, i18n_EN };
//# sourceMappingURL=keshif.js.map
